<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Disjoint Set (Union Find) 2 - Data Structures and Algorithms for Coding Interviews</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithms for Coding Interviews</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="disjoint-set-union-find-2"><a class="header" href="#disjoint-set-union-find-2">Disjoint Set (Union Find) 2</a></h1>
<h2 id="most-stones-removed-with-same-row-or-column"><a class="header" href="#most-stones-removed-with-same-row-or-column">Most Stones Removed with Same Row or Column</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0947.Most%20Stones%20Removed%20with%20Same%20Row%20or%20Column/README_EN.md
tags:
    - Depth-First Search
    - Union Find
    - Graph
    - Hash Table
</code></pre>
<!-- problem:start -->
<h1 id="947-most-stones-removed-with-same-row-or-column"><a class="header" href="#947-most-stones-removed-with-same-row-or-column"><a href="https://leetcode.com/problems/most-stones-removed-with-same-row-or-column">947. Most Stones Removed with Same Row or Column</a></a></h1>
<p><a href="/solution/0900-0999/0947.Most%20Stones%20Removed%20with%20Same%20Row%20or%20Column/README.html">中文文档</a></p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<!-- description:start -->
<p>On a 2D plane, we place <code>n</code> stones at some integer coordinate points. Each coordinate point may have at most one stone.</p>
<p>A stone can be removed if it shares either <strong>the same row or the same column</strong> as another stone that has not been removed.</p>
<p>Given an array <code>stones</code> of length <code>n</code> where <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of the <code>i<sup>th</sup></code> stone, return <em>the largest possible number of stones that can be removed</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> stones = [[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> [0,0] is the only stone on the plane, so you cannot remove it.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>No two stones are at the same coordinate point.</li>
</ul>
<!-- description:end -->
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-union-find"><a class="header" href="#solution-1-union-find">Solution 1: Union-Find</a></h3>
<p>We can use a union-find data structure to maintain the relationships between stones. If two stones are in the same row or column, we consider them to be connected and use the union-find to link them together. In the end, we count how many connected components there are in the union-find, which corresponds to the number of stones that can remain. Therefore, the total number of stones that can be removed is the total number of stones minus the number of stones that can remain. We can also record the number of successful unions during the merge process, which equals the number of stones that can be removed.</p>
<p>The time complexity is $O(n^2 \times \alpha(n))$, and the space complexity is $O(n)$. Here, $n$ is the number of stones.</p>
<!-- tabs:start -->
<h4 id="python3"><a class="header" href="#python3">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True


class Solution:
    def removeStones(self, stones: List[List[int]]) -&gt; int:
        uf = UnionFind(len(stones))
        ans = 0
        for i, (x1, y1) in enumerate(stones):
            for j, (x2, y2) in enumerate(stones[:i]):
                if x1 == x2 or y1 == y2:
                    ans += uf.union(i, j)
        return ans
</code></pre>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }
}

class Solution {
    public int removeStones(int[][] stones) {
        int n = stones.length;
        UnionFind uf = new UnionFind(n);
        int ans = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ans += uf.union(i, j) ? 1 : 0;
                }
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c"><a class="header" href="#c">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) {
        int n = stones.size();
        UnionFind uf(n);
        int ans = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ans += uf.unite(i, j);
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go"><a class="header" href="#go">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func removeStones(stones [][]int) (ans int) {
	n := len(stones)
	uf := newUnionFind(n)
	for i, s1 := range stones {
		for j, s2 := range stones[:i] {
			if s1[0] == s2[0] || s1[1] == s2[1] {
				if uf.union(i, j) {
					ans++
				}
			}
		}
	}
	return
}
</code></pre>
<h4 id="typescript"><a class="header" href="#typescript">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    p: number[];
    size: number[];
    constructor(n: number) {
        this.p = Array.from({ length: n }, (_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }

    union(a: number, b: number): boolean {
        const [pa, pb] = [this.find(a), this.find(b)];
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }
}

function removeStones(stones: number[][]): number {
    const n = stones.length;
    const uf = new UnionFind(n);
    let ans = 0;
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; i; ++j) {
            if (stones[i][0] === stones[j][0] || stones[i][1] === stones[j][1]) {
                ans += uf.union(i, j) ? 1 : 0;
            }
        }
    }
    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-union-find-optimized"><a class="header" href="#solution-2-union-find-optimized">Solution 2: Union-Find (Optimized)</a></h3>
<p>We can add an offset to the y-coordinates of the stones, allowing us to unify the x-coordinates and y-coordinates. Then, we use a union-find data structure to maintain the relationship between x-coordinates and y-coordinates.</p>
<p>We iterate through each stone, merging its x-coordinate with its y-coordinate.</p>
<p>Finally, we iterate through all the stones again, putting the root node of each stone's x-coordinate into a set. The number of elements in this set represents the number of stones that can remain. Therefore, the total number of stones that can be removed is the total number of stones minus the number of stones that can remain.</p>
<p>The time complexity is $O(n \times \alpha(m))$, and the space complexity is $O(m)$. Here, $n$ and $m$ represent the number of stones and the maximum value of the coordinates, respectively.</p>
<!-- tabs:start -->
<h4 id="python3-1"><a class="header" href="#python3-1">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True


class Solution:
    def removeStones(self, stones: List[List[int]]) -&gt; int:
        m = 10001
        uf = UnionFind(m &lt;&lt; 1)
        for x, y in stones:
            uf.union(x, y + m)
        return len(stones) - len({uf.find(x) for x, _ in stones})
</code></pre>
<h4 id="java-1"><a class="header" href="#java-1">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }
}

class Solution {
    public int removeStones(int[][] stones) {
        int m = 10001;
        UnionFind uf = new UnionFind(m &lt;&lt; 1);
        for (var st : stones) {
            uf.union(st[0], st[1] + m);
        }
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for (var st : stones) {
            s.add(uf.find(st[0]));
        }
        return stones.length - s.size();
    }
}
</code></pre>
<h4 id="c-1"><a class="header" href="#c-1">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) {
        int m = 10001;
        UnionFind uf(m &lt;&lt; 1);
        for (auto&amp; st : stones) {
            uf.unite(st[0], st[1] + m);
        }
        unordered_set&lt;int&gt; s;
        for (auto&amp; st : stones) {
            s.insert(uf.find(st[0]));
        }
        return stones.size() - s.size();
    }
};
</code></pre>
<h4 id="go-1"><a class="header" href="#go-1">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func removeStones(stones [][]int) (ans int) {
	m := 10001
	uf := newUnionFind(m &lt;&lt; 1)
	for _, st := range stones {
		uf.union(st[0], st[1]+m)
	}
	s := map[int]bool{}
	for _, st := range stones {
		s[uf.find(st[0])] = true
	}
	return len(stones) - len(s)
}
</code></pre>
<h4 id="typescript-1"><a class="header" href="#typescript-1">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    p: number[];
    size: number[];
    constructor(n: number) {
        this.p = Array.from({ length: n }, (_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }

    union(a: number, b: number): boolean {
        const [pa, pb] = [this.find(a), this.find(b)];
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }
}

function removeStones(stones: number[][]): number {
    const m = 10001;
    const uf = new UnionFind(m &lt;&lt; 1);
    for (const [x, y] of stones) {
        uf.union(x, y + m);
    }
    const s = new Set&lt;number&gt;();
    for (const [x, _] of stones) {
        s.add(uf.find(x));
    }
    return stones.length - s.size;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-dfs"><a class="header" href="#solution-3-dfs">Solution 3: DFS</a></h3>
<!-- tabs:start -->
<h4 id="typescript-2"><a class="header" href="#typescript-2">TypeScript</a></h4>
<pre><code class="language-ts">function removeStones(stones: number[][]): number {
    const n = stones.length;
    const g: number[][] = Array.from({ length: n }, () =&gt; []);

    for (let i = 0; i &lt; n; i++) {
        const [y, x] = stones[i];
        for (let j = i + 1; j &lt; n; j++) {
            if (y === stones[j][0] || x === stones[j][1]) {
                g[i].push(j);
                g[j].push(i);
            }
        }
    }

    const dfs = (i: number) =&gt; {
        const seen = new Set&lt;number&gt;();

        let q = [i];
        while (q.length) {
            const qNext: number[] = [];

            for (const i of q) {
                if (seen.has(i)) continue;
                seen.add(i);
                set.delete(i);
                qNext.push(...g[i]);
            }

            q = qNext;
        }
    };

    const set = new Set(Array.from({ length: n }, (_, i) =&gt; i));
    let ans = n;
    for (const i of set) {
        dfs(i);
        ans--;
    }

    return ans;
}
</code></pre>
<h4 id="javascript"><a class="header" href="#javascript">JavaScript</a></h4>
<pre><code class="language-js">function removeStones(stones) {
    const n = stones.length;
    const g = Array.from({ length: n }, () =&gt; []);

    for (let i = 0; i &lt; n; i++) {
        const [y, x] = stones[i];
        for (let j = i + 1; j &lt; n; j++) {
            if (y === stones[j][0] || x === stones[j][1]) {
                g[i].push(j);
                g[j].push(i);
            }
        }
    }

    const dfs = i =&gt; {
        const seen = new Set();

        let q = [i];
        while (q.length) {
            const qNext = [];

            for (const i of q) {
                if (seen.has(i)) continue;
                seen.add(i);
                set.delete(i);
                qNext.push(...g[i]);
            }

            q = qNext;
        }
    };

    const set = new Set(Array.from({ length: n }, (_, i) =&gt; i));
    let ans = n;
    for (const i of set) {
        dfs(i);
        ans--;
    }

    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.HashMap;

// 移除最多的同行或同列石头
// n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头
// 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头
// 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置
// 返回 可以移除的石子 的最大数量。
// 测试链接 : https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
public class Code01_MostStonesRemovedWithSameRowOrColumn {

	// key : 某行
	// value : 第一次遇到的石头编号
	public static HashMap&lt;Integer, Integer&gt; rowFirst = new HashMap&lt;Integer, Integer&gt;();

	public static HashMap&lt;Integer, Integer&gt; colFirst = new HashMap&lt;Integer, Integer&gt;();

	public static int MAXN = 1001;

	public static int[] father = new int[MAXN];

	public static int sets;

	public static void build(int n) {
		rowFirst.clear();
		colFirst.clear();
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
		}
		sets = n;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			sets--;
		}
	}

	public static int removeStones(int[][] stones) {
		int n = stones.length;
		build(n);
		for (int i = 0; i &lt; n; i++) {
			int row = stones[i][0];
			int col = stones[i][1];
			if (!rowFirst.containsKey(row)) {
				rowFirst.put(row, i);
			} else {
				union(i, rowFirst.get(row));
			}
			if (!colFirst.containsKey(col)) {
				colFirst.put(col, i);
			} else {
				union(i, colFirst.get(col));
			}
		}
		return n - sets;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<h2 id="find-all-people-with-secret"><a class="header" href="#find-all-people-with-secret">Find All People With Secret</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/2000-2099/2092.Find%20All%20People%20With%20Secret/README_EN.md
rating: 2003
source: Weekly Contest 269 Q4
tags:
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Graph
    - Sorting
</code></pre>
<!-- problem:start -->
<h1 id="2092-find-all-people-with-secret"><a class="header" href="#2092-find-all-people-with-secret"><a href="https://leetcode.com/problems/find-all-people-with-secret">2092. Find All People With Secret</a></a></h1>
<p><a href="/solution/2000-2099/2092.Find%20All%20People%20With%20Secret/README.html">中文文档</a></p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<!-- description:start -->
<p>You are given an integer <code>n</code> indicating there are <code>n</code> people numbered from <code>0</code> to <code>n - 1</code>. You are also given a <strong>0-indexed</strong> 2D integer array <code>meetings</code> where <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> indicates that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> have a meeting at <code>time<sub>i</sub></code>. A person may attend <strong>multiple meetings</strong> at the same time. Finally, you are given an integer <code>firstPerson</code>.</p>
<p>Person <code>0</code> has a <strong>secret</strong> and initially shares the secret with a person <code>firstPerson</code> at time <code>0</code>. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person <code>x<sub>i</sub></code> has the secret at <code>time<sub>i</sub></code>, then they will share the secret with person <code>y<sub>i</sub></code>, and vice versa.</p>
<p>The secrets are shared <strong>instantaneously</strong>. That is, a person may receive the secret and share it with people in other meetings within the same time frame.</p>
<p>Return <em>a list of all the people that have the secret after all the meetings have taken place. </em>You may return the answer in <strong>any order</strong>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,5]
<strong>Explanation:
</strong>At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.​​​​
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>Output:</strong> [0,1,3]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
	<li><code>meetings[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-1"><a class="header" href="#solutions-1">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1"><a class="header" href="#solution-1">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-2"><a class="header" href="#python3-2">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def findAllPeople(
        self, n: int, meetings: List[List[int]], firstPerson: int
    ) -&gt; List[int]:
        vis = [False] * n
        vis[0] = vis[firstPerson] = True
        meetings.sort(key=lambda x: x[2])
        i, m = 0, len(meetings)
        while i &lt; m:
            j = i
            while j + 1 &lt; m and meetings[j + 1][2] == meetings[i][2]:
                j += 1
            s = set()
            g = defaultdict(list)
            for x, y, _ in meetings[i : j + 1]:
                g[x].append(y)
                g[y].append(x)
                s.update([x, y])
            q = deque([u for u in s if vis[u]])
            while q:
                u = q.popleft()
                for v in g[u]:
                    if not vis[v]:
                        vis[v] = True
                        q.append(v)
            i = j + 1
        return [i for i, v in enumerate(vis) if v]
</code></pre>
<h4 id="java-2"><a class="header" href="#java-2">Java</a></h4>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int firstPerson) {
        boolean[] vis = new boolean[n];
        vis[0] = true;
        vis[firstPerson] = true;
        int m = meetings.length;
        Arrays.sort(meetings, Comparator.comparingInt(a -&gt; a[2]));
        for (int i = 0; i &lt; m;) {
            int j = i;
            for (; j + 1 &lt; m &amp;&amp; meetings[j + 1][2] == meetings[i][2]; ++j)
                ;
            Map&lt;Integer, List&lt;Integer&gt;&gt; g = new HashMap&lt;&gt;();
            Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
            for (int k = i; k &lt;= j; ++k) {
                int x = meetings[k][0], y = meetings[k][1];
                g.computeIfAbsent(x, key -&gt; new ArrayList&lt;&gt;()).add(y);
                g.computeIfAbsent(y, key -&gt; new ArrayList&lt;&gt;()).add(x);
                s.add(x);
                s.add(y);
            }
            Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
            for (int u : s) {
                if (vis[u]) {
                    q.offer(u);
                }
            }
            while (!q.isEmpty()) {
                int u = q.poll();
                for (int v : g.getOrDefault(u, Collections.emptyList())) {
                    if (!vis[v]) {
                        vis[v] = true;
                        q.offer(v);
                    }
                }
            }
            i = j + 1;
        }
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; ++i) {
            if (vis[i]) {
                ans.add(i);
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-2"><a class="header" href="#c-2">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        vector&lt;bool&gt; vis(n);
        vis[0] = vis[firstPerson] = true;
        sort(meetings.begin(), meetings.end(), [&amp;](const auto&amp; x, const auto&amp; y) {
            return x[2] &lt; y[2];
        });
        for (int i = 0, m = meetings.size(); i &lt; m;) {
            int j = i;
            for (; j + 1 &lt; m &amp;&amp; meetings[j + 1][2] == meetings[i][2]; ++j)
                ;
            unordered_map&lt;int, vector&lt;int&gt;&gt; g;
            unordered_set&lt;int&gt; s;
            for (int k = i; k &lt;= j; ++k) {
                int x = meetings[k][0], y = meetings[k][1];
                g[x].push_back(y);
                g[y].push_back(x);
                s.insert(x);
                s.insert(y);
            }
            queue&lt;int&gt; q;
            for (int u : s)
                if (vis[u])
                    q.push(u);
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v : g[u]) {
                    if (!vis[v]) {
                        vis[v] = true;
                        q.push(v);
                    }
                }
            }
            i = j + 1;
        }
        vector&lt;int&gt; ans;
        for (int i = 0; i &lt; n; ++i)
            if (vis[i])
                ans.push_back(i);
        return ans;
    }
};
</code></pre>
<h4 id="go-2"><a class="header" href="#go-2">Go</a></h4>
<pre><code class="language-go">func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
	vis := make([]bool, n)
	vis[0], vis[firstPerson] = true, true
	sort.Slice(meetings, func(i, j int) bool {
		return meetings[i][2] &lt; meetings[j][2]
	})
	for i, j, m := 0, 0, len(meetings); i &lt; m; i = j + 1 {
		j = i
		for j+1 &lt; m &amp;&amp; meetings[j+1][2] == meetings[i][2] {
			j++
		}
		g := map[int][]int{}
		s := map[int]bool{}
		for _, e := range meetings[i : j+1] {
			x, y := e[0], e[1]
			g[x] = append(g[x], y)
			g[y] = append(g[y], x)
			s[x], s[y] = true, true
		}
		q := []int{}
		for u := range s {
			if vis[u] {
				q = append(q, u)
			}
		}
		for len(q) &gt; 0 {
			u := q[0]
			q = q[1:]
			for _, v := range g[u] {
				if !vis[v] {
					vis[v] = true
					q = append(q, v)
				}
			}
		}
	}
	var ans []int
	for i, v := range vis {
		if v {
			ans = append(ans, i)
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-3"><a class="header" href="#typescript-3">TypeScript</a></h4>
<pre><code class="language-ts">function findAllPeople(n: number, meetings: number[][], firstPerson: number): number[] {
    let parent: Array&lt;number&gt; = Array.from({ length: n + 1 }, (v, i) =&gt; i);
    parent[firstPerson] = 0;

    function findParent(index: number): number {
        if (parent[index] != index) parent[index] = findParent(parent[index]);
        return parent[index];
    }

    let map = new Map&lt;number, Array&lt;Array&lt;number&gt;&gt;&gt;();
    for (let meeting of meetings) {
        const time = meeting[2];
        let members: Array&lt;Array&lt;number&gt;&gt; = map.get(time) || new Array();
        members.push(meeting);
        map.set(time, members);
    }
    const times = [...map.keys()].sort((a, b) =&gt; a - b);
    for (let time of times) {
        // round 1
        for (let meeting of map.get(time)) {
            let [a, b] = meeting;
            if (!parent[findParent(a)] || !parent[findParent(b)]) {
                parent[findParent(a)] = 0;
                parent[findParent(b)] = 0;
            }
            parent[findParent(a)] = parent[findParent(b)];
        }
        // round 2
        for (let meeting of map.get(time)) {
            let [a, b] = meeting;
            if (!parent[findParent(a)] || !parent[findParent(b)]) {
                parent[findParent(a)] = 0;
                parent[findParent(b)] = 0;
            } else {
                parent[a] = a;
                parent[b] = b;
            }
        }
    }

    let ans = new Array&lt;number&gt;();
    for (let i = 0; i &lt;= n; i++) {
        if (!parent[findParent(i)]) {
            ans.push(i);
        }
    }
    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// 找出知晓秘密的所有专家
// 给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号
// 另外给你一个下标从 0 开始的二维整数数组 meetings
// 其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会
// 一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson
// 专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson
// 接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播
// 更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密
// 那么他将会与专家 yi 分享这个秘密，反之亦然。秘密共享是 瞬时发生 的
// 也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享
// 在所有会议都结束之后，返回所有知晓这个秘密的专家列表
// 你可以按 任何顺序 返回答案
// 链接测试 : https://leetcode.com/problems/find-all-people-with-secret/
public class Code02_FindAllPeopleWithSecret {

	public static int MAXN = 100001;

	public static int[] father = new int[MAXN];

	// 集合的标签信息 : 设置集合的一些属性
	// 属性在哪？secret[代表元素] 代表集合的属性
	public static boolean[] secret = new boolean[MAXN];

	public static void build(int n, int first) {
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
			secret[i] = false;
		}
		father[first] = 0;
		secret[0] = true;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			secret[fy] |= secret[fx];
		}
	}

	// 会议排序 : m * log m
	// 处理过程 : O(m)
	// 收集答案 : O(n)
	public static List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int first) {
		build(n, first);
		// {0 : 专家   1 : 专家编号   2 : 时刻}
		Arrays.sort(meetings, (a, b) -&gt; a[2] - b[2]);
		int m = meetings.length;
		for (int l = 0, r; l &lt; m;) {
			r = l;
			while (r + 1 &lt; m &amp;&amp; meetings[l][2] == meetings[r + 1][2]) {
				r++;
			}
			// l....r这些会议，一定是一个时刻
			for (int i = l; i &lt;= r; i++) {
				union(meetings[i][0], meetings[i][1]);
			}
			// 有小的撤销行为，但这不是可撤销并查集
			// 只是每一批没有知道秘密的专家重新建立集合而已
			for (int i = l, a, b; i &lt;= r; i++) {
				a = meetings[i][0];
				b = meetings[i][1];
				if (!secret[find(a)]) {
					father[a] = a;
				}
				if (!secret[find(b)]) {
					father[b] = b;
				}
			}
			l = r + 1;
		}
		List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
		for (int i = 0; i &lt; n; i++) {
			if (secret[find(i)]) {
				ans.add(i);
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<h2 id="number-of-good-paths"><a class="header" href="#number-of-good-paths">Number of Good Paths</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/2400-2499/2421.Number%20of%20Good%20Paths/README_EN.md
rating: 2444
source: Weekly Contest 312 Q4
tags:
    - Tree
    - Union Find
    - Graph
    - Array
    - Hash Table
    - Sorting
</code></pre>
<!-- problem:start -->
<h1 id="2421-number-of-good-paths"><a class="header" href="#2421-number-of-good-paths"><a href="https://leetcode.com/problems/number-of-good-paths">2421. Number of Good Paths</a></a></h1>
<p><a href="/solution/2400-2499/2421.Number%20of%20Good%20Paths/README.html">中文文档</a></p>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<!-- description:start -->
<p>There is a tree (i.e. a connected, undirected graph with no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> edges.</p>
<p>You are given a <strong>0-indexed</strong> integer array <code>vals</code> of length <code>n</code> where <code>vals[i]</code> denotes the value of the <code>i<sup>th</sup></code> node. You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>
<p>A <strong>good path</strong> is a simple path that satisfies the following conditions:</p>
<ol>
	<li>The starting node and the ending node have the <strong>same</strong> value.</li>
	<li>All nodes between the starting node and the ending node have values <strong>less than or equal to</strong> the starting node (i.e. the starting node&#39;s value should be the maximum value along the path).</li>
</ol>
<p>Return <em>the number of distinct good paths</em>.</p>
<p>Note that a path and its reverse are counted as the <strong>same</strong> path. For example, <code>0 -&gt; 1</code> is considered to be the same as <code>1 -&gt; 0</code>. A single node is also considered as a valid path.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2421.Number%20of%20Good%20Paths/images/f9caaac15b383af9115c5586779dec5.png" style="width: 400px; height: 333px;" />
<pre>
<strong>Input:</strong> vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There is 1 additional good path: 1 -&gt; 0 -&gt; 2 -&gt; 4.
(The reverse path 4 -&gt; 2 -&gt; 0 -&gt; 1 is treated as the same as 1 -&gt; 0 -&gt; 2 -&gt; 4.)
Note that 0 -&gt; 2 -&gt; 3 is not a good path because vals[2] &gt; vals[0].
</pre>
<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2421.Number%20of%20Good%20Paths/images/149d3065ec165a71a1b9aec890776ff.png" style="width: 273px; height: 350px;" />
<pre>
<strong>Input:</strong> vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There are 2 additional good paths: 0 -&gt; 1 and 2 -&gt; 3.
</pre>
<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2421.Number%20of%20Good%20Paths/images/31705e22af3d9c0a557459bc7d1b62d.png" style="width: 100px; height: 88px;" />
<pre>
<strong>Input:</strong> vals = [1], edges = []
<strong>Output:</strong> 1
<strong>Explanation:</strong> The tree consists of only one node, so there is one good path.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == vals.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= vals[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-2"><a class="header" href="#solutions-2">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-sorting--union-find"><a class="header" href="#solution-1-sorting--union-find">Solution 1: Sorting + Union Find</a></h3>
<p>To ensure that the starting point (or endpoint) of the path is greater than or equal to all points on the path, we can consider sorting all points from small to large first, then traverse and add them to the connected component, specifically as follows:</p>
<p>When traversing to point $a$, for the adjacent point $b$ that is less than or equal to $vals[a]$, if they are not in the same connected component, they can be merged. And we can use all points in the connected component where point $a$ is located with a value of $vals[a]$ as the starting point, and all points in the connected component where point $b$ is located with a value of $vals[a]$ as the endpoint. The product of the number of the two types of points is the contribution to the answer when adding point $a$.</p>
<p>The time complexity is $O(n \times \log n)$.</p>
<!-- tabs:start -->
<h4 id="python3-3"><a class="header" href="#python3-3">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -&gt; int:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        g = defaultdict(list)
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)

        n = len(vals)
        p = list(range(n))
        size = defaultdict(Counter)
        for i, v in enumerate(vals):
            size[i][v] = 1

        ans = n
        for v, a in sorted(zip(vals, range(n))):
            for b in g[a]:
                if vals[b] &gt; v:
                    continue
                pa, pb = find(a), find(b)
                if pa != pb:
                    ans += size[pa][v] * size[pb][v]
                    p[pa] = pb
                    size[pb][v] += size[pa][v]
        return ans
</code></pre>
<h4 id="java-3"><a class="header" href="#java-3">Java</a></h4>
<pre><code class="language-java">class Solution {
    private int[] p;

    public int numberOfGoodPaths(int[] vals, int[][] edges) {
        int n = vals.length;
        p = new int[n];
        int[][] arr = new int[n][2];
        List&lt;Integer&gt;[] g = new List[n];
        Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;());
        for (int[] e : edges) {
            int a = e[0], b = e[1];
            g[a].add(b);
            g[b].add(a);
        }
        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; size = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            arr[i] = new int[] {vals[i], i};
            size.computeIfAbsent(i, k -&gt; new HashMap&lt;&gt;()).put(vals[i], 1);
        }
        Arrays.sort(arr, (a, b) -&gt; a[0] - b[0]);
        int ans = n;
        for (var e : arr) {
            int v = e[0], a = e[1];
            for (int b : g[a]) {
                if (vals[b] &gt; v) {
                    continue;
                }
                int pa = find(a), pb = find(b);
                if (pa != pb) {
                    ans += size.get(pa).getOrDefault(v, 0) * size.get(pb).getOrDefault(v, 0);
                    p[pa] = pb;
                    size.get(pb).put(
                        v, size.get(pb).getOrDefault(v, 0) + size.get(pa).getOrDefault(v, 0));
                }
            }
        }
        return ans;
    }

    private int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
}
</code></pre>
<h4 id="c-3"><a class="header" href="#c-3">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numberOfGoodPaths(vector&lt;int&gt;&amp; vals, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = vals.size();
        vector&lt;int&gt; p(n);
        iota(p.begin(), p.end(), 0);
        function&lt;int(int)&gt; find;
        find = [&amp;](int x) {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        };
        vector&lt;vector&lt;int&gt;&gt; g(n);
        for (auto&amp; e : edges) {
            int a = e[0], b = e[1];
            g[a].push_back(b);
            g[b].push_back(a);
        }
        unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; size;
        vector&lt;pair&lt;int, int&gt;&gt; arr(n);
        for (int i = 0; i &lt; n; ++i) {
            arr[i] = {vals[i], i};
            size[i][vals[i]] = 1;
        }
        sort(arr.begin(), arr.end());
        int ans = n;
        for (auto [v, a] : arr) {
            for (int b : g[a]) {
                if (vals[b] &gt; v) {
                    continue;
                }
                int pa = find(a), pb = find(b);
                if (pa != pb) {
                    ans += size[pa][v] * size[pb][v];
                    p[pa] = pb;
                    size[pb][v] += size[pa][v];
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-3"><a class="header" href="#go-3">Go</a></h4>
<pre><code class="language-go">func numberOfGoodPaths(vals []int, edges [][]int) int {
	n := len(vals)
	p := make([]int, n)
	size := map[int]map[int]int{}
	type pair struct{ v, i int }
	arr := make([]pair, n)
	for i, v := range vals {
		p[i] = i
		if size[i] == nil {
			size[i] = map[int]int{}
		}
		size[i][v] = 1
		arr[i] = pair{v, i}
	}

	var find func(x int) int
	find = func(x int) int {
		if p[x] != x {
			p[x] = find(p[x])
		}
		return p[x]
	}

	sort.Slice(arr, func(i, j int) bool { return arr[i].v &lt; arr[j].v })
	g := make([][]int, n)
	for _, e := range edges {
		a, b := e[0], e[1]
		g[a] = append(g[a], b)
		g[b] = append(g[b], a)
	}
	ans := n
	for _, e := range arr {
		v, a := e.v, e.i
		for _, b := range g[a] {
			if vals[b] &gt; v {
				continue
			}
			pa, pb := find(a), find(b)
			if pa != pb {
				ans += size[pb][v] * size[pa][v]
				p[pa] = pb
				size[pb][v] += size[pa][v]
			}
		}
	}
	return ans
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.Arrays;

// 好路径的数目
// 给你一棵 n 个节点的树（连通无向无环的图）
// 节点编号从0到n-1，且恰好有n-1条边
// 给你一个长度为 n 下标从 0 开始的整数数组 vals
// 分别表示每个节点的值。同时给你一个二维整数数组 edges
// 其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边
// 好路径需要满足以下条件：开始和结束节点的值相同、 路径中所有值都小于等于开始的值
// 请你返回不同好路径的数目
// 注意，一条路径和它反向的路径算作 同一 路径
// 比方说， 0 -&gt; 1 与 1 -&gt; 0 视为同一条路径。单个节点也视为一条合法路径
// 测试链接 : https://leetcode.com/problems/number-of-good-paths/
public class Code03_NumberOfGoodPaths {

	public static int MAXN = 30001;

	// 需要保证集合中，代表节点的值，一定是整个集合的最大值
	public static int[] father = new int[MAXN];

	// 集合中最大值的次数，也就是 集合中代表节点的值有几个
	public static int[] maxcnt = new int[MAXN];

	public static void build(int n) {
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
			maxcnt[i] = 1;
		}
	}

	// 这个并查集的优化只来自扁平化
	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	// 核心！
	// 注意以下的写法！
	// 谁的值大，谁做代表节点
	// 同时注意 maxcnt 的更新
	public static int union(int x, int y, int[] vals) {
		// fx : x所在集团的代表节点，同时也是x所在集团的最大值下标
		int fx = find(x);
		// fy : y所在集团的代表节点，同时也是y所在集团的最大值下标
		int fy = find(y);
		int path = 0;
		if (vals[fx] &gt; vals[fy]) {
			father[fy] = fx;
		} else if (vals[fx] &lt; vals[fy]) {
			father[fx] = fy;
		} else {
			// 两个集团最大值一样！
			path = maxcnt[fx] * maxcnt[fy];
			father[fy] = fx;
			maxcnt[fx] += maxcnt[fy];
		}
		return path;
	}

	public static int numberOfGoodPaths(int[] vals, int[][] edges) {
		int n = vals.length;
		build(n);
		int ans = n;
		// 课上重点讲这个核心排序！
		// 处理边的时候，依次从小节点往大节点处理
		Arrays.sort(edges, (e1, e2) -&gt; (Math.max(vals[e1[0]], vals[e1[1]]) - Math.max(vals[e2[0]], vals[e2[1]])));
		for (int[] edge : edges) {
			ans += union(edge[0], edge[1], vals);
		}
		return ans;
	}

	// 课上讲解的例子1和例子2
	public static void main(String[] args) {
		// 课上例子1
		//              0  1  2  3  4  5  6  7
		int[] vals1 = { 2, 1, 1, 2, 2, 1, 1, 2 };
		int[][] edges1 = { 
				{ 0, 1 },
				{ 0, 2 },
				{ 1, 3 },
				{ 2, 4 },
				{ 2, 5 },
				{ 5, 6 },
				{ 6, 7 } };
		System.out.println(numberOfGoodPaths(vals1, edges1));

		// 课上例子2
		//              0  1  2  3  4  5  6  7  8  9 10 11 12
		int[] vals2 = { 1, 2, 2, 3, 1, 2, 2, 1, 1, 3, 3, 3, 3 };
		int[][] edges2 = {
				{ 0, 1 },
				{ 0, 2 },
				{ 0, 3 },
				{ 1, 4 },
				{ 4, 7 },
				{ 4, 8 },
				{ 3, 5 },
				{ 3, 6 },
				{ 6, 9 },
				{ 6, 10 },
				{ 6, 11 },
				{ 9, 12 } };
		System.out.println(numberOfGoodPaths(vals2, edges2));
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<h2 id="minimize-malware-spread-ii"><a class="header" href="#minimize-malware-spread-ii">Minimize Malware Spread II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0928.Minimize%20Malware%20Spread%20II/README_EN.md
tags:
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Graph
    - Array
    - Hash Table
</code></pre>
<!-- problem:start -->
<h1 id="928-minimize-malware-spread-ii"><a class="header" href="#928-minimize-malware-spread-ii"><a href="https://leetcode.com/problems/minimize-malware-spread-ii">928. Minimize Malware Spread II</a></a></h1>
<p><a href="/solution/0900-0999/0928.Minimize%20Malware%20Spread%20II/README.html">中文文档</a></p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<!-- description:start -->
<p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>
<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>
<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>
<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>
<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-3"><a class="header" href="#solutions-3">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-union-find-1"><a class="header" href="#solution-1-union-find-1">Solution 1: Union-Find</a></h3>
<p>We can use the union-find data structure to merge all nodes that are not in $initial$ and satisfy $graph[i][j] = 1$.</p>
<p>Next, we create a hash table $g$, where $g[i]$ represents the root node of the connected component that is connected to node $i$. We also need a counter $cnt$ to count how many initial nodes each root node is infected by.</p>
<p>For each initially infected node $i$, we traverse all nodes $j$ connected to node $i$. If node $j$ is not in $initial$, we add the root node of node $j$ to the set $g[i]$. At the same time, we count how many initial nodes each root node is infected by and save the result in the counter $cnt$.</p>
<p>Then, we use a variable $ans$ to record the answer, and $mx$ to record the maximum number of infected nodes that can be reduced. Initially, $ans = 0$, $mx = -1$.</p>
<p>We traverse all initially infected nodes. For each node $i$, we traverse all root nodes in $g[i]$. If a root node is only infected by one initial node, we add the size of the connected component where the root node is located to $t$. If $t &gt; mx$ or $t = mx$ and $i &lt; ans$, we update $ans = i$, $mx = t$.</p>
<p>Finally, we return $ans$.</p>
<p>The time complexity is $O(n^2 \times \alpha(n))$, and the space complexity is $O(n^2)$. Where $n$ is the number of nodes, and $\alpha(n)$ is the inverse Ackermann function.</p>
<!-- tabs:start -->
<h4 id="python3-4"><a class="header" href="#python3-4">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    __slots__ = "p", "size"

    def __init__(self, n: int):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -&gt; int:
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a: int, b: int) -&gt; bool:
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True

    def get_size(self, root: int) -&gt; int:
        return self.size[root]


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int:
        n = len(graph)
        s = set(initial)
        uf = UnionFind(n)
        for i in range(n):
            if i not in s:
                for j in range(i + 1, n):
                    graph[i][j] and j not in s and uf.union(i, j)

        g = defaultdict(set)
        cnt = Counter()
        for i in initial:
            for j in range(n):
                if j not in s and graph[i][j]:
                    g[i].add(uf.find(j))
            for root in g[i]:
                cnt[root] += 1

        ans, mx = 0, -1
        for i in initial:
            t = sum(uf.get_size(root) for root in g[i] if cnt[root] == 1)
            if t &gt; mx or (t == mx and i &lt; ans):
                ans, mx = i, t
        return ans
</code></pre>
<h4 id="java-4"><a class="header" href="#java-4">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    public int size(int root) {
        return size[root];
    }
}

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] s = new boolean[n];
        for (int i : initial) {
            s[i] = true;
        }
        UnionFind uf = new UnionFind(n);
        for (int i = 0; i &lt; n; ++i) {
            if (!s[i]) {
                for (int j = i + 1; j &lt; n; ++j) {
                    if (graph[i][j] == 1 &amp;&amp; !s[j]) {
                        uf.union(i, j);
                    }
                }
            }
        }
        Set&lt;Integer&gt;[] g = new Set[n];
        Arrays.setAll(g, k -&gt; new HashSet&lt;&gt;());
        int[] cnt = new int[n];
        for (int i : initial) {
            for (int j = 0; j &lt; n; ++j) {
                if (!s[j] &amp;&amp; graph[i][j] == 1) {
                    g[i].add(uf.find(j));
                }
            }
            for (int root : g[i]) {
                ++cnt[root];
            }
        }
        int ans = 0, mx = -1;
        for (int i : initial) {
            int t = 0;
            for (int root : g[i]) {
                if (cnt[root] == 1) {
                    t += uf.size(root);
                }
            }
            if (t &gt; mx || (t == mx &amp;&amp; i &lt; ans)) {
                ans = i;
                mx = t;
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-4"><a class="header" href="#c-4">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    int getSize(int root) {
        return size[root];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int minMalwareSpread(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; initial) {
        int n = graph.size();
        bool s[n];
        memset(s, false, sizeof(s));
        for (int i : initial) {
            s[i] = true;
        }
        UnionFind uf(n);
        for (int i = 0; i &lt; n; ++i) {
            if (!s[i]) {
                for (int j = i + 1; j &lt; n; ++j) {
                    if (graph[i][j] &amp;&amp; !s[j]) {
                        uf.unite(i, j);
                    }
                }
            }
        }
        unordered_set&lt;int&gt; g[n];
        int cnt[n];
        memset(cnt, 0, sizeof(cnt));
        for (int i : initial) {
            for (int j = 0; j &lt; n; ++j) {
                if (!s[j] &amp;&amp; graph[i][j]) {
                    g[i].insert(uf.find(j));
                }
            }
            for (int root : g[i]) {
                ++cnt[root];
            }
        }
        int ans = 0, mx = -1;
        for (int i : initial) {
            int t = 0;
            for (int root : g[i]) {
                if (cnt[root] == 1) {
                    t += uf.getSize(root);
                }
            }
            if (t &gt; mx || (t == mx &amp;&amp; i &lt; ans)) {
                ans = i;
                mx = t;
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-4"><a class="header" href="#go-4">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func (uf *unionFind) getSize(root int) int {
	return uf.size[root]
}

func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	s := make([]bool, n)
	for _, i := range initial {
		s[i] = true
	}
	uf := newUnionFind(n)
	for i := range graph {
		if !s[i] {
			for j := i + 1; j &lt; n; j++ {
				if graph[i][j] == 1 &amp;&amp; !s[j] {
					uf.union(i, j)
				}
			}
		}
	}
	g := make([]map[int]bool, n)
	for _, i := range initial {
		g[i] = map[int]bool{}
	}
	cnt := make([]int, n)
	for _, i := range initial {
		for j := 0; j &lt; n; j++ {
			if !s[j] &amp;&amp; graph[i][j] == 1 {
				g[i][uf.find(j)] = true
			}
		}
		for root := range g[i] {
			cnt[root]++
		}
	}
	ans, mx := 0, -1
	for _, i := range initial {
		t := 0
		for root := range g[i] {
			if cnt[root] == 1 {
				t += uf.getSize(root)
			}
		}
		if t &gt; mx || t == mx &amp;&amp; i &lt; ans {
			ans, mx = i, t
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-4"><a class="header" href="#typescript-4">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    p: number[];
    size: number[];
    constructor(n: number) {
        this.p = Array(n)
            .fill(0)
            .map((_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }

    union(a: number, b: number): boolean {
        const [pa, pb] = [this.find(a), this.find(b)];
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }

    getSize(root: number): number {
        return this.size[root];
    }
}

function minMalwareSpread(graph: number[][], initial: number[]): number {
    const n = graph.length;
    const s = new Set(initial);
    const uf = new UnionFind(n);
    for (let i = 0; i &lt; n; ++i) {
        if (!s.has(i)) {
            for (let j = i + 1; j &lt; n; ++j) {
                if (graph[i][j] &amp;&amp; !s.has(j)) {
                    uf.union(i, j);
                }
            }
        }
    }
    const g: Set&lt;number&gt;[] = Array.from({ length: n }, () =&gt; new Set());
    const cnt: number[] = Array(n).fill(0);
    for (const i of initial) {
        for (let j = 0; j &lt; n; ++j) {
            if (graph[i][j] &amp;&amp; !s.has(j)) {
                g[i].add(uf.find(j));
            }
        }
        for (const root of g[i]) {
            ++cnt[root];
        }
    }
    let ans = 0;
    let mx = -1;
    for (const i of initial) {
        let t = 0;
        for (const root of g[i]) {
            if (cnt[root] === 1) {
                t += uf.getSize(root);
            }
        }
        if (t &gt; mx || (t === mx &amp;&amp; i &lt; ans)) {
            [ans, mx] = [i, t];
        }
    }
    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.Arrays;

// 尽量减少恶意软件的传播 II
// 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示
// 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
// 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
// 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
// 我们可以从 initial 中删除一个节点，
// 并完全移除该节点以及从该节点到任何其他节点的任何连接。
// 请返回移除后能够使 M(initial) 最小化的节点。
// 如果有多个节点满足条件，返回索引 最小的节点 。
// initial 中每个整数都不同
// 测试链接 : https://leetcode.com/problems/minimize-malware-spread-ii/
public class Code04_MinimizeMalwareSpreadII {

	// 如果测试数据变大，就改变这个值
	public static int MAXN = 301;

	// [3,6,103]
	// virus[3] = true;
	// virus[103] = true;
	// 方便查询
	public static boolean[] virus = new boolean[MAXN];

	// 每个源头点删掉的话，能拯救多少点的数据
	public static int[] cnts = new int[MAXN];

	// 集合的标签 : 集合的感染点是什么点
	// a : 代表点，整个集合源头是 infect[a]
	// infect[a] == -1，目前这个集合没有发现源头
	// infect[a] &gt;= 0，目前这个集合源头是 infect[a]
	// infect[a] == -2，目前这个集合源头不止一个，已经无法拯救了!
	public static int[] infect = new int[MAXN];

	// 并查集固有信息
	public static int[] father = new int[MAXN];

	// 集合的标签 : 集合的大小是多少
	public static int[] size = new int[MAXN];

	// 集合一定只放普通点，源头点根本不参与集合，也不是元素！

	public static void build(int n, int[] initial) {
		for (int i = 0; i &lt; n; i++) {
			virus[i] = false;
			cnts[i] = 0;
			infect[i] = -1;
			size[i] = 1;
			father[i] = i;
		}
		for (int i : initial) {
			virus[i] = true;
		}
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			size[fy] += size[fx];
		}
	}

	public static int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;
		build(n, initial);
		// 不是病毒的点，普通点合并！
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				if (graph[i][j] == 1 &amp;&amp; !virus[i] &amp;&amp; !virus[j]) {
					union(i, j);
				}
			}
		}
		// 病毒周围的普通点(集合 )去设置源头！
		for (int sick : initial) {
			for (int neighbor = 0; neighbor &lt; n; neighbor++) {
				if (sick != neighbor &amp;&amp; !virus[neighbor] &amp;&amp; graph[sick][neighbor] == 1) {
					int fn = find(neighbor);
					if (infect[fn] == -1) {
						infect[fn] = sick;
					} else if (infect[fn] != -2 &amp;&amp; infect[fn] != sick) {
						infect[fn] = -2;
					}
				}
			}
		}
		// 统计拯救数据
		for (int i = 0; i &lt; n; i++) {
			// 不是代表点，不看
			if (i == find(i) &amp;&amp; infect[i] &gt;= 0) {
				cnts[infect[i]] += size[i];
			}
		}
		Arrays.sort(initial);
		int ans = initial[0];
		int max = cnts[ans];
		for (int i : initial) {
			if (cnts[i] &gt; max) {
				ans = i;
				max = cnts[i];
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../data-structures/disjoint-set-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../data-structures/trie.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../data-structures/disjoint-set-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../data-structures/trie.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
