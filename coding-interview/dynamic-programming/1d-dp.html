<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>One-Dimensional DP Problems - Data Structures and Algorithms for Coding Interviews</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithms for Coding Interviews</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="one-dimentional-dp-problems"><a class="header" href="#one-dimentional-dp-problems">One-Dimentional DP Problems</a></h1>
<h2 id="fibonacci-number"><a class="header" href="#fibonacci-number">Fibonacci Number</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/fibonacci-number" target="_blank">LeetCode Testing Link</a></p>
<p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>
<p>F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n  1.</p>
<p>Given n, calculate F(n).</p>
<p>Example 1:</p>
<p>Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</p>
<p>Example 2:</p>
<p>Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</p>
<p>Example 3:</p>
<p>Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</p>
<p>Constraints:</p>
<ul>
<li>0 &lt;= n &lt;= 30</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class FibonacciNumber {

    // 1. Recursive solution without memoization
	public static int fib1(int n) {
		return f1(n);
	}

	public static int f1(int i) {
		if (i == 0) {
			return 0;
		}
		if (i == 1) {
			return 1;
		}
		return f1(i - 1) + f1(i - 2);
	}

    // 2. Recursive solution with memoization
	public static int fib2(int n) {
		int[] dp = new int[n + 1];
		Arrays.fill(dp, -1);
		return f2(n, dp);
	}

	public static int f2(int i, int[] dp) {
		if (i == 0) {
			return 0;
		}
		if (i == 1) {
			return 1;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		int ans = f2(i - 1, dp) + f2(i - 2, dp);
		dp[i] = ans;
		return ans;
	}

    // Iterative solution (state transition)
	public static int fib3(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		int[] dp = new int[n + 1];
		dp[1] = 1;
		for (int i = 2; i &lt;= n; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[n];
	}

    // Interative solution with state compression
	public static int fib4(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		int lastLast = 0, last = 1;
		for (int i = 2, cur; i &lt;= n; i++) {
			cur = lastLast + last;
			lastLast = last;
			last = cur;
		}
		return last;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="minimum-cost-for-tickets"><a class="header" href="#minimum-cost-for-tickets">Minimum Cost for Tickets</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-cost-for-tickets" target="_blank">LeetCode Testing Link</a></p>
<p>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.</p>
<p>Train tickets are sold in three different ways:</p>
<ul>
<li>a 1-day pass is sold for costs[0] dollars,</li>
<li>a 7-day pass is sold for costs[1] dollars, and</li>
<li>a 30-day pass is sold for costs[2] dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.</p>
<p>For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.</p>
<p>Return the minimum number of dollars you need to travel every day in the given list of days.</p>
<p>Example 1:</p>
<p>Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.</p>
<p>Example 2:</p>
<p>Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= days.length &lt;= 365</li>
<li>1 &lt;= days[i] &lt;= 365</li>
<li>days is in strictly increasing order.</li>
<li>costs.length == 3</li>
<li>1 &lt;= costs[i] &lt;= 1000</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class MinimumCostForTickets {

	// global variable, accessible from all methods
	public static int[] durations = { 1, 7, 30 };

	// 1. brute-force solution
	public static int mincostTickets1(int[] days, int[] costs) {
		return f1(days, costs, 0);
	}

	// compute the minimum cost starting from day i
	public static int f1(int[] days, int[] costs, int i) {
		if (i == days.length) {
			// no more trips
			return 0;
		}
		int ans = Integer.MAX_VALUE;
		for (int k = 0, j = i; k &lt; 3; k++) {
			while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
				j++; // Is the days[j] covered by the durations[k] ticket purchased at days[i]?
			}
			ans = Math.min(ans, costs[k] + f1(days, costs, j));
		}
		return ans;
	}

	// 2. recursion with memoization
	public static int mincostTickets2(int[] days, int[] costs) {
		int[] dp = new int[days.length];
		for (int i = 0; i &lt; days.length; i++) {
			dp[i] = Integer.MAX_VALUE;
		}
		return f2(days, costs, 0, dp);
	}

	// int[] dp is the memo table
	public static int f2(int[] days, int[] costs, int i, int[] dp) {
		if (i == days.length) {
			return 0;
		}
		if (dp[i] != Integer.MAX_VALUE) {
			return dp[i];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = 0, j = i; k &lt; 3; k++) {
			while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
				j++;
			}
			ans = Math.min(ans, costs[k] + f2(days, costs, j, dp));
		}
		dp[i] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int MAXN = 366;

	public static int[] dp = new int[MAXN];

	public static int mincostTickets3(int[] days, int[] costs) {
		int n = days.length;
		Arrays.fill(dp, 0, n + 1, Integer.MAX_VALUE);
		dp[n] = 0;
		for (int i = n - 1; i &gt;= 0; i--) {
			for (int k = 0, j = i; k &lt; 3; k++) {
				while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
					j++;
				}
				dp[i] = Math.min(dp[i], costs[k] + dp[j]);
			}
		}
		return dp[0];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="decode-ways"><a class="header" href="#decode-ways">Decode Ways</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/decode-ways" target="_blank">LeetCode Testing Link</a></p>
<p>You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:</p>
<p>1 - A
2 - B
...
25 - Y
26 - Z</p>
<p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (2 and 5 vs 25).</p>
<p>For example, 11106 can be decoded into:</p>
<pre><code>AAJF with the grouping (1, 1, 10, 6)
KJF with the grouping (11, 10, 6)
The grouping (1, 11, 06) is invalid because 06 is not a valid code (only 6 is valid).
</code></pre>
<p>Note: there may be strings that are impossible to decode.</p>
<p>Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.</p>
<p>The test cases are generated so that the answer fits in a 32-bit integer.</p>
<p>Example 1:</p>
<p>Input: s = 12</p>
<p>Output: 2</p>
<p>Explanation:</p>
<p>12 could be decoded as AB (1 2) or L (12).</p>
<p>Example 2:</p>
<p>Input: s = 226</p>
<p>Output: 3</p>
<p>Explanation:</p>
<p>226 could be decoded as BZ (2 26), VF (22 6), or BBF (2 2 6).</p>
<p>Example 3:</p>
<p>Input: s = 06</p>
<p>Output: 0</p>
<p>Explanation:</p>
<p>06 cannot be mapped to F because of the leading zero (6 is different from 06). In this case, the string is not a valid encoding, so return 0.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 100</li>
<li>s contains only digits and may contain leading zero(s).</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class DecodeWays {

	// 1. Recursive brute-force solution
	public static int numDecodings1(String s) {
		return f1(s.toCharArray(), 0);
	}

	// compute decoding ways for substring s[i..]
	public static int f1(char[] s, int i) {
		if (i == s.length) {
			return 1;
		}
		int ans;
		if (s[i] == '0') {
			ans = 0;
		} else {
			ans = f1(s, i + 1);
			if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
				ans += f1(s, i + 2);
			}
		}
		return ans;
	}

	// 2. recursive solution with memoization
	public static int numDecodings2(String s) {
		int[] dp = new int[s.length()];
		Arrays.fill(dp, -1);
		return f2(s.toCharArray(), 0, dp);
	}

	public static int f2(char[] s, int i, int[] dp) {
		if (i == s.length) {
			return 1;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		int ans;
		if (s[i] == '0') {
			ans = 0;
		} else {
			ans = f2(s, i + 1, dp);
			if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
				ans += f2(s, i + 2, dp);
			}
		}
		dp[i] = ans;
		return ans;
	}

	// 3. bottom-up iterative solution
	public static int numDecodings3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[] dp = new int[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') {
				dp[i] = 0;
			} else {
				dp[i] = dp[i + 1];
				if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
					dp[i] += dp[i + 2];
				}
			}
		}
		return dp[0];
	}

	// 4. iterative solution + state compression
	public static int numDecodings4(String s) {
		// dp[i+1]
		int next = 1;
		// dp[i+2]
		int nextNext = 0;
		for (int i = s.length() - 1, cur; i &gt;= 0; i--) {
			if (s.charAt(i) == '0') {
				cur = 0;
			} else {
				cur = next;
				if (i + 1 &lt; s.length() &amp;&amp; ((s.charAt(i) - '0') * 10 + s.charAt(i + 1) - '0') &lt;= 26) {
					cur += nextNext;
				}
			}
			nextNext = next;
			next = cur;
		}
		return next;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="decode-ways-ii"><a class="header" href="#decode-ways-ii">Decode Ways II</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/decode-ways-ii" target="_blank">LeetCode Testing Link</a></p>
<p>A message containing letters from A-Z can be encoded into numbers using the following mapping:</p>
<p>A - 1
B - 2
...
Z - 26</p>
<p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, 11106 can be mapped into:</p>
<pre><code>AAJF with the grouping (1 1 10 6)
KJF with the grouping (11 10 6)
</code></pre>
<p>Note that the grouping (1 11 06) is invalid because 06 cannot be mapped into F since 6 is different from 06.</p>
<p>In addition to the mapping above, an encoded message may contain the * character, which can represent any digit from 1 to 9 (0 is excluded). For example, the encoded message 1* may represent any of the encoded messages 11, 12, 13, 14, 15, 16, 17, 18, or 19. Decoding 1* is equivalent to decoding any of the encoded messages it can represent.</p>
<p>Given a string s consisting of digits and * characters, return the number of ways to decode it.</p>
<p>Since the answer may be very large, return it modulo 109 + 7.</p>
<p>Example 1:</p>
<p>Input: s = *
Output: 9
Explanation: The encoded message can represent any of the encoded messages 1, 2, 3, 4, 5, 6, 7, 8, or 9.
Each of these can be decoded to the strings A, B, C, D, E, F, G, H, and I respectively.
Hence, there are a total of 9 ways to decode *.</p>
<p>Example 2:</p>
<p>Input: s = 1*
Output: 18
Explanation: The encoded message can represent any of the encoded messages 11, 12, 13, 14, 15, 16, 17, 18, or 19.
Each of these encoded messages have 2 ways to be decoded (e.g. 11 can be decoded to AA or K).
Hence, there are a total of 9 * 2 = 18 ways to decode 1*.</p>
<p>Example 3:</p>
<p>Input: s = 2*
Output: 15
Explanation: The encoded message can represent any of the encoded messages 21, 22, 23, 24, 25, 26, 27, 28, or 29.
21, 22, 23, 24, 25, and 26 have 2 ways of being decoded, but 27, 28, and 29 only have 1 way.
Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode 2*.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>s[i] is a digit or *.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class DecodeWaysII {

	// 1. brute-force solution without modulus (incorrect answer)
	public static int numDecodings1(String str) {
		return f1(str.toCharArray(), 0);
	}

	// compute decode ways for substring s[i..]
	public static int f1(char[] s, int i) {
		if (i == s.length) {
			return 1;
		}
		if (s[i] == '0') {
			return 0;
		}
		// s[i] != '0'
		// decode s[i] only
		int ans = f1(s, i + 1) * (s[i] == '*' ? 9 : 1);
		// decode s[i] and s[i+1] combined
		if (i + 1 &lt; s.length) { // s[i+1] exists
			if (s[i] != '*' &amp;&amp; s[i+1] != '*') { // case 1: digit + digit
				if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
					ans += f1(s, i + 2);
				}
			} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') { // case 2: digit + '*'
				if (s[i] == '1') {
					ans += f1(s, i + 2) * 9;
				}
				if (s[i] == '2') {
					ans += f1(s, i + 2) * 6;
				}
			} else if (s[i] == '*' &amp;&amp; s[i+1] != '*') { // case 3: '*' + digit
				if (s[i + 1] &lt;= '6') {
					ans += f1(s, i + 2) * 2;
				} else {
					ans += f1(s, i + 2);
				}
			} else { // case 4: '*' + '*'
				ans += f1(s, i + 2) * 15;
			}
		}
		return ans;
	}

	// 2. recursive solution with memoization, modulus answer
	public static long mod = 1000000007;

	public static int numDecodings2(String str) {
		char[] s = str.toCharArray();
		long[] dp = new long[s.length];
		Arrays.fill(dp, -1);
		return (int) f2(s, 0, dp);
	}

	public static long f2(char[] s, int i, long[] dp) {
		if (i == s.length) {
			return 1;
		}
		if (s[i] == '0') {
			return 0;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		long ans = f2(s, i + 1, dp) * (s[i] == '*' ? 9 : 1); // decode s[i] only
		if (i + 1 &lt; s.length) { // decode s[i] and s[i+1] together
			if (s[i] != '*' &amp;&amp; s[i+1] != '*') {
				if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
					ans += f2(s, i + 2, dp);
				}
			} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') {
				if (s[i] == '1') {
					ans += f2(s, i + 2, dp) * 9;
				}
				if (s[i] == '2') {
					ans += f2(s, i + 2, dp) * 6;
				}
			} else if (s[i] == '*' &amp;&amp; s[i + 1] != '*') {
				if (s[i + 1] &lt;= '6') {
					ans += f2(s, i + 2, dp) * 2;
				} else {
					ans += f2(s, i + 2, dp);
				}
			} else {
				ans += f2(s, i + 2, dp) * 15;
			}
		}
		ans %= mod;
		dp[i] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int numDecodings3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		long[] dp = new long[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') continue;
			dp[i] = (s[i] == '*' ? 9 : 1) * dp[i + 1];
			if (i + 1 &lt; n) {
				if (s[i] != '*' &amp;&amp; s[i + 1] != '*') {
					if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
						dp[i] += dp[i + 2];
					}
				} else if (s[i] != '*' &amp;&amp; s[i + 1] == '*') {
					if (s[i] == '1') {
						dp[i] += dp[i + 2] * 9;
					}
					if (s[i] == '2') {
						dp[i] += dp[i + 2] * 6;
					}
				} else if (s[i] == '*' &amp;&amp; s[i + 1] != '*') {
					if (s[i + 1] &lt;= '6') {
						dp[i] += dp[i + 2] * 2;
					} else {
						dp[i] += dp[i + 2];
					}
				} else {
					dp[i] += dp[i + 2] * 15;
				}
			}
			dp[i] %= mod;
		}
		return (int) dp[0];
	}

	// 4. iterative solution with state compression
	public static int numDecodings4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		long cur = 0, next = 1, nextNext = 0;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') continue;
			cur = (s[i] == '*' ? 9 : 1) * next;
			if (i + 1 &lt; n) {
				if (s[i] != '*' &amp;&amp; s[i+1] != '*') {
					if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
						cur += nextNext;
					}
				} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') {
					if (s[i] == '1') {
						cur += nextNext * 9;
					}
					if (s[i] == '2') {
						cur += nextNext * 6;
					}
				} else if (s[i] == '*' &amp;&amp; s[i+1] != '*') {
					if (s[i + 1] &lt;= '6') {
						cur += nextNext * 2;
					} else {
						cur += nextNext;
					}
				} else {
					cur += nextNext * 15;
				}
			}
			cur %= mod;
			nextNext = next;
			next = cur;
			cur = 0;
		}
		return (int) next;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="ugly-number-ii"><a class="header" href="#ugly-number-ii">Ugly Number II</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/ugly-number-ii" target="_blank">LeetCode Testing Link</a></p>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</p>
<p>Given an integer n, return the nth ugly number.</p>
<p>Example 1:</p>
<p>Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.</p>
<p>Example 2:</p>
<p>Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= n &lt;= 1690</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class UglyNumberII {

	public static int nthUglyNumber(int n) {
		int[] dp = new int[n + 1];
		dp[1] = 1;
		int i2 = 1, i3 = 1, i5 = 1, a, b, c, cur;
		for (int i = 2; i &lt;= n; i++) {
			a = dp[i2] * 2;
			b = dp[i3] * 3;
			c = dp[i5] * 5;
			cur = Math.min(Math.min(a, b), c);
			if (cur == a) {
				i2++;
			}
			if (cur == b) {
				i3++;
			}
			if (cur == c) {
				i5++;
			}
			dp[i] = cur;
		}
		return dp[n];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="longest-valid-parentheses"><a class="header" href="#longest-valid-parentheses">Longest Valid Parentheses</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses" target="_blank">LeetCode Testing Link</a></p>
<p>Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.</p>
<p>Example 1:</p>
<p>Input: s = (()
Output: 2
Explanation: The longest valid parentheses substring is ().</p>
<p>Example 2:</p>
<p>Input: s = )()())
Output: 4
Explanation: The longest valid parentheses substring is ()().</p>
<p>Example 3:</p>
<p>Input: s =
Output: 0</p>
<p>Constraints:</p>
<ul>
<li>0 &lt;= s.length &lt; 3 * 10^4</li>
<li>s[i] is '(', or ')'.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class LongestValidParentheses {

	public static int longestValidParentheses(String str) {
		char[] s = str.toCharArray();
		// dp[i] : the longest valid parentheses for substring ending at i 
		int[] dp = new int[s.length];
		int ans = 0, p;
		for (int i = 1; i &lt; s.length; i++) {
			if (s[i] == ')') {
				p = i - dp[i - 1] - 1;
				if (p &gt;= 0 &amp;&amp; s[p] == '(') {
					dp[i] = dp[i - 1] + 2 + (p - 1 &gt;= 0 ? dp[p - 1] : 0);
				}
			}
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="unique-substring-in-wraparound-string"><a class="header" href="#unique-substring-in-wraparound-string">Unique Substring in Wraparound String</a></h2>
<details><summary>Description:</summary>
<p>(https://leetcode.com/problems/unique-substrings-in-wraparound-string)</p>
<p>We define the string base to be the infinite wraparound string of abcdefghijklmnopqrstuvwxyz, so base will look like this:</p>
<pre><code>...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.....
</code></pre>
<p>Given a string s, return the number of unique non-empty substrings of s are present in base.</p>
<p>Example 1:</p>
<p>Input: s = a
Output: 1
Explanation: Only the substring a of s is in base.</p>
<p>Example 2:</p>
<p>Input: s = cac
Output: 2
Explanation: There are two substrings (a, c) of s in base.</p>
<p>Example 3:</p>
<p>Input: s = zab
Output: 6
Explanation: There are six substrings (z, a, b, za, ab, and zab) of s in base.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>s consists of lowercase English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class UniqueSubstringInWraparoundString {

	// 时间复杂度O(n)，n是字符串s的长度，字符串base长度为正无穷
	public static int findSubstringInWraproundString(String str) {
		int n = str.length();
		int[] s = new int[n];
		// abcde...z -&gt; 0, 1, 2, 3, 4....25
		for (int i = 0; i &lt; n; i++) {
			s[i] = str.charAt(i) - 'a';
		}
		// dp[0] : s中必须以'a'的子串，最大延伸长度是多少，延伸一定要跟据base串的规则
		int[] dp = new int[26];
		// s : c d e....
		//     2 3 4
		dp[s[0]] = 1;
		for (int i = 1, cur, pre, len = 1; i &lt; n; i++) {
			cur = s[i];
			pre = s[i - 1];
			// pre cur
			if ((pre == 25 &amp;&amp; cur == 0) || pre + 1 == cur) {
				// (前一个字符是'z' &amp;&amp; 当前字符是'a') || 前一个字符比当前字符的ascii码少1
				len++;
			} else {
				len = 1;
			}
			dp[cur] = Math.max(dp[cur], len);
		}
		int ans = 0;
		for (int i = 0; i &lt; 26; i++) {
			ans += dp[i];
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="distinct-subsequences-ii"><a class="header" href="#distinct-subsequences-ii">Distinct Subsequences II</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/distinct-subsequences-ii" target="_blank">LeetCode Testing Link</a></p>
<p>Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.
A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters (i.e., <code>ace</code> is a subsequence of <code>abcde</code> while <code>aec</code> is not).</p>
<p>Example 1:</p>
<p>Input: s = abc
Output: 7
Explanation: The 7 distinct subsequences are a, b, c, ab, ac, bc, and abc.</p>
<p>Example 2:</p>
<p>Input: s = aba
Output: 6
Explanation: The 6 distinct subsequences are a, b, ab, aa, ba, and aba.</p>
<p>Example 3:</p>
<p>Input: s = aaa
Output: 3
Explanation: The 3 distinct subsequences are a, aa and aaa.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 2000</li>
<li>s consists of lowercase English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class DistinctSubsequencesII {

	// 时间复杂度O(n)，n是字符串s的长度
	public static int distinctSubseqII(String s) {
		int mod = 1000000007;
		char[] str = s.toCharArray();
		int[] cnt = new int[26];
		int all = 1, newAdd;
		for (char x : str) {
			newAdd = (all - cnt[x - 'a'] + mod) % mod;
			cnt[x - 'a'] = (cnt[x - 'a'] + newAdd) % mod;
			all = (all + newAdd) % mod;
		}
		return (all - 1 + mod) % mod;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../dynamic-programming/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../dynamic-programming/2d-dp-1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../dynamic-programming/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../dynamic-programming/2d-dp-1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
