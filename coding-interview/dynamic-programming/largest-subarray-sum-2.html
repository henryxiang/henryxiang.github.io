<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Largest Subarray Sum and the Related Problems 2 - Data Structures and Algorithms for Coding Interviews</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithms for Coding Interviews</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="largest-subarray-sum-part-2"><a class="header" href="#largest-subarray-sum-part-2">Largest Subarray Sum (part 2)</a></h1>
<h2 id="maximum-product-subarray"><a class="header" href="#maximum-product-subarray">Maximum Product Subarray</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0100-0199/0152.Maximum%20Product%20Subarray/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="152-maximum-product-subarray"><a class="header" href="#152-maximum-product-subarray"><a href="https://leetcode.com/problems/maximum-product-subarray">152. Maximum Product Subarray</a></a></h1>
<p><a href="/solution/0100-0199/0152.Maximum%20Product%20Subarray/README.html">中文文档</a></p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code>, find a <span data-keyword="subarray-nonempty">subarray</span> that has the largest product, and return <em>the product</em>.</p>
<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,3,-2,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> [2,3] has the largest product 6.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [-2,0,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li>The product of any subarray of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>
</ul>
<!-- description:end -->
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1"><a class="header" href="#solution-1">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3"><a class="header" href="#python3">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        ans = f = g = nums[0]
        for x in nums[1:]:
            ff, gg = f, g
            f = max(x, ff * x, gg * x)
            g = min(x, ff * x, gg * x)
            ans = max(ans, f)
        return ans
</code></pre>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxProduct(int[] nums) {
        int f = nums[0], g = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.length; ++i) {
            int ff = f, gg = g;
            f = Math.max(nums[i], Math.max(ff * nums[i], gg * nums[i]));
            g = Math.min(nums[i], Math.min(ff * nums[i], gg * nums[i]));
            ans = Math.max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<h4 id="c"><a class="header" href="#c">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int f = nums[0], g = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.size(); ++i) {
            int ff = f, gg = g;
            f = max({nums[i], ff * nums[i], gg * nums[i]});
            g = min({nums[i], ff * nums[i], gg * nums[i]});
            ans = max(ans, f);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go"><a class="header" href="#go">Go</a></h4>
<pre><code class="language-go">func maxProduct(nums []int) int {
	f, g, ans := nums[0], nums[0], nums[0]
	for _, x := range nums[1:] {
		ff, gg := f, g
		f = max(x, max(ff*x, gg*x))
		g = min(x, min(ff*x, gg*x))
		ans = max(ans, f)
	}
	return ans
}
</code></pre>
<h4 id="typescript"><a class="header" href="#typescript">TypeScript</a></h4>
<pre><code class="language-ts">function maxProduct(nums: number[]): number {
    let [f, g, ans] = [nums[0], nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        const [ff, gg] = [f, g];
        f = Math.max(nums[i], ff * nums[i], gg * nums[i]);
        g = Math.min(nums[i], ff * nums[i], gg * nums[i]);
        ans = Math.max(ans, f);
    }
    return ans;
}
</code></pre>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn max_product(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut f = nums[0];
        let mut g = nums[0];
        let mut ans = nums[0];
        for &amp;x in nums.iter().skip(1) {
            let (ff, gg) = (f, g);
            f = x.max(x * ff).max(x * gg);
            g = x.min(x * ff).min(x * gg);
            ans = ans.max(f);
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript"><a class="header" href="#javascript">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {
    let [f, g, ans] = [nums[0], nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        const [ff, gg] = [f, g];
        f = Math.max(nums[i], ff * nums[i], gg * nums[i]);
        g = Math.min(nums[i], ff * nums[i], gg * nums[i]);
        ans = Math.max(ans, f);
    }
    return ans;
};
</code></pre>
<h4 id="c-1"><a class="header" href="#c-1">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int MaxProduct(int[] nums) {
        int f = nums[0], g = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.Length; ++i) {
            int ff = f, gg = g;
            f = Math.Max(nums[i], Math.Max(ff * nums[i], gg * nums[i]));
            g = Math.Min(nums[i], Math.Min(ff * nums[i], gg * nums[i]));
            ans = Math.Max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 乘积最大子数组
// 给你一个整数数组 nums
// 请你找出数组中乘积最大的非空连续子数组
// 并返回该子数组所对应的乘积
// 测试链接 : https://leetcode.com/problems/maximum-product-subarray/
public class Code01_MaximumProductSubarray {

	// 这节课讲完之后，测试数据又增加了
	// 用int类型的变量会让中间结果溢出
	// 所以改成用double类型的变量
	// 思路是不变的
	public static int maxProduct(int[] nums) {
		double ans = nums[0], min = nums[0], max = nums[0], curmin, curmax;
		for (int i = 1; i &lt; nums.length; i++) {
			curmin = Math.min(nums[i], Math.min(min * nums[i], max * nums[i]));
			curmax = Math.max(nums[i], Math.max(min * nums[i], max * nums[i]));
			min = curmin;
			max = curmax;
			ans = Math.max(ans, max);
		}
		return (int) ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="max-sum-divided-by-7"><a class="header" href="#max-sum-divided-by-7">Max Sum Divided By 7</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 子序列累加和必须被7整除的最大累加和
// 给定一个非负数组nums，
// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除
// 返回最大累加和
// 对数器验证
public class Code02_MaxSumDividedBy7 {

	// 暴力方法
	// 为了验证
	public static int maxSum1(int[] nums) {
		// nums形成的所有子序列的累加和都求出来
		// 其中%7==0的那些累加和中，返回最大的
		// 就是如下f函数的功能
		return f(nums, 0, 0);
	}

	public static int f(int[] nums, int i, int s) {
		if (i == nums.length) {
			return s % 7 == 0 ? s : 0;
		}
		return Math.max(f(nums, i + 1, s), f(nums, i + 1, s + nums[i]));
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		// dp[i][j] : nums[0...i-1]
		// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j
		// 这样的子序列最大累加和是多少
		// 注意 : dp[i][j] == -1代表不存在这样的子序列
		int[][] dp = new int[n + 1][7];
		dp[0][0] = 0;
		for (int j = 1; j &lt; 7; j++) {
			dp[0][j] = -1;
		}
		for (int i = 1, x, cur, need; i &lt;= n; i++) {
			x = nums[i - 1];
			cur = nums[i - 1] % 7;
			for (int j = 0; j &lt; 7; j++) {
				dp[i][j] = dp[i - 1][j];
				// 这里求need是核心
				need = cur &lt;= j ? (j - cur) : (j - cur + 7);
				// 或者如下这种写法也对
				// need = (7 + j - cur) % 7;
				if (dp[i - 1][need] != -1) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][need] + x);
				}
			}
		}
		return dp[n][0];
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * v);
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 15;
		int v = 30;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 子序列累加和必须被7整除的最大累加和
// 给定一个非负数组nums，
// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除
// 返回最大累加和
// 对数器验证
public class Code02_MaxSumDividedBy7 {

	// 暴力方法
	// 为了验证
	public static int maxSum1(int[] nums) {
		// nums形成的所有子序列的累加和都求出来
		// 其中%7==0的那些累加和中，返回最大的
		// 就是如下f函数的功能
		return f(nums, 0, 0);
	}

	public static int f(int[] nums, int i, int s) {
		if (i == nums.length) {
			return s % 7 == 0 ? s : 0;
		}
		return Math.max(f(nums, i + 1, s), f(nums, i + 1, s + nums[i]));
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		// dp[i][j] : nums[0...i-1]
		// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j
		// 这样的子序列最大累加和是多少
		// 注意 : dp[i][j] == -1代表不存在这样的子序列
		int[][] dp = new int[n + 1][7];
		dp[0][0] = 0;
		for (int j = 1; j &lt; 7; j++) {
			dp[0][j] = -1;
		}
		for (int i = 1, x, cur, need; i &lt;= n; i++) {
			x = nums[i - 1];
			cur = nums[i - 1] % 7;
			for (int j = 0; j &lt; 7; j++) {
				dp[i][j] = dp[i - 1][j];
				// 这里求need是核心
				need = cur &lt;= j ? (j - cur) : (j - cur + 7);
				// 或者如下这种写法也对
				// need = (7 + j - cur) % 7;
				if (dp[i - 1][need] != -1) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][need] + x);
				}
			}
		}
		return dp[n][0];
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * v);
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 15;
		int v = 30;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="magic-scroll-probelm"><a class="header" href="#magic-scroll-probelm">Magic Scroll Probelm</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 魔法卷轴
// 给定一个数组nums，其中可能有正、负、0
// 每个魔法卷轴可以把nums中连续的一段全变成0
// 你希望数组整体的累加和尽可能大
// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴
// 请返回数组尽可能大的累加和
// 对数器验证
public class Code03_MagicScrollProbelm {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums) {
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		int n = nums.length;
		int p2 = mustOneScroll(nums, 0, n - 1);
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			p3 = Math.max(p3, mustOneScroll(nums, 0, i - 1) + mustOneScroll(nums, i, n - 1));
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 暴力方法
	// 为了测试
	// nums[l...r]范围上一定要用一次卷轴情况下的最大累加和
	public static int mustOneScroll(int[] nums, int l, int r) {
		int ans = Integer.MIN_VALUE;
		// l...r范围上包含a...b范围
		// 如果a...b范围上的数字都变成0
		// 返回剩下数字的累加和
		// 所以枚举所有可能的a...b范围
		// 相当暴力，但是正确
		for (int a = l; a &lt;= r; a++) {
			for (int b = a; b &lt;= r; b++) {
				// l...a...b...r
				int curAns = 0;
				for (int i = l; i &lt; a; i++) {
					curAns += nums[i];
				}
				for (int i = b + 1; i &lt;= r; i++) {
					curAns += nums[i];
				}
				ans = Math.max(ans, curAns);
			}
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		if (n == 0) {
			return 0;
		}
		// 情况1 : 完全不使用卷轴
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		// prefix[i] : 0~i范围上一定要用1次卷轴的情况下，0~i范围上整体最大累加和多少
		int[] prefix = new int[n];
		// 每一步的前缀和
		int sum = nums[0];
		// maxPresum : 之前所有前缀和的最大值
		int maxPresum = Math.max(0, nums[0]);
		for (int i = 1; i &lt; n; i++) {
			prefix[i] = Math.max(prefix[i - 1] + nums[i], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用1次卷轴
		int p2 = prefix[n - 1];
		// suffix[i] : i~n-1范围上一定要用1次卷轴的情况下，i~n-1范围上整体最大累加和多少
		int[] suffix = new int[n];
		sum = nums[n - 1];
		maxPresum = Math.max(0, sum);
		for (int i = n - 2; i &gt;= 0; i--) {
			suffix[i] = Math.max(nums[i] + suffix[i + 1], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用2次卷轴
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			// 枚举所有的划分点i
			// 0~i-1 左
			// i~n-1 右
			p3 = Math.max(p3, prefix[i - 1] + suffix[i]);
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 为了测试
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	public static void main(String[] args) {
		int n = 50;
		int v = 100;
		int testTime = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n);
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 魔法卷轴
// 给定一个数组nums，其中可能有正、负、0
// 每个魔法卷轴可以把nums中连续的一段全变成0
// 你希望数组整体的累加和尽可能大
// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴
// 请返回数组尽可能大的累加和
// 对数器验证
public class Code03_MagicScrollProbelm {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums) {
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		int n = nums.length;
		int p2 = mustOneScroll(nums, 0, n - 1);
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			p3 = Math.max(p3, mustOneScroll(nums, 0, i - 1) + mustOneScroll(nums, i, n - 1));
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 暴力方法
	// 为了测试
	// nums[l...r]范围上一定要用一次卷轴情况下的最大累加和
	public static int mustOneScroll(int[] nums, int l, int r) {
		int ans = Integer.MIN_VALUE;
		// l...r范围上包含a...b范围
		// 如果a...b范围上的数字都变成0
		// 返回剩下数字的累加和
		// 所以枚举所有可能的a...b范围
		// 相当暴力，但是正确
		for (int a = l; a &lt;= r; a++) {
			for (int b = a; b &lt;= r; b++) {
				// l...a...b...r
				int curAns = 0;
				for (int i = l; i &lt; a; i++) {
					curAns += nums[i];
				}
				for (int i = b + 1; i &lt;= r; i++) {
					curAns += nums[i];
				}
				ans = Math.max(ans, curAns);
			}
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		if (n == 0) {
			return 0;
		}
		// 情况1 : 完全不使用卷轴
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		// prefix[i] : 0~i范围上一定要用1次卷轴的情况下，0~i范围上整体最大累加和多少
		int[] prefix = new int[n];
		// 每一步的前缀和
		int sum = nums[0];
		// maxPresum : 之前所有前缀和的最大值
		int maxPresum = Math.max(0, nums[0]);
		for (int i = 1; i &lt; n; i++) {
			prefix[i] = Math.max(prefix[i - 1] + nums[i], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用1次卷轴
		int p2 = prefix[n - 1];
		// suffix[i] : i~n-1范围上一定要用1次卷轴的情况下，i~n-1范围上整体最大累加和多少
		int[] suffix = new int[n];
		sum = nums[n - 1];
		maxPresum = Math.max(0, sum);
		for (int i = n - 2; i &gt;= 0; i--) {
			suffix[i] = Math.max(nums[i] + suffix[i + 1], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用2次卷轴
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			// 枚举所有的划分点i
			// 0~i-1 左
			// i~n-1 右
			p3 = Math.max(p3, prefix[i - 1] + suffix[i]);
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 为了测试
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	public static void main(String[] args) {
		int n = 50;
		int v = 100;
		int testTime = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n);
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="maximum-sum-of-3-non-overlapping-subarrays"><a class="header" href="#maximum-sum-of-3-non-overlapping-subarrays">Maximum Sum of 3 Non-Overlapping Subarrays</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0689.Maximum%20Sum%20of%203%20Non-Overlapping%20Subarrays/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="689-maximum-sum-of-3-non-overlapping-subarrays"><a class="header" href="#689-maximum-sum-of-3-non-overlapping-subarrays"><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays">689. Maximum Sum of 3 Non-Overlapping Subarrays</a></a></h1>
<p><a href="/solution/0600-0699/0689.Maximum%20Sum%20of%203%20Non-Overlapping%20Subarrays/README.html">中文文档</a></p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, find three non-overlapping subarrays of length <code>k</code> with maximum sum and return them.</p>
<p>Return the result as a list of indices representing the starting position of each interval (<strong>0-indexed</strong>). If there are multiple answers, return the lexicographically smallest one.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,1,2,6,7,5,1], k = 2
<strong>Output:</strong> [0,3,5]
<strong>Explanation:</strong> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,1,2,1,2,1,2,1], k = 2
<strong>Output:</strong> [0,2,4]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>
	<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-1"><a class="header" href="#solutions-1">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-sliding-window"><a class="header" href="#solution-1-sliding-window">Solution 1: Sliding Window</a></h3>
<p>We use a sliding window to enumerate the position of the third subarray, while maintaining the maximum sum and its position of the first two non-overlapping subarrays.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-1"><a class="header" href="#python3-1">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -&gt; List[int]:
        s = s1 = s2 = s3 = 0
        mx1 = mx12 = 0
        idx1, idx12 = 0, ()
        ans = []
        for i in range(k * 2, len(nums)):
            s1 += nums[i - k * 2]
            s2 += nums[i - k]
            s3 += nums[i]
            if i &gt;= k * 3 - 1:
                if s1 &gt; mx1:
                    mx1 = s1
                    idx1 = i - k * 3 + 1
                if mx1 + s2 &gt; mx12:
                    mx12 = mx1 + s2
                    idx12 = (idx1, i - k * 2 + 1)
                if mx12 + s3 &gt; s:
                    s = mx12 + s3
                    ans = [*idx12, i - k + 1]
                s1 -= nums[i - k * 3 + 1]
                s2 -= nums[i - k * 2 + 1]
                s3 -= nums[i - k + 1]
        return ans
</code></pre>
<h4 id="java-1"><a class="header" href="#java-1">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int[] ans = new int[3];
        int s = 0, s1 = 0, s2 = 0, s3 = 0;
        int mx1 = 0, mx12 = 0;
        int idx1 = 0, idx121 = 0, idx122 = 0;
        for (int i = k * 2; i &lt; nums.length; ++i) {
            s1 += nums[i - k * 2];
            s2 += nums[i - k];
            s3 += nums[i];
            if (i &gt;= k * 3 - 1) {
                if (s1 &gt; mx1) {
                    mx1 = s1;
                    idx1 = i - k * 3 + 1;
                }
                if (mx1 + s2 &gt; mx12) {
                    mx12 = mx1 + s2;
                    idx121 = idx1;
                    idx122 = i - k * 2 + 1;
                }
                if (mx12 + s3 &gt; s) {
                    s = mx12 + s3;
                    ans = new int[] {idx121, idx122, i - k + 1};
                }
                s1 -= nums[i - k * 3 + 1];
                s2 -= nums[i - k * 2 + 1];
                s3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-2"><a class="header" href="#c-2">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; ans(3);
        int s = 0, s1 = 0, s2 = 0, s3 = 0;
        int mx1 = 0, mx12 = 0;
        int idx1 = 0, idx121 = 0, idx122 = 0;
        for (int i = k * 2; i &lt; nums.size(); ++i) {
            s1 += nums[i - k * 2];
            s2 += nums[i - k];
            s3 += nums[i];
            if (i &gt;= k * 3 - 1) {
                if (s1 &gt; mx1) {
                    mx1 = s1;
                    idx1 = i - k * 3 + 1;
                }
                if (mx1 + s2 &gt; mx12) {
                    mx12 = mx1 + s2;
                    idx121 = idx1;
                    idx122 = i - k * 2 + 1;
                }
                if (mx12 + s3 &gt; s) {
                    s = mx12 + s3;
                    ans = {idx121, idx122, i - k + 1};
                }
                s1 -= nums[i - k * 3 + 1];
                s2 -= nums[i - k * 2 + 1];
                s3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-1"><a class="header" href="#go-1">Go</a></h4>
<pre><code class="language-go">func maxSumOfThreeSubarrays(nums []int, k int) []int {
	ans := make([]int, 3)
	s, s1, s2, s3 := 0, 0, 0, 0
	mx1, mx12 := 0, 0
	idx1, idx121, idx122 := 0, 0, 0
	for i := k * 2; i &lt; len(nums); i++ {
		s1 += nums[i-k*2]
		s2 += nums[i-k]
		s3 += nums[i]
		if i &gt;= k*3-1 {
			if s1 &gt; mx1 {
				mx1 = s1
				idx1 = i - k*3 + 1
			}
			if mx1+s2 &gt; mx12 {
				mx12 = mx1 + s2
				idx121 = idx1
				idx122 = i - k*2 + 1
			}
			if mx12+s3 &gt; s {
				s = mx12 + s3
				ans = []int{idx121, idx122, i - k + 1}
			}
			s1 -= nums[i-k*3+1]
			s2 -= nums[i-k*2+1]
			s3 -= nums[i-k+1]
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-1"><a class="header" href="#typescript-1">TypeScript</a></h4>
<pre><code class="language-ts">function maxSumOfThreeSubarrays(nums: number[], k: number): number[] {
    const n: number = nums.length;
    const s: number[] = Array(n + 1).fill(0);

    for (let i = 0; i &lt; n; ++i) {
        s[i + 1] = s[i] + nums[i];
    }

    const pre: number[][] = Array(n)
        .fill([])
        .map(() =&gt; new Array(2).fill(0));
    const suf: number[][] = Array(n)
        .fill([])
        .map(() =&gt; new Array(2).fill(0));

    for (let i = 0, t = 0, idx = 0; i &lt; n - k + 1; ++i) {
        const cur: number = s[i + k] - s[i];
        if (cur &gt; t) {
            pre[i + k - 1] = [cur, i];
            t = cur;
            idx = i;
        } else {
            pre[i + k - 1] = [t, idx];
        }
    }

    for (let i = n - k, t = 0, idx = 0; i &gt;= 0; --i) {
        const cur: number = s[i + k] - s[i];
        if (cur &gt;= t) {
            suf[i] = [cur, i];
            t = cur;
            idx = i;
        } else {
            suf[i] = [t, idx];
        }
    }

    let ans: number[] = [];
    for (let i = k, t = 0; i &lt; n - 2 * k + 1; ++i) {
        const cur: number = s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0];
        if (cur &gt; t) {
            ans = [pre[i - 1][1], i, suf[i + k][1]];
            t = cur;
        }
    }

    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-preprocessing-prefix-and-suffix--enumerating-middle-subarray"><a class="header" href="#solution-2-preprocessing-prefix-and-suffix--enumerating-middle-subarray">Solution 2: Preprocessing Prefix and Suffix + Enumerating Middle Subarray</a></h3>
<p>We can preprocess to get the prefix sum array $s$ of the array $nums$, where $s[i] = \sum_{j=0}^{i-1} nums[j]$. Then for any $i$, $j$, $s[j] - s[i]$ is the sum of the subarray $[i, j)$.</p>
<p>Next, we use dynamic programming to maintain two arrays $pre$ and $suf$ of length $n$, where $pre[i]$ represents the maximum sum and its starting position of the subarray of length $k$ within the range $[0, i]$, and $suf[i]$ represents the maximum sum and its starting position of the subarray of length $k$ within the range $[i, n)$.</p>
<p>Then, we enumerate the starting position $i$ of the middle subarray. The sum of the three subarrays is $pre[i-1][0] + suf[i+k][0] + (s[i+k] - s[i])$, where $pre[i-1][0]$ represents the maximum sum of the subarray of length $k$ within the range $[0, i-1]$, $suf[i+k][0]$ represents the maximum sum of the subarray of length $k$ within the range $[i+k, n)$, and $(s[i+k] - s[i])$ represents the sum of the subarray of length $k$ within the range $[i, i+k)$. We find the starting positions of the three subarrays corresponding to the maximum sum.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$.</p>
<!-- tabs:start -->
<h4 id="python3-2"><a class="header" href="#python3-2">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -&gt; List[int]:
        n = len(nums)
        s = list(accumulate(nums, initial=0))
        pre = [[] for _ in range(n)]
        suf = [[] for _ in range(n)]
        t = idx = 0
        for i in range(n - k + 1):
            if (cur := s[i + k] - s[i]) &gt; t:
                pre[i + k - 1] = [cur, i]
                t, idx = pre[i + k - 1]
            else:
                pre[i + k - 1] = [t, idx]
        t = idx = 0
        for i in range(n - k, -1, -1):
            if (cur := s[i + k] - s[i]) &gt;= t:
                suf[i] = [cur, i]
                t, idx = suf[i]
            else:
                suf[i] = [t, idx]
        t = 0
        ans = []
        for i in range(k, n - 2 * k + 1):
            if (cur := s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0]) &gt; t:
                ans = [pre[i - 1][1], i, suf[i + k][1]]
                t = cur
        return ans
</code></pre>
<h4 id="java-2"><a class="header" href="#java-2">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int n = nums.length;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; ++i) {
            s[i + 1] = s[i] + nums[i];
        }
        int[][] pre = new int[n][0];
        int[][] suf = new int[n][0];
        for (int i = 0, t = 0, idx = 0; i &lt; n - k + 1; ++i) {
            int cur = s[i + k] - s[i];
            if (cur &gt; t) {
                pre[i + k - 1] = new int[] {cur, i};
                t = cur;
                idx = i;
            } else {
                pre[i + k - 1] = new int[] {t, idx};
            }
        }
        for (int i = n - k, t = 0, idx = 0; i &gt;= 0; --i) {
            int cur = s[i + k] - s[i];
            if (cur &gt;= t) {
                suf[i] = new int[] {cur, i};
                t = cur;
                idx = i;
            } else {
                suf[i] = new int[] {t, idx};
            }
        }
        int[] ans = new int[0];
        for (int i = k, t = 0; i &lt; n - 2 * k + 1; ++i) {
            int cur = s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0];
            if (cur &gt; t) {
                ans = new int[] {pre[i - 1][1], i, suf[i + k][1]};
                t = cur;
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-3"><a class="header" href="#c-3">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;int&gt; s(n + 1, 0);
        for (int i = 0; i &lt; n; ++i) {
            s[i + 1] = s[i] + nums[i];
        }

        vector&lt;vector&lt;int&gt;&gt; pre(n, vector&lt;int&gt;(2, 0));
        vector&lt;vector&lt;int&gt;&gt; suf(n, vector&lt;int&gt;(2, 0));

        for (int i = 0, t = 0, idx = 0; i &lt; n - k + 1; ++i) {
            int cur = s[i + k] - s[i];
            if (cur &gt; t) {
                pre[i + k - 1] = {cur, i};
                t = cur;
                idx = i;
            } else {
                pre[i + k - 1] = {t, idx};
            }
        }

        for (int i = n - k, t = 0, idx = 0; i &gt;= 0; --i) {
            int cur = s[i + k] - s[i];
            if (cur &gt;= t) {
                suf[i] = {cur, i};
                t = cur;
                idx = i;
            } else {
                suf[i] = {t, idx};
            }
        }

        vector&lt;int&gt; ans;
        for (int i = k, t = 0; i &lt; n - 2 * k + 1; ++i) {
            int cur = s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0];
            if (cur &gt; t) {
                ans = {pre[i - 1][1], i, suf[i + k][1]};
                t = cur;
            }
        }

        return ans;
    }
};
</code></pre>
<h4 id="go-2"><a class="header" href="#go-2">Go</a></h4>
<pre><code class="language-go">func maxSumOfThreeSubarrays(nums []int, k int) (ans []int) {
	n := len(nums)
	s := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		s[i+1] = s[i] + nums[i]
	}

	pre := make([][]int, n)
	suf := make([][]int, n)

	for i, t, idx := 0, 0, 0; i &lt; n-k+1; i++ {
		cur := s[i+k] - s[i]
		if cur &gt; t {
			pre[i+k-1] = []int{cur, i}
			t, idx = cur, i
		} else {
			pre[i+k-1] = []int{t, idx}
		}
	}

	for i, t, idx := n-k, 0, 0; i &gt;= 0; i-- {
		cur := s[i+k] - s[i]
		if cur &gt;= t {
			suf[i] = []int{cur, i}
			t, idx = cur, i
		} else {
			suf[i] = []int{t, idx}
		}
	}

	for i, t := k, 0; i &lt; n-2*k+1; i++ {
		cur := s[i+k] - s[i] + pre[i-1][0] + suf[i+k][0]
		if cur &gt; t {
			ans = []int{pre[i-1][1], i, suf[i+k][1]}
			t = cur
		}
	}

	return
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 三个无重叠子数组的最大和
// 给你一个整数数组 nums 和一个整数 k
// 找出三个长度为 k 、互不重叠、且全部数字和（3 * k 项）最大的子数组
// 并返回这三个子数组
// 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置
// 如果有多个结果，返回字典序最小的一个
// 测试链接 : https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/
public class Code04_MaximumSum3UnoverlappingSubarrays {

	public static int[] maxSumOfThreeSubarrays(int[] nums, int k) {
		int n = nums.length;
		// sums[i] : 以i开头并且长度为k的子数组的累加和
		int[] sums = new int[n];
		for (int l = 0, r = 0, sum = 0; r &lt; n; r++) {
			// l....r
			sum += nums[r];
			if (r - l + 1 == k) {
				sums[l] = sum;
				sum -= nums[l];
				l++;
			}
		}
		// prefix[i] :
		// 0~i范围上所有长度为k的子数组中，拥有最大累加和的子数组，是以什么位置开头的
		int[] prefix = new int[n];
		for (int l = 1, r = k; r &lt; n; l++, r++) {
			if (sums[l] &gt; sums[prefix[r - 1]]) {
				// 注意&gt;，为了同样最大累加和的情况下，最小的字典序
				prefix[r] = l;
			} else {
				prefix[r] = prefix[r - 1];
			}
		}
		// suffix[i] :
		// i~n-1范围上所有长度为k的子数组中，拥有最大累加和的子数组，是以什么位置开头的
		int[] suffix = new int[n];
		suffix[n - k] = n - k;
		for (int l = n - k - 1; l &gt;= 0; l--) {
			if (sums[l] &gt;= sums[suffix[l + 1]]) {
				// 注意&gt;=，为了同样最大累加和的情况下，最小的字典序
				suffix[l] = l;
			} else {
				suffix[l] = suffix[l + 1];
			}
		}
		int a = 0, b = 0, c = 0, max = 0;
		// 0...i-1    i...j    j+1...n-1
		//   左     中(长度为k)     右
		for (int p, s, i = k, j = 2 * k - 1, sum; j &lt; n - k; i++, j++) {
			// 0.....i-1   i.....j  j+1.....n-1
			// 最好开头p      i开头     最好开头s
			p = prefix[i - 1];
			s = suffix[j + 1];
			sum = sums[p] + sums[i] + sums[s];
			if (sum &gt; max) {
				// 注意&gt;，为了同样最大累加和的情况下，最小的字典序
				max = sum;
				a = p;
				b = i;
				c = s;
			}
		}
		return new int[] { a, b, c };
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="reverse-array-subarray-max-sum"><a class="header" href="#reverse-array-subarray-max-sum">Reverse Array Subarray Max Sum</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 可以翻转1次的情况下子数组最大累加和
// 给定一个数组nums，
// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整
// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]
// 返回必须随意翻转1次之后，子数组的最大累加和
// 对数器验证
public class Code05_ReverseArraySubarrayMaxSum {

	// 暴力方法
	// 为了验证
	public static int maxSumReverse1(int[] nums) {
		int ans = Integer.MIN_VALUE;
		for (int l = 0; l &lt; nums.length; l++) {
			for (int r = l; r &lt; nums.length; r++) {
				reverse(nums, l, r);
				ans = Math.max(ans, maxSum(nums));
				reverse(nums, l, r);
			}
		}
		return ans;
	}

	// nums[l...r]范围上的数字进行逆序调整
	public static void reverse(int[] nums, int l, int r) {
		while (l &lt; r) {
			int tmp = nums[l];
			nums[l++] = nums[r];
			nums[r--] = tmp;
		}
	}

	// 返回子数组最大累加和
	public static int maxSum(int[] nums) {
		int n = nums.length;
		int ans = nums[0];
		for (int i = 1, pre = nums[0]; i &lt; n; i++) {
			pre = Math.max(nums[i], pre + nums[i]);
			ans = Math.max(ans, pre);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSumReverse2(int[] nums) {
		int n = nums.length;
		// start[i] : 所有必须以i开头的子数组中，最大累加和是多少
		int[] start = new int[n];
		start[n - 1] = nums[n - 1];
		for (int i = n - 2; i &gt;= 0; i--) {
			// nums[i]
			// nums[i] + start[i+1]
			start[i] = Math.max(nums[i], nums[i] + start[i + 1]);
		}
		int ans = start[0];
		// end : 子数组必须以i-1结尾，其中的最大累加和
		int end = nums[0];
		// maxEnd :
		// 0~i-1范围上，
		// 子数组必须以0结尾，其中的最大累加和
		// 子数组必须以1结尾，其中的最大累加和
		// ...
		// 子数组必须以i-1结尾，其中的最大累加和
		// 所有情况中，最大的那个累加和就是maxEnd
		int maxEnd = nums[0];
		for (int i = 1; i &lt; n; i++) {
			// maxend   i....
			// 枚举划分点 i...
			ans = Math.max(ans, maxEnd + start[i]);
			// 子数组必须以i结尾，其中的最大累加和
			end = Math.max(nums[i], end + nums[i]);
			maxEnd = Math.max(maxEnd, end);
		}
		ans = Math.max(ans, maxEnd);
		return ans;
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 50;
		int v = 200;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] arr = randomArray(len, v);
			int ans1 = maxSumReverse1(arr);
			int ans2 = maxSumReverse2(arr);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 可以翻转1次的情况下子数组最大累加和
// 给定一个数组nums，
// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整
// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]
// 返回必须随意翻转1次之后，子数组的最大累加和
// 对数器验证
public class Code05_ReverseArraySubarrayMaxSum {

	// 暴力方法
	// 为了验证
	public static int maxSumReverse1(int[] nums) {
		int ans = Integer.MIN_VALUE;
		for (int l = 0; l &lt; nums.length; l++) {
			for (int r = l; r &lt; nums.length; r++) {
				reverse(nums, l, r);
				ans = Math.max(ans, maxSum(nums));
				reverse(nums, l, r);
			}
		}
		return ans;
	}

	// nums[l...r]范围上的数字进行逆序调整
	public static void reverse(int[] nums, int l, int r) {
		while (l &lt; r) {
			int tmp = nums[l];
			nums[l++] = nums[r];
			nums[r--] = tmp;
		}
	}

	// 返回子数组最大累加和
	public static int maxSum(int[] nums) {
		int n = nums.length;
		int ans = nums[0];
		for (int i = 1, pre = nums[0]; i &lt; n; i++) {
			pre = Math.max(nums[i], pre + nums[i]);
			ans = Math.max(ans, pre);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSumReverse2(int[] nums) {
		int n = nums.length;
		// start[i] : 所有必须以i开头的子数组中，最大累加和是多少
		int[] start = new int[n];
		start[n - 1] = nums[n - 1];
		for (int i = n - 2; i &gt;= 0; i--) {
			// nums[i]
			// nums[i] + start[i+1]
			start[i] = Math.max(nums[i], nums[i] + start[i + 1]);
		}
		int ans = start[0];
		// end : 子数组必须以i-1结尾，其中的最大累加和
		int end = nums[0];
		// maxEnd :
		// 0~i-1范围上，
		// 子数组必须以0结尾，其中的最大累加和
		// 子数组必须以1结尾，其中的最大累加和
		// ...
		// 子数组必须以i-1结尾，其中的最大累加和
		// 所有情况中，最大的那个累加和就是maxEnd
		int maxEnd = nums[0];
		for (int i = 1; i &lt; n; i++) {
			// maxend   i....
			// 枚举划分点 i...
			ans = Math.max(ans, maxEnd + start[i]);
			// 子数组必须以i结尾，其中的最大累加和
			end = Math.max(nums[i], end + nums[i]);
			maxEnd = Math.max(maxEnd, end);
		}
		ans = Math.max(ans, maxEnd);
		return ans;
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 50;
		int v = 200;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] arr = randomArray(len, v);
			int ans1 = maxSumReverse1(arr);
			int ans2 = maxSumReverse2(arr);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="delete-one-number-length-k-max-sum"><a class="header" href="#delete-one-number-length-k-max-sum">Delete One Number Length K Max Sum</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 删掉1个数字后长度为k的子数组最大累加和
// 给定一个数组nums，求必须删除一个数字后的新数组中
// 长度为k的子数组最大累加和，删除哪个数字随意
// 对数器验证
public class Code06_DeleteOneNumberLengthKMaxSum {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			int[] rest = delete(nums, i);
			ans = Math.max(ans, lenKmaxSum(rest, k));
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 删掉index位置的元素，然后返回新数组
	public static int[] delete(int[] nums, int index) {
		int len = nums.length - 1;
		int[] ans = new int[len];
		int i = 0;
		for (int j = 0; j &lt; nums.length; j++) {
			if (j != index) {
				ans[i++] = nums[j];
			}
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 枚举每一个子数组找到最大累加和
	public static int lenKmaxSum(int[] nums, int k) {
		int n = nums.length;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt;= n - k; i++) {
			int cur = 0;
			for (int j = i, cnt = 0; cnt &lt; k; j++, cnt++) {
				cur += nums[j];
			}
			ans = Math.max(ans, cur);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(N)
	public static int maxSum2(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		// 单调队列 : 维持窗口内最小值的更新结构，讲解054的内容
		int[] window = new int[n];
		int l = 0;
		int r = 0;
		// 窗口累加和
		long sum = 0;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			// 单调队列 : i位置进入单调队列
			while (l &lt; r &amp;&amp; nums[window[r - 1]] &gt;= nums[i]) {
				r--;
			}
			window[r++] = i;
			sum += nums[i];
			if (i &gt;= k) {
				ans = Math.max(ans, (int) (sum - nums[window[l]]));
				if (window[l] == i - k) {
					// 单调队列 : 如果单调队列最左侧的位置过期了，从队列中弹出
					l++;
				}
				sum -= nums[i - k];
			}
		}
		return ans;
	}

	// 为了测试
	// 生成长度为n，值在[-v, +v]之间的随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (2 * v + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 200;
		int v = 1000;
		int testTimes = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTimes; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int k = (int) (Math.random() * n) + 1;
			int ans1 = maxSum1(nums, k);
			int ans2 = maxSum2(nums, k);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 删掉1个数字后长度为k的子数组最大累加和
// 给定一个数组nums，求必须删除一个数字后的新数组中
// 长度为k的子数组最大累加和，删除哪个数字随意
// 对数器验证
public class Code06_DeleteOneNumberLengthKMaxSum {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			int[] rest = delete(nums, i);
			ans = Math.max(ans, lenKmaxSum(rest, k));
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 删掉index位置的元素，然后返回新数组
	public static int[] delete(int[] nums, int index) {
		int len = nums.length - 1;
		int[] ans = new int[len];
		int i = 0;
		for (int j = 0; j &lt; nums.length; j++) {
			if (j != index) {
				ans[i++] = nums[j];
			}
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 枚举每一个子数组找到最大累加和
	public static int lenKmaxSum(int[] nums, int k) {
		int n = nums.length;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt;= n - k; i++) {
			int cur = 0;
			for (int j = i, cnt = 0; cnt &lt; k; j++, cnt++) {
				cur += nums[j];
			}
			ans = Math.max(ans, cur);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(N)
	public static int maxSum2(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		// 单调队列 : 维持窗口内最小值的更新结构，讲解054的内容
		int[] window = new int[n];
		int l = 0;
		int r = 0;
		// 窗口累加和
		long sum = 0;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			// 单调队列 : i位置进入单调队列
			while (l &lt; r &amp;&amp; nums[window[r - 1]] &gt;= nums[i]) {
				r--;
			}
			window[r++] = i;
			sum += nums[i];
			if (i &gt;= k) {
				ans = Math.max(ans, (int) (sum - nums[window[l]]));
				if (window[l] == i - k) {
					// 单调队列 : 如果单调队列最左侧的位置过期了，从队列中弹出
					l++;
				}
				sum -= nums[i - k];
			}
		}
		return ans;
	}

	// 为了测试
	// 生成长度为n，值在[-v, +v]之间的随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (2 * v + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 200;
		int v = 1000;
		int testTimes = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTimes; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int k = (int) (Math.random() * n) + 1;
			int ans1 = maxSum1(nums, k);
			int ans2 = maxSum2(nums, k);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../dynamic-programming/largest-subarray-sum-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../dynamic-programming/interval-dp-1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../dynamic-programming/largest-subarray-sum-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../dynamic-programming/interval-dp-1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
