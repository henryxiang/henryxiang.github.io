<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Structures and Algorithms for Coding Interviews</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithms for Coding Interviews</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<h2 id="basic-data-structures"><a class="header" href="#basic-data-structures">Basic Data Structures</a></h2>
<ul>
<li>Binary number</li>
<li>Linked list (single and double)</li>
<li>Stack</li>
<li>Queue (including double-end queue)</li>
</ul>
<h2 id="advanced-data-structures"><a class="header" href="#advanced-data-structures">Advanced Data Structures</a></h2>
<ul>
<li>Priority queue (heap)</li>
<li>Monotonic queue and stack</li>
<li>Trie (Prefix Tree)</li>
<li>Binary tree (including BST)</li>
<li>Graph</li>
<li>Disjoint set (union find)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union-find-1"><a class="header" href="#disjoint-set-union-find-1">Disjoint Set (Union Find) 1</a></h1>
<h2 id="implemetations"><a class="header" href="#implemetations">Implemetations</a></h2>
<h3 id="basic-version"><a class="header" href="#basic-version">Basic Version</a></h3>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class056;

// 并查集模版(洛谷)
// 本实现用递归函数实现路径压缩，而且省掉了小挂大的优化，一般情况下可以省略
// 测试链接 : https://www.luogu.com.cn/problem/P3367
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code02_UnionFindLuogu {

	public static int MAXN = 10001;

	public static int[] father = new int[MAXN];

	public static int n;

	public static void build() {
		for (int i = 0; i &lt;= n; i++) {
			father[i] = i;
		}
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static boolean isSameSet(int x, int y) {
		return find(x) == find(y);
	}

	public static void union(int x, int y) {
		father[find(x)] = find(y);
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			build();
			in.nextToken();
			int m = (int) in.nval;
			for (int i = 0; i &lt; m; i++) {
				in.nextToken();
				int z = (int) in.nval;
				in.nextToken();
				int x = (int) in.nval;
				in.nextToken();
				int y = (int) in.nval;
				if (z == 1) {
					union(x, y);
				} else {
					out.println(isSameSet(x, y) ? "Y" : "N");
				}
			}
		}
		out.flush();
		out.close();
		br.close();
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/BouW-NjgRcI?start=0">
    </iframe>
</details>
<h3 id="optimized-version"><a class="header" href="#optimized-version">Optimized Version</a></h3>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class056;

// 并查集模版(牛客)
// 路径压缩 + 小挂大
// 测试链接 : https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code01_UnionFindNowCoder {

	public static int MAXN = 1000001;

	public static int[] father = new int[MAXN];

	public static int[] size = new int[MAXN];

	public static int[] stack = new int[MAXN];

	public static int n;

	public static void build() {
		for (int i = 0; i &lt;= n; i++) {
			father[i] = i;
			size[i] = 1;
		}
	}

	// i号节点，往上一直找，找到代表节点返回！
	public static int find(int i) {
		// 沿途收集了几个点
		int size = 0;
		while (i != father[i]) {
			stack[size++] = i;
			i = father[i];
		}
		// 沿途节点收集好了，i已经跳到代表节点了
		while (size &gt; 0) {
			father[stack[--size]] = i;
		}
		return i;
	}

	public static boolean isSameSet(int x, int y) {
		return find(x) == find(y);
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			// fx是集合的代表：拿大小
			// fy是集合的代表：拿大小
			if (size[fx] &gt;= size[fy]) {
				size[fx] += size[fy];
				father[fy] = fx;
			} else {
				size[fy] += size[fx];
				father[fx] = fy;
			}
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			build();
			in.nextToken();
			int m = (int) in.nval;
			for (int i = 0; i &lt; m; i++) {
				in.nextToken();
				int op = (int) in.nval;
				in.nextToken();
				int x = (int) in.nval;
				in.nextToken();
				int y = (int) in.nval;
				if (op == 1) {
					out.println(isSameSet(x, y) ? "Yes" : "No");
				} else {
					union(x, y);
				}
			}
		}
		out.flush();
		out.close();
		br.close();
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/BouW-NjgRcI?start=0">
    </iframe>
</details>
<h2 id="couples-holding-hands"><a class="header" href="#couples-holding-hands">Couples Holding Hands</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0700-0799/0765.Couples%20Holding%20Hands/README_EN.md
tags:
    - Greedy
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Graph
</code></pre>
<!-- problem:start -->
<h1 id="765-couples-holding-hands"><a class="header" href="#765-couples-holding-hands"><a href="https://leetcode.com/problems/couples-holding-hands">765. Couples Holding Hands</a></a></h1>
<p><a href="data-structures//solution/0700-0799/0765.Couples%20Holding%20Hands/README.html">中文文档</a></p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<!-- description:start -->
<p>There are <code>n</code> couples sitting in <code>2n</code> seats arranged in a row and want to hold hands.</p>
<p>The people and seats are represented by an integer array <code>row</code> where <code>row[i]</code> is the ID of the person sitting in the <code>i<sup>th</sup></code> seat. The couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2n - 2, 2n - 1)</code>.</p>
<p>Return <em>the minimum number of swaps so that every couple is sitting side by side</em>. A swap consists of choosing any two people, then they stand up and switch seats.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> row = [0,2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We only need to swap the second (row[1]) and third (row[2]) person.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> row = [3,2,0,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All couples are already seated side by side.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>2n == row.length</code></li>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>n</code> is even.</li>
	<li><code>0 &lt;= row[i] &lt; 2n</code></li>
	<li>All the elements of <code>row</code> are <strong>unique</strong>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1"><a class="header" href="#solution-1">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3"><a class="header" href="#python3">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def minSwapsCouples(self, row: List[int]) -&gt; int:
        def find(x: int) -&gt; int:
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        n = len(row) &gt;&gt; 1
        p = list(range(n))
        for i in range(0, len(row), 2):
            a, b = row[i] &gt;&gt; 1, row[i + 1] &gt;&gt; 1
            p[find(a)] = find(b)
        return n - sum(i == find(i) for i in range(n))
</code></pre>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<pre><code class="language-java">class Solution {
    private int[] p;

    public int minSwapsCouples(int[] row) {
        int n = row.length &gt;&gt; 1;
        p = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
        }
        for (int i = 0; i &lt; n &lt;&lt; 1; i += 2) {
            int a = row[i] &gt;&gt; 1, b = row[i + 1] &gt;&gt; 1;
            p[find(a)] = find(b);
        }
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            if (i == find(i)) {
                --ans;
            }
        }
        return ans;
    }

    private int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
}
</code></pre>
<h4 id="c"><a class="header" href="#c">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int minSwapsCouples(vector&lt;int&gt;&amp; row) {
        int n = row.size() / 2;
        int p[n];
        iota(p, p + n, 0);
        function&lt;int(int)&gt; find = [&amp;](int x) -&gt; int {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        };
        for (int i = 0; i &lt; n &lt;&lt; 1; i += 2) {
            int a = row[i] &gt;&gt; 1, b = row[i + 1] &gt;&gt; 1;
            p[find(a)] = find(b);
        }
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans -= i == find(i);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go"><a class="header" href="#go">Go</a></h4>
<pre><code class="language-go">func minSwapsCouples(row []int) int {
	n := len(row) &gt;&gt; 1
	p := make([]int, n)
	for i := range p {
		p[i] = i
	}
	var find func(int) int
	find = func(x int) int {
		if p[x] != x {
			p[x] = find(p[x])
		}
		return p[x]
	}
	for i := 0; i &lt; n&lt;&lt;1; i += 2 {
		a, b := row[i]&gt;&gt;1, row[i+1]&gt;&gt;1
		p[find(a)] = find(b)
	}
	ans := n
	for i := range p {
		if find(i) == i {
			ans--
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript"><a class="header" href="#typescript">TypeScript</a></h4>
<pre><code class="language-ts">function minSwapsCouples(row: number[]): number {
    const n = row.length &gt;&gt; 1;
    const p: number[] = Array(n)
        .fill(0)
        .map((_, i) =&gt; i);
    const find = (x: number): number =&gt; {
        if (p[x] !== x) {
            p[x] = find(p[x]);
        }
        return p[x];
    };
    for (let i = 0; i &lt; n &lt;&lt; 1; i += 2) {
        const a = row[i] &gt;&gt; 1;
        const b = row[i + 1] &gt;&gt; 1;
        p[find(a)] = find(b);
    }
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        if (i === find(i)) {
            --ans;
        }
    }
    return ans;
}
</code></pre>
<h4 id="c-1"><a class="header" href="#c-1">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    private int[] p;

    public int MinSwapsCouples(int[] row) {
        int n = row.Length &gt;&gt; 1;
        p = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
        }
        for (int i = 0; i &lt; n &lt;&lt; 1; i += 2) {
            int a = row[i] &gt;&gt; 1;
            int b = row[i + 1] &gt;&gt; 1;
            p[find(a)] = find(b);
        }
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            if (p[i] == i) {
                --ans;
            }
        }
        return ans;
    }

    private int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class056;

// 情侣牵手
// n对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手
// 人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的ID
// 情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)
// 返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起
// 每次交换可选择任意两人，让他们站起来交换座位
// 测试链接 : https://leetcode.com/problems/couples-holding-hands/
public class Code03_CouplesHoldingHands {

	public static int minSwapsCouples(int[] row) {
		int n = row.length;
		build(n / 2);
		for (int i = 0; i &lt; n; i += 2) {
			union(row[i] / 2, row[i + 1] / 2);
		}
		return n / 2 - sets;
	}

	public static int MAXN = 31;

	public static int[] father = new int[MAXN];

	public static int sets;

	public static void build(int m) {
		for (int i = 0; i &lt; m; i++) {
			father[i] = i;
		}
		sets = m;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			sets--;
		}
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/BouW-NjgRcI?start=0">
    </iframe>
</details>
<h2 id="similar-string-groups"><a class="header" href="#similar-string-groups">Similar String Groups</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0800-0899/0839.Similar%20String%20Groups/README_EN.md
tags:
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Array
    - Hash Table
    - String
</code></pre>
<!-- problem:start -->
<h1 id="839-similar-string-groups"><a class="header" href="#839-similar-string-groups"><a href="https://leetcode.com/problems/similar-string-groups">839. Similar String Groups</a></a></h1>
<p><a href="data-structures//solution/0800-0899/0839.Similar%20String%20Groups/README.html">中文文档</a></p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<!-- description:start -->
<p>Two strings, <code>X</code> and <code>Y</code>, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string <code>X</code>.</p>
<p>For example, <code>&quot;tars&quot;</code>&nbsp;and <code>&quot;rats&quot;</code>&nbsp;are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>
<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.&nbsp; Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.&nbsp; Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>
<p>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]
<strong>Output:</strong> 2
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> strs = [&quot;omv&quot;,&quot;ovm&quot;]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= strs.length &lt;= 300</code></li>
	<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>
	<li><code>strs[i]</code> consists of lowercase letters only.</li>
	<li>All words in <code>strs</code> have the same length and are anagrams of each other.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-1"><a class="header" href="#solutions-1">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-union-find"><a class="header" href="#solution-1-union-find">Solution 1: Union-Find</a></h3>
<p>We can enumerate any two strings $s$ and $t$ in the list of strings. Since $s$ and $t$ are anagrams, if the number of differing characters at corresponding positions between $s$ and $t$ does not exceed $2$, then $s$ and $t$ are similar. We can use the union-find data structure to merge $s$ and $t$. If the merge is successful, the number of similar string groups decreases by $1$.</p>
<p>The final number of similar string groups is the number of connected components in the union-find structure.</p>
<p>Time complexity is $O(n^2 \times (m + \alpha(n)))$, and space complexity is $O(n)$. Here, $n$ and $m$ are the length of the list of strings and the length of the strings, respectively, and $\alpha(n)$ is the inverse Ackermann function, which can be considered a very small constant.</p>
<!-- tabs:start -->
<h4 id="python3-1"><a class="header" href="#python3-1">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True


class Solution:
    def numSimilarGroups(self, strs: List[str]) -&gt; int:
        n, m = len(strs), len(strs[0])
        uf = UnionFind(n)
        for i, s in enumerate(strs):
            for j, t in enumerate(strs[:i]):
                if sum(s[k] != t[k] for k in range(m)) &lt;= 2 and uf.union(i, j):
                    n -= 1
        return n
</code></pre>
<h4 id="java-1"><a class="header" href="#java-1">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }
}

class Solution {
    public int numSimilarGroups(String[] strs) {
        int n = strs.length, m = strs[0].length();
        UnionFind uf = new UnionFind(n);
        int cnt = n;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                int diff = 0;
                for (int k = 0; k &lt; m; ++k) {
                    if (strs[i].charAt(k) != strs[j].charAt(k)) {
                        ++diff;
                    }
                }
                if (diff &lt;= 2 &amp;&amp; uf.union(i, j)) {
                    --cnt;
                }
            }
        }
        return cnt;
    }
}
</code></pre>
<h4 id="c-2"><a class="header" href="#c-2">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int numSimilarGroups(vector&lt;string&gt;&amp; strs) {
        int n = strs.size(), m = strs[0].size();
        int cnt = n;
        UnionFind uf(n);
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                int diff = 0;
                for (int k = 0; k &lt; m; ++k) {
                    diff += strs[i][k] != strs[j][k];
                }
                if (diff &lt;= 2 &amp;&amp; uf.unite(i, j)) {
                    --cnt;
                }
            }
        }
        return cnt;
    }
};
</code></pre>
<h4 id="go-1"><a class="header" href="#go-1">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func numSimilarGroups(strs []string) int {
	n := len(strs)
	uf := newUnionFind(n)
	for i, s := range strs {
		for j, t := range strs[:i] {
			diff := 0
			for k := range s {
				if s[k] != t[k] {
					diff++
				}
			}
			if diff &lt;= 2 &amp;&amp; uf.union(i, j) {
				n--
			}
		}
	}
	return n
}
</code></pre>
<h4 id="typescript-1"><a class="header" href="#typescript-1">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    private p: number[];
    private size: number[];

    constructor(n: number) {
        this.p = Array.from({ length: n }, (_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    union(a: number, b: number): boolean {
        const pa = this.find(a);
        const pb = this.find(b);
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }
}

function numSimilarGroups(strs: string[]): number {
    const n = strs.length;
    const m = strs[0].length;
    const uf = new UnionFind(n);
    let cnt = n;
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; i; ++j) {
            let diff = 0;
            for (let k = 0; k &lt; m; ++k) {
                if (strs[i][k] !== strs[j][k]) {
                    diff++;
                }
            }
            if (diff &lt;= 2 &amp;&amp; uf.union(i, j)) {
                cnt--;
            }
        }
    }
    return cnt;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class056;

// 相似字符串组
// 如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等
// 那么称 X 和 Y 两个字符串相似
// 如果这两个字符串本身是相等的，那它们也是相似的
// 例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)；
// "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似
// 总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}
// 注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似
// 形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。
// 给你一个字符串列表 strs列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。
// 返回 strs 中有多少字符串组
// 测试链接 : https://leetcode.com/problems/similar-string-groups/
public class Code04_SimilarStringGroups {

	public static int MAXN = 301;

	public static int[] father = new int[MAXN];

	public static int sets;

	public static void build(int n) {
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
		}
		sets = n;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			sets--;
		}
	}

	public static int numSimilarGroups(String[] strs) {
		int n = strs.length;
		int m = strs[0].length();
		build(n);
		for (int i = 0; i &lt; n; i++) {
			for (int j = i + 1; j &lt; n; j++) {
				if (find(i) != find(j)) {
					int diff = 0;
					for (int k = 0; k &lt; m &amp;&amp; diff &lt; 3; k++) {
						if (strs[i].charAt(k) != strs[j].charAt(k)) {
							diff++;
						}
					}
					if (diff == 0 || diff == 2) {
						union(i, j);
					}
				}
			}
		}
		return sets;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/BouW-NjgRcI?start=0">
    </iframe>
</details>
<h2 id="number-of-islands"><a class="header" href="#number-of-islands">Number of Islands</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0200.Number%20of%20Islands/README_EN.md
tags:
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Array
    - Matrix
</code></pre>
<!-- problem:start -->
<h1 id="200-number-of-islands"><a class="header" href="#200-number-of-islands"><a href="https://leetcode.com/problems/number-of-islands">200. Number of Islands</a></a></h1>
<p><a href="data-structures//solution/0200-0299/0200.Number%20of%20Islands/README.html">中文文档</a></p>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<!-- description:start -->
<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>
<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
<strong>Output:</strong> 1
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
<strong>Output:</strong> 3
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-2"><a class="header" href="#solutions-2">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-1"><a class="header" href="#solution-1-1">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-2"><a class="header" href="#python3-2">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        def dfs(i, j):
            grid[i][j] = '0'
            for a, b in pairwise(dirs):
                x, y = i + a, j + b
                if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and grid[x][y] == '1':
                    dfs(x, y)

        ans = 0
        dirs = (-1, 0, 1, 0, -1)
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    dfs(i, j)
                    ans += 1
        return ans
</code></pre>
<h4 id="java-2"><a class="header" href="#java-2">Java</a></h4>
<pre><code class="language-java">class Solution {
    private char[][] grid;
    private int m;
    private int n;

    public int numIslands(char[][] grid) {
        m = grid.length;
        n = grid[0].length;
        this.grid = grid;
        int ans = 0;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    ++ans;
                }
            }
        }
        return ans;
    }

    private void dfs(int i, int j) {
        grid[i][j] = '0';
        int[] dirs = {-1, 0, 1, 0, -1};
        for (int k = 0; k &lt; 4; ++k) {
            int x = i + dirs[k];
            int y = j + dirs[k + 1];
            if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1') {
                dfs(x, y);
            }
        }
    }
}
</code></pre>
<h4 id="c-3"><a class="header" href="#c-3">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        int dirs[5] = {-1, 0, 1, 0, -1};
        function&lt;void(int, int)&gt; dfs = [&amp;](int i, int j) {
            grid[i][j] = '0';
            for (int k = 0; k &lt; 4; ++k) {
                int x = i + dirs[k], y = j + dirs[k + 1];
                if (x &gt;= 0 &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == '1') {
                    dfs(x, y);
                }
            }
        };
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    ++ans;
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-2"><a class="header" href="#go-2">Go</a></h4>
<pre><code class="language-go">func numIslands(grid [][]byte) int {
	m, n := len(grid), len(grid[0])
	var dfs func(i, j int)
	dfs = func(i, j int) {
		grid[i][j] = '0'
		dirs := []int{-1, 0, 1, 0, -1}
		for k := 0; k &lt; 4; k++ {
			x, y := i+dirs[k], j+dirs[k+1]
			if x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1' {
				dfs(x, y)
			}
		}
	}
	ans := 0
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if grid[i][j] == '1' {
				dfs(i, j)
				ans++
			}
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-2"><a class="header" href="#typescript-2">TypeScript</a></h4>
<pre><code class="language-ts">function numIslands(grid: string[][]): number {
    const m = grid.length;
    const n = grid[0].length;
    let ans = 0;
    const dfs = (i: number, j: number) =&gt; {
        if (grid[i]?.[j] !== '1') {
            return;
        }
        grid[i][j] = '0';
        dfs(i + 1, j);
        dfs(i - 1, j);
        dfs(i, j + 1);
        dfs(i, j - 1);
    };
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (grid[i][j] === '1') {
                dfs(i, j);
                ++ans;
            }
        }
    }
    return ans;
}
</code></pre>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const DIRS: [i32; 5] = [-1, 0, 1, 0, -1];

impl Solution {
    pub fn num_islands(grid: Vec&lt;Vec&lt;char&gt;&gt;) -&gt; i32 {
        fn dfs(grid: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, i: usize, j: usize) {
            grid[i][j] = '0';
            for k in 0..4 {
                let x = (i as i32) + DIRS[k];
                let y = (j as i32) + DIRS[k + 1];
                if x &gt;= 0
                    &amp;&amp; (x as usize) &lt; grid.len()
                    &amp;&amp; y &gt;= 0
                    &amp;&amp; (y as usize) &lt; grid[0].len()
                    &amp;&amp; grid[x as usize][y as usize] == '1'
                {
                    dfs(grid, x as usize, y as usize);
                }
            }
        }

        let mut grid = grid;
        let mut ans = 0;
        for i in 0..grid.len() {
            for j in 0..grid[0].len() {
                if grid[i][j] == '1' {
                    dfs(&amp;mut grid, i, j);
                    ans += 1;
                }
            }
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="c-4"><a class="header" href="#c-4">C#</a></h4>
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    public int NumIslands(char[][] grid)
    {
        var queue = new Queue&lt;Tuple&lt;int, int&gt;&gt;();
        var lenI = grid.Length;
        var lenJ = lenI == 0 ? 0 : grid[0].Length;
        var paths = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };
        var result = 0;
        for (var i = 0; i &lt; lenI; ++i)
        {
            for (var j = 0; j &lt; lenJ; ++j)
            {
                if (grid[i][j] == '1')
                {
                    ++result;
                    grid[i][j] = '0';
                    queue.Enqueue(Tuple.Create(i, j));
                    while (queue.Any())
                    {
                        var position = queue.Dequeue();
                        for (var k = 0; k &lt; 4; ++k)
                        {
                            var next = Tuple.Create(position.Item1 + paths[k, 0], position.Item2 + paths[k, 1]);
                            if (next.Item1 &gt;= 0 &amp;&amp; next.Item1 &lt; lenI &amp;&amp; next.Item2 &gt;= 0 &amp;&amp; next.Item2 &lt; lenJ &amp;&amp; grid[next.Item1][next.Item2] == '1')
                            {
                                grid[next.Item1][next.Item2] = '0';
                                queue.Enqueue(next);
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2"><a class="header" href="#solution-2">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-3"><a class="header" href="#python3-3">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        def bfs(i, j):
            grid[i][j] = '0'
            q = deque([(i, j)])
            while q:
                i, j = q.popleft()
                for a, b in pairwise(dirs):
                    x, y = i + a, j + b
                    if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and grid[x][y] == '1':
                        q.append((x, y))
                        grid[x][y] = 0

        ans = 0
        dirs = (-1, 0, 1, 0, -1)
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    bfs(i, j)
                    ans += 1
        return ans
</code></pre>
<h4 id="java-3"><a class="header" href="#java-3">Java</a></h4>
<pre><code class="language-java">class Solution {
    private char[][] grid;
    private int m;
    private int n;

    public int numIslands(char[][] grid) {
        m = grid.length;
        n = grid[0].length;
        this.grid = grid;
        int ans = 0;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1') {
                    bfs(i, j);
                    ++ans;
                }
            }
        }
        return ans;
    }

    private void bfs(int i, int j) {
        grid[i][j] = '0';
        Deque&lt;int[]&gt; q = new ArrayDeque&lt;&gt;();
        q.offer(new int[] {i, j});
        int[] dirs = {-1, 0, 1, 0, -1};
        while (!q.isEmpty()) {
            int[] p = q.poll();
            for (int k = 0; k &lt; 4; ++k) {
                int x = p[0] + dirs[k];
                int y = p[1] + dirs[k + 1];
                if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1') {
                    q.offer(new int[] {x, y});
                    grid[x][y] = '0';
                }
            }
        }
    }
}
</code></pre>
<h4 id="c-5"><a class="header" href="#c-5">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        int dirs[5] = {-1, 0, 1, 0, -1};
        function&lt;void(int, int)&gt; bfs = [&amp;](int i, int j) {
            grid[i][j] = '0';
            queue&lt;pair&lt;int, int&gt;&gt; q;
            q.push({i, j});
            vector&lt;int&gt; dirs = {-1, 0, 1, 0, -1};
            while (!q.empty()) {
                auto [a, b] = q.front();
                q.pop();
                for (int k = 0; k &lt; 4; ++k) {
                    int x = a + dirs[k];
                    int y = b + dirs[k + 1];
                    if (x &gt;= 0 &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == '1') {
                        q.push({x, y});
                        grid[x][y] = '0';
                    }
                }
            }
        };
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1') {
                    bfs(i, j);
                    ++ans;
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-3"><a class="header" href="#go-3">Go</a></h4>
<pre><code class="language-go">func numIslands(grid [][]byte) int {
	m, n := len(grid), len(grid[0])
	bfs := func(i, j int) {
		grid[i][j] = '0'
		q := [][]int{[]int{i, j}}
		dirs := []int{-1, 0, 1, 0, -1}
		for len(q) &gt; 0 {
			p := q[0]
			q = q[1:]
			for k := 0; k &lt; 4; k++ {
				x, y := p[0]+dirs[k], p[1]+dirs[k+1]
				if x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1' {
					q = append(q, []int{x, y})
					grid[x][y] = '0'
				}
			}
		}
	}
	ans := 0
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if grid[i][j] == '1' {
				bfs(i, j)
				ans++
			}
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-3"><a class="header" href="#typescript-3">TypeScript</a></h4>
<pre><code class="language-ts">function numIslands(grid: string[][]): number {
    const m = grid.length;
    const n = grid[0].length;
    let ans = 0;
    function bfs(i, j) {
        grid[i][j] = '0';
        let q = [[i, j]];
        const dirs = [-1, 0, 1, 0, -1];
        while (q.length) {
            [i, j] = q.shift();
            for (let k = 0; k &lt; 4; ++k) {
                const x = i + dirs[k];
                const y = j + dirs[k + 1];
                if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1') {
                    q.push([x, y]);
                    grid[x][y] = '0';
                }
            }
        }
    }
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (grid[i][j] == '1') {
                bfs(i, j);
                ++ans;
            }
        }
    }
    return ans;
}
</code></pre>
<h4 id="rust-1"><a class="header" href="#rust-1">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::VecDeque;

const DIRS: [i32; 5] = [-1, 0, 1, 0, -1];

impl Solution {
    pub fn num_islands(grid: Vec&lt;Vec&lt;char&gt;&gt;) -&gt; i32 {
        fn bfs(grid: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, i: usize, j: usize) {
            grid[i][j] = '0';
            let mut queue = VecDeque::from([(i, j)]);
            while !queue.is_empty() {
                let (i, j) = queue.pop_front().unwrap();
                for k in 0..4 {
                    let x = (i as i32) + DIRS[k];
                    let y = (j as i32) + DIRS[k + 1];
                    if x &gt;= 0
                        &amp;&amp; (x as usize) &lt; grid.len()
                        &amp;&amp; y &gt;= 0
                        &amp;&amp; (y as usize) &lt; grid[0].len()
                        &amp;&amp; grid[x as usize][y as usize] == '1'
                    {
                        grid[x as usize][y as usize] = '0';
                        queue.push_back((x as usize, y as usize));
                    }
                }
            }
        }

        let mut grid = grid;
        let mut ans = 0;
        for i in 0..grid.len() {
            for j in 0..grid[0].len() {
                if grid[i][j] == '1' {
                    bfs(&amp;mut grid, i, j);
                    ans += 1;
                }
            }
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3"><a class="header" href="#solution-3">Solution 3</a></h3>
<!-- tabs:start -->
<h4 id="python3-4"><a class="header" href="#python3-4">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        dirs = (0, 1, 0)
        m, n = len(grid), len(grid[0])
        p = list(range(m * n))
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for a, b in pairwise(dirs):
                        x, y = i + a, j + b
                        if x &lt; m and y &lt; n and grid[x][y] == '1':
                            p[find(i * n + j)] = find(x * n + y)
        return sum(
            grid[i][j] == '1' and i * n + j == find(i * n + j)
            for i in range(m)
            for j in range(n)
        )
</code></pre>
<h4 id="java-4"><a class="header" href="#java-4">Java</a></h4>
<pre><code class="language-java">class Solution {
    private int[] p;

    public int numIslands(char[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        p = new int[m * n];
        for (int i = 0; i &lt; p.length; ++i) {
            p[i] = i;
        }
        int[] dirs = {1, 0, 1};
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1') {
                    for (int k = 0; k &lt; 2; ++k) {
                        int x = i + dirs[k];
                        int y = j + dirs[k + 1];
                        if (x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1') {
                            p[find(x * n + y)] = find(i * n + j);
                        }
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1' &amp;&amp; i * n + j == find(i * n + j)) {
                    ++ans;
                }
            }
        }
        return ans;
    }

    private int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
}
</code></pre>
<h4 id="c-6"><a class="header" href="#c-6">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector&lt;int&gt; p(m * n);
        iota(p.begin(), p.end(), 0);
        function&lt;int(int)&gt; find = [&amp;](int x) -&gt; int {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        };
        int dirs[3] = {1, 0, 1};
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1') {
                    for (int k = 0; k &lt; 2; ++k) {
                        int x = i + dirs[k];
                        int y = j + dirs[k + 1];
                        if (x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1') {
                            p[find(x * n + y)] = find(i * n + j);
                        }
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                ans += grid[i][j] == '1' &amp;&amp; i * n + j == find(i * n + j);
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-4"><a class="header" href="#go-4">Go</a></h4>
<pre><code class="language-go">func numIslands(grid [][]byte) int {
	m, n := len(grid), len(grid[0])
	p := make([]int, m*n)
	for i := range p {
		p[i] = i
	}
	var find func(x int) int
	find = func(x int) int {
		if p[x] != x {
			p[x] = find(p[x])
		}
		return p[x]
	}
	dirs := []int{1, 0, 1}
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if grid[i][j] == '1' {
				for k := 0; k &lt; 2; k++ {
					x, y := i+dirs[k], j+dirs[k+1]
					if x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1' {
						p[find(x*n+y)] = find(i*n + j)
					}
				}
			}
		}
	}
	ans := 0
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if grid[i][j] == '1' &amp;&amp; i*n+j == find(i*n+j) {
				ans++
			}
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-4"><a class="header" href="#typescript-4">TypeScript</a></h4>
<pre><code class="language-ts">function numIslands(grid: string[][]): number {
    const m = grid.length;
    const n = grid[0].length;
    let p = [];
    for (let i = 0; i &lt; m * n; ++i) {
        p.push(i);
    }
    function find(x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
    const dirs = [1, 0, 1];
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (grid[i][j] == '1') {
                for (let k = 0; k &lt; 2; ++k) {
                    const x = i + dirs[k];
                    const y = j + dirs[k + 1];
                    if (x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1') {
                        p[find(i * n + j)] = find(x * n + y);
                    }
                }
            }
        }
    }
    let ans = 0;
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (grid[i][j] == '1' &amp;&amp; i * n + j == find(i * n + j)) {
                ++ans;
            }
        }
    }
    return ans;
}
</code></pre>
<h4 id="rust-2"><a class="header" href="#rust-2">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const DIRS: [usize; 3] = [1, 0, 1];

impl Solution {
    pub fn num_islands(grid: Vec&lt;Vec&lt;char&gt;&gt;) -&gt; i32 {
        let m = grid.len();
        let n = grid[0].len();
        let mut p: Vec&lt;i32&gt; = (0..(m * n) as i32).collect();

        fn find(p: &amp;mut Vec&lt;i32&gt;, x: usize) -&gt; i32 {
            if p[x] != (x as i32) {
                p[x] = find(p, p[x] as usize);
            }
            p[x]
        }

        for i in 0..m {
            for j in 0..n {
                if grid[i][j] == '1' {
                    for k in 0..2 {
                        let x = i + DIRS[k];
                        let y = j + DIRS[k + 1];
                        if x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1' {
                            let f1 = find(&amp;mut p, x * n + y);
                            let f2 = find(&amp;mut p, i * n + j);
                            p[f1 as usize] = f2;
                        }
                    }
                }
            }
        }

        let mut ans = 0;
        for i in 0..m {
            for j in 0..n {
                if grid[i][j] == '1' &amp;&amp; p[i * n + j] == ((i * n + j) as i32) {
                    ans += 1;
                }
            }
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class056;

// 岛屿数量
// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量
// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成
// 此外，你可以假设该网格的四条边均被水包围
// 测试链接 : https://leetcode.com/problems/number-of-islands/
public class Code05_NumberOfIslands {

	// 并查集的做法
	public static int numIslands(char[][] board) {
		int n = board.length;
		int m = board[0].length;
		build(n, m, board);
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; m; j++) {
				if (board[i][j] == '1') {
					if (j &gt; 0 &amp;&amp; board[i][j - 1] == '1') {
						union(i, j, i, j - 1);
					}
					if (i &gt; 0 &amp;&amp; board[i - 1][j] == '1') {
						union(i, j, i - 1, j);
					}
				}
			}
		}
		return sets;
	}

	public static int MAXSIZE = 100001;

	public static int[] father = new int[MAXSIZE];

	public static int cols;

	public static int sets;

	public static void build(int n, int m, char[][] board) {
		cols = m;
		sets = 0;
		for (int a = 0; a &lt; n; a++) {
			for (int b = 0, index; b &lt; m; b++) {
				if (board[a][b] == '1') {
					index = index(a, b);
					father[index] = index;
					sets++;
				}
			}
		}
	}

	public static int index(int a, int b) {
		return a * cols + b;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int a, int b, int c, int d) {
		int fx = find(index(a, b));
		int fy = find(index(c, d));
		if (fx != fy) {
			father[fx] = fy;
			sets--;
		}
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/BouW-NjgRcI?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union-find-2"><a class="header" href="#disjoint-set-union-find-2">Disjoint Set (Union Find) 2</a></h1>
<h2 id="most-stones-removed-with-same-row-or-column"><a class="header" href="#most-stones-removed-with-same-row-or-column">Most Stones Removed with Same Row or Column</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0947.Most%20Stones%20Removed%20with%20Same%20Row%20or%20Column/README_EN.md
tags:
    - Depth-First Search
    - Union Find
    - Graph
    - Hash Table
</code></pre>
<!-- problem:start -->
<h1 id="947-most-stones-removed-with-same-row-or-column"><a class="header" href="#947-most-stones-removed-with-same-row-or-column"><a href="https://leetcode.com/problems/most-stones-removed-with-same-row-or-column">947. Most Stones Removed with Same Row or Column</a></a></h1>
<p><a href="data-structures//solution/0900-0999/0947.Most%20Stones%20Removed%20with%20Same%20Row%20or%20Column/README.html">中文文档</a></p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<!-- description:start -->
<p>On a 2D plane, we place <code>n</code> stones at some integer coordinate points. Each coordinate point may have at most one stone.</p>
<p>A stone can be removed if it shares either <strong>the same row or the same column</strong> as another stone that has not been removed.</p>
<p>Given an array <code>stones</code> of length <code>n</code> where <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of the <code>i<sup>th</sup></code> stone, return <em>the largest possible number of stones that can be removed</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> stones = [[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> [0,0] is the only stone on the plane, so you cannot remove it.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>No two stones are at the same coordinate point.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-3"><a class="header" href="#solutions-3">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-union-find-1"><a class="header" href="#solution-1-union-find-1">Solution 1: Union-Find</a></h3>
<p>We can use a union-find data structure to maintain the relationships between stones. If two stones are in the same row or column, we consider them to be connected and use the union-find to link them together. In the end, we count how many connected components there are in the union-find, which corresponds to the number of stones that can remain. Therefore, the total number of stones that can be removed is the total number of stones minus the number of stones that can remain. We can also record the number of successful unions during the merge process, which equals the number of stones that can be removed.</p>
<p>The time complexity is $O(n^2 \times \alpha(n))$, and the space complexity is $O(n)$. Here, $n$ is the number of stones.</p>
<!-- tabs:start -->
<h4 id="python3-5"><a class="header" href="#python3-5">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True


class Solution:
    def removeStones(self, stones: List[List[int]]) -&gt; int:
        uf = UnionFind(len(stones))
        ans = 0
        for i, (x1, y1) in enumerate(stones):
            for j, (x2, y2) in enumerate(stones[:i]):
                if x1 == x2 or y1 == y2:
                    ans += uf.union(i, j)
        return ans
</code></pre>
<h4 id="java-5"><a class="header" href="#java-5">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }
}

class Solution {
    public int removeStones(int[][] stones) {
        int n = stones.length;
        UnionFind uf = new UnionFind(n);
        int ans = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ans += uf.union(i, j) ? 1 : 0;
                }
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-7"><a class="header" href="#c-7">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) {
        int n = stones.size();
        UnionFind uf(n);
        int ans = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ans += uf.unite(i, j);
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-5"><a class="header" href="#go-5">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func removeStones(stones [][]int) (ans int) {
	n := len(stones)
	uf := newUnionFind(n)
	for i, s1 := range stones {
		for j, s2 := range stones[:i] {
			if s1[0] == s2[0] || s1[1] == s2[1] {
				if uf.union(i, j) {
					ans++
				}
			}
		}
	}
	return
}
</code></pre>
<h4 id="typescript-5"><a class="header" href="#typescript-5">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    p: number[];
    size: number[];
    constructor(n: number) {
        this.p = Array.from({ length: n }, (_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }

    union(a: number, b: number): boolean {
        const [pa, pb] = [this.find(a), this.find(b)];
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }
}

function removeStones(stones: number[][]): number {
    const n = stones.length;
    const uf = new UnionFind(n);
    let ans = 0;
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; i; ++j) {
            if (stones[i][0] === stones[j][0] || stones[i][1] === stones[j][1]) {
                ans += uf.union(i, j) ? 1 : 0;
            }
        }
    }
    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-union-find-optimized"><a class="header" href="#solution-2-union-find-optimized">Solution 2: Union-Find (Optimized)</a></h3>
<p>We can add an offset to the y-coordinates of the stones, allowing us to unify the x-coordinates and y-coordinates. Then, we use a union-find data structure to maintain the relationship between x-coordinates and y-coordinates.</p>
<p>We iterate through each stone, merging its x-coordinate with its y-coordinate.</p>
<p>Finally, we iterate through all the stones again, putting the root node of each stone's x-coordinate into a set. The number of elements in this set represents the number of stones that can remain. Therefore, the total number of stones that can be removed is the total number of stones minus the number of stones that can remain.</p>
<p>The time complexity is $O(n \times \alpha(m))$, and the space complexity is $O(m)$. Here, $n$ and $m$ represent the number of stones and the maximum value of the coordinates, respectively.</p>
<!-- tabs:start -->
<h4 id="python3-6"><a class="header" href="#python3-6">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True


class Solution:
    def removeStones(self, stones: List[List[int]]) -&gt; int:
        m = 10001
        uf = UnionFind(m &lt;&lt; 1)
        for x, y in stones:
            uf.union(x, y + m)
        return len(stones) - len({uf.find(x) for x, _ in stones})
</code></pre>
<h4 id="java-6"><a class="header" href="#java-6">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }
}

class Solution {
    public int removeStones(int[][] stones) {
        int m = 10001;
        UnionFind uf = new UnionFind(m &lt;&lt; 1);
        for (var st : stones) {
            uf.union(st[0], st[1] + m);
        }
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for (var st : stones) {
            s.add(uf.find(st[0]));
        }
        return stones.length - s.size();
    }
}
</code></pre>
<h4 id="c-8"><a class="header" href="#c-8">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) {
        int m = 10001;
        UnionFind uf(m &lt;&lt; 1);
        for (auto&amp; st : stones) {
            uf.unite(st[0], st[1] + m);
        }
        unordered_set&lt;int&gt; s;
        for (auto&amp; st : stones) {
            s.insert(uf.find(st[0]));
        }
        return stones.size() - s.size();
    }
};
</code></pre>
<h4 id="go-6"><a class="header" href="#go-6">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func removeStones(stones [][]int) (ans int) {
	m := 10001
	uf := newUnionFind(m &lt;&lt; 1)
	for _, st := range stones {
		uf.union(st[0], st[1]+m)
	}
	s := map[int]bool{}
	for _, st := range stones {
		s[uf.find(st[0])] = true
	}
	return len(stones) - len(s)
}
</code></pre>
<h4 id="typescript-6"><a class="header" href="#typescript-6">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    p: number[];
    size: number[];
    constructor(n: number) {
        this.p = Array.from({ length: n }, (_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }

    union(a: number, b: number): boolean {
        const [pa, pb] = [this.find(a), this.find(b)];
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }
}

function removeStones(stones: number[][]): number {
    const m = 10001;
    const uf = new UnionFind(m &lt;&lt; 1);
    for (const [x, y] of stones) {
        uf.union(x, y + m);
    }
    const s = new Set&lt;number&gt;();
    for (const [x, _] of stones) {
        s.add(uf.find(x));
    }
    return stones.length - s.size;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-dfs"><a class="header" href="#solution-3-dfs">Solution 3: DFS</a></h3>
<!-- tabs:start -->
<h4 id="typescript-7"><a class="header" href="#typescript-7">TypeScript</a></h4>
<pre><code class="language-ts">function removeStones(stones: number[][]): number {
    const n = stones.length;
    const g: number[][] = Array.from({ length: n }, () =&gt; []);

    for (let i = 0; i &lt; n; i++) {
        const [y, x] = stones[i];
        for (let j = i + 1; j &lt; n; j++) {
            if (y === stones[j][0] || x === stones[j][1]) {
                g[i].push(j);
                g[j].push(i);
            }
        }
    }

    const dfs = (i: number) =&gt; {
        const seen = new Set&lt;number&gt;();

        let q = [i];
        while (q.length) {
            const qNext: number[] = [];

            for (const i of q) {
                if (seen.has(i)) continue;
                seen.add(i);
                set.delete(i);
                qNext.push(...g[i]);
            }

            q = qNext;
        }
    };

    const set = new Set(Array.from({ length: n }, (_, i) =&gt; i));
    let ans = n;
    for (const i of set) {
        dfs(i);
        ans--;
    }

    return ans;
}
</code></pre>
<h4 id="javascript"><a class="header" href="#javascript">JavaScript</a></h4>
<pre><code class="language-js">function removeStones(stones) {
    const n = stones.length;
    const g = Array.from({ length: n }, () =&gt; []);

    for (let i = 0; i &lt; n; i++) {
        const [y, x] = stones[i];
        for (let j = i + 1; j &lt; n; j++) {
            if (y === stones[j][0] || x === stones[j][1]) {
                g[i].push(j);
                g[j].push(i);
            }
        }
    }

    const dfs = i =&gt; {
        const seen = new Set();

        let q = [i];
        while (q.length) {
            const qNext = [];

            for (const i of q) {
                if (seen.has(i)) continue;
                seen.add(i);
                set.delete(i);
                qNext.push(...g[i]);
            }

            q = qNext;
        }
    };

    const set = new Set(Array.from({ length: n }, (_, i) =&gt; i));
    let ans = n;
    for (const i of set) {
        dfs(i);
        ans--;
    }

    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.HashMap;

// 移除最多的同行或同列石头
// n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头
// 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头
// 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置
// 返回 可以移除的石子 的最大数量。
// 测试链接 : https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
public class Code01_MostStonesRemovedWithSameRowOrColumn {

	// key : 某行
	// value : 第一次遇到的石头编号
	public static HashMap&lt;Integer, Integer&gt; rowFirst = new HashMap&lt;Integer, Integer&gt;();

	public static HashMap&lt;Integer, Integer&gt; colFirst = new HashMap&lt;Integer, Integer&gt;();

	public static int MAXN = 1001;

	public static int[] father = new int[MAXN];

	public static int sets;

	public static void build(int n) {
		rowFirst.clear();
		colFirst.clear();
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
		}
		sets = n;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			sets--;
		}
	}

	public static int removeStones(int[][] stones) {
		int n = stones.length;
		build(n);
		for (int i = 0; i &lt; n; i++) {
			int row = stones[i][0];
			int col = stones[i][1];
			if (!rowFirst.containsKey(row)) {
				rowFirst.put(row, i);
			} else {
				union(i, rowFirst.get(row));
			}
			if (!colFirst.containsKey(col)) {
				colFirst.put(col, i);
			} else {
				union(i, colFirst.get(col));
			}
		}
		return n - sets;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<h2 id="find-all-people-with-secret"><a class="header" href="#find-all-people-with-secret">Find All People With Secret</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/2000-2099/2092.Find%20All%20People%20With%20Secret/README_EN.md
rating: 2003
source: Weekly Contest 269 Q4
tags:
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Graph
    - Sorting
</code></pre>
<!-- problem:start -->
<h1 id="2092-find-all-people-with-secret"><a class="header" href="#2092-find-all-people-with-secret"><a href="https://leetcode.com/problems/find-all-people-with-secret">2092. Find All People With Secret</a></a></h1>
<p><a href="data-structures//solution/2000-2099/2092.Find%20All%20People%20With%20Secret/README.html">中文文档</a></p>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<!-- description:start -->
<p>You are given an integer <code>n</code> indicating there are <code>n</code> people numbered from <code>0</code> to <code>n - 1</code>. You are also given a <strong>0-indexed</strong> 2D integer array <code>meetings</code> where <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> indicates that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> have a meeting at <code>time<sub>i</sub></code>. A person may attend <strong>multiple meetings</strong> at the same time. Finally, you are given an integer <code>firstPerson</code>.</p>
<p>Person <code>0</code> has a <strong>secret</strong> and initially shares the secret with a person <code>firstPerson</code> at time <code>0</code>. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person <code>x<sub>i</sub></code> has the secret at <code>time<sub>i</sub></code>, then they will share the secret with person <code>y<sub>i</sub></code>, and vice versa.</p>
<p>The secrets are shared <strong>instantaneously</strong>. That is, a person may receive the secret and share it with people in other meetings within the same time frame.</p>
<p>Return <em>a list of all the people that have the secret after all the meetings have taken place. </em>You may return the answer in <strong>any order</strong>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,5]
<strong>Explanation:
</strong>At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.​​​​
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>Output:</strong> [0,1,3]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
	<li><code>meetings[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-4"><a class="header" href="#solutions-4">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-2"><a class="header" href="#solution-1-2">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-7"><a class="header" href="#python3-7">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def findAllPeople(
        self, n: int, meetings: List[List[int]], firstPerson: int
    ) -&gt; List[int]:
        vis = [False] * n
        vis[0] = vis[firstPerson] = True
        meetings.sort(key=lambda x: x[2])
        i, m = 0, len(meetings)
        while i &lt; m:
            j = i
            while j + 1 &lt; m and meetings[j + 1][2] == meetings[i][2]:
                j += 1
            s = set()
            g = defaultdict(list)
            for x, y, _ in meetings[i : j + 1]:
                g[x].append(y)
                g[y].append(x)
                s.update([x, y])
            q = deque([u for u in s if vis[u]])
            while q:
                u = q.popleft()
                for v in g[u]:
                    if not vis[v]:
                        vis[v] = True
                        q.append(v)
            i = j + 1
        return [i for i, v in enumerate(vis) if v]
</code></pre>
<h4 id="java-7"><a class="header" href="#java-7">Java</a></h4>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int firstPerson) {
        boolean[] vis = new boolean[n];
        vis[0] = true;
        vis[firstPerson] = true;
        int m = meetings.length;
        Arrays.sort(meetings, Comparator.comparingInt(a -&gt; a[2]));
        for (int i = 0; i &lt; m;) {
            int j = i;
            for (; j + 1 &lt; m &amp;&amp; meetings[j + 1][2] == meetings[i][2]; ++j)
                ;
            Map&lt;Integer, List&lt;Integer&gt;&gt; g = new HashMap&lt;&gt;();
            Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
            for (int k = i; k &lt;= j; ++k) {
                int x = meetings[k][0], y = meetings[k][1];
                g.computeIfAbsent(x, key -&gt; new ArrayList&lt;&gt;()).add(y);
                g.computeIfAbsent(y, key -&gt; new ArrayList&lt;&gt;()).add(x);
                s.add(x);
                s.add(y);
            }
            Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
            for (int u : s) {
                if (vis[u]) {
                    q.offer(u);
                }
            }
            while (!q.isEmpty()) {
                int u = q.poll();
                for (int v : g.getOrDefault(u, Collections.emptyList())) {
                    if (!vis[v]) {
                        vis[v] = true;
                        q.offer(v);
                    }
                }
            }
            i = j + 1;
        }
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; ++i) {
            if (vis[i]) {
                ans.add(i);
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-9"><a class="header" href="#c-9">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        vector&lt;bool&gt; vis(n);
        vis[0] = vis[firstPerson] = true;
        sort(meetings.begin(), meetings.end(), [&amp;](const auto&amp; x, const auto&amp; y) {
            return x[2] &lt; y[2];
        });
        for (int i = 0, m = meetings.size(); i &lt; m;) {
            int j = i;
            for (; j + 1 &lt; m &amp;&amp; meetings[j + 1][2] == meetings[i][2]; ++j)
                ;
            unordered_map&lt;int, vector&lt;int&gt;&gt; g;
            unordered_set&lt;int&gt; s;
            for (int k = i; k &lt;= j; ++k) {
                int x = meetings[k][0], y = meetings[k][1];
                g[x].push_back(y);
                g[y].push_back(x);
                s.insert(x);
                s.insert(y);
            }
            queue&lt;int&gt; q;
            for (int u : s)
                if (vis[u])
                    q.push(u);
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v : g[u]) {
                    if (!vis[v]) {
                        vis[v] = true;
                        q.push(v);
                    }
                }
            }
            i = j + 1;
        }
        vector&lt;int&gt; ans;
        for (int i = 0; i &lt; n; ++i)
            if (vis[i])
                ans.push_back(i);
        return ans;
    }
};
</code></pre>
<h4 id="go-7"><a class="header" href="#go-7">Go</a></h4>
<pre><code class="language-go">func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
	vis := make([]bool, n)
	vis[0], vis[firstPerson] = true, true
	sort.Slice(meetings, func(i, j int) bool {
		return meetings[i][2] &lt; meetings[j][2]
	})
	for i, j, m := 0, 0, len(meetings); i &lt; m; i = j + 1 {
		j = i
		for j+1 &lt; m &amp;&amp; meetings[j+1][2] == meetings[i][2] {
			j++
		}
		g := map[int][]int{}
		s := map[int]bool{}
		for _, e := range meetings[i : j+1] {
			x, y := e[0], e[1]
			g[x] = append(g[x], y)
			g[y] = append(g[y], x)
			s[x], s[y] = true, true
		}
		q := []int{}
		for u := range s {
			if vis[u] {
				q = append(q, u)
			}
		}
		for len(q) &gt; 0 {
			u := q[0]
			q = q[1:]
			for _, v := range g[u] {
				if !vis[v] {
					vis[v] = true
					q = append(q, v)
				}
			}
		}
	}
	var ans []int
	for i, v := range vis {
		if v {
			ans = append(ans, i)
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-8"><a class="header" href="#typescript-8">TypeScript</a></h4>
<pre><code class="language-ts">function findAllPeople(n: number, meetings: number[][], firstPerson: number): number[] {
    let parent: Array&lt;number&gt; = Array.from({ length: n + 1 }, (v, i) =&gt; i);
    parent[firstPerson] = 0;

    function findParent(index: number): number {
        if (parent[index] != index) parent[index] = findParent(parent[index]);
        return parent[index];
    }

    let map = new Map&lt;number, Array&lt;Array&lt;number&gt;&gt;&gt;();
    for (let meeting of meetings) {
        const time = meeting[2];
        let members: Array&lt;Array&lt;number&gt;&gt; = map.get(time) || new Array();
        members.push(meeting);
        map.set(time, members);
    }
    const times = [...map.keys()].sort((a, b) =&gt; a - b);
    for (let time of times) {
        // round 1
        for (let meeting of map.get(time)) {
            let [a, b] = meeting;
            if (!parent[findParent(a)] || !parent[findParent(b)]) {
                parent[findParent(a)] = 0;
                parent[findParent(b)] = 0;
            }
            parent[findParent(a)] = parent[findParent(b)];
        }
        // round 2
        for (let meeting of map.get(time)) {
            let [a, b] = meeting;
            if (!parent[findParent(a)] || !parent[findParent(b)]) {
                parent[findParent(a)] = 0;
                parent[findParent(b)] = 0;
            } else {
                parent[a] = a;
                parent[b] = b;
            }
        }
    }

    let ans = new Array&lt;number&gt;();
    for (let i = 0; i &lt;= n; i++) {
        if (!parent[findParent(i)]) {
            ans.push(i);
        }
    }
    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// 找出知晓秘密的所有专家
// 给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号
// 另外给你一个下标从 0 开始的二维整数数组 meetings
// 其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会
// 一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson
// 专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson
// 接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播
// 更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密
// 那么他将会与专家 yi 分享这个秘密，反之亦然。秘密共享是 瞬时发生 的
// 也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享
// 在所有会议都结束之后，返回所有知晓这个秘密的专家列表
// 你可以按 任何顺序 返回答案
// 链接测试 : https://leetcode.com/problems/find-all-people-with-secret/
public class Code02_FindAllPeopleWithSecret {

	public static int MAXN = 100001;

	public static int[] father = new int[MAXN];

	// 集合的标签信息 : 设置集合的一些属性
	// 属性在哪？secret[代表元素] 代表集合的属性
	public static boolean[] secret = new boolean[MAXN];

	public static void build(int n, int first) {
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
			secret[i] = false;
		}
		father[first] = 0;
		secret[0] = true;
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			secret[fy] |= secret[fx];
		}
	}

	// 会议排序 : m * log m
	// 处理过程 : O(m)
	// 收集答案 : O(n)
	public static List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int first) {
		build(n, first);
		// {0 : 专家   1 : 专家编号   2 : 时刻}
		Arrays.sort(meetings, (a, b) -&gt; a[2] - b[2]);
		int m = meetings.length;
		for (int l = 0, r; l &lt; m;) {
			r = l;
			while (r + 1 &lt; m &amp;&amp; meetings[l][2] == meetings[r + 1][2]) {
				r++;
			}
			// l....r这些会议，一定是一个时刻
			for (int i = l; i &lt;= r; i++) {
				union(meetings[i][0], meetings[i][1]);
			}
			// 有小的撤销行为，但这不是可撤销并查集
			// 只是每一批没有知道秘密的专家重新建立集合而已
			for (int i = l, a, b; i &lt;= r; i++) {
				a = meetings[i][0];
				b = meetings[i][1];
				if (!secret[find(a)]) {
					father[a] = a;
				}
				if (!secret[find(b)]) {
					father[b] = b;
				}
			}
			l = r + 1;
		}
		List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
		for (int i = 0; i &lt; n; i++) {
			if (secret[find(i)]) {
				ans.add(i);
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<h2 id="number-of-good-paths"><a class="header" href="#number-of-good-paths">Number of Good Paths</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/2400-2499/2421.Number%20of%20Good%20Paths/README_EN.md
rating: 2444
source: Weekly Contest 312 Q4
tags:
    - Tree
    - Union Find
    - Graph
    - Array
    - Hash Table
    - Sorting
</code></pre>
<!-- problem:start -->
<h1 id="2421-number-of-good-paths"><a class="header" href="#2421-number-of-good-paths"><a href="https://leetcode.com/problems/number-of-good-paths">2421. Number of Good Paths</a></a></h1>
<p><a href="data-structures//solution/2400-2499/2421.Number%20of%20Good%20Paths/README.html">中文文档</a></p>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<!-- description:start -->
<p>There is a tree (i.e. a connected, undirected graph with no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> edges.</p>
<p>You are given a <strong>0-indexed</strong> integer array <code>vals</code> of length <code>n</code> where <code>vals[i]</code> denotes the value of the <code>i<sup>th</sup></code> node. You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>
<p>A <strong>good path</strong> is a simple path that satisfies the following conditions:</p>
<ol>
	<li>The starting node and the ending node have the <strong>same</strong> value.</li>
	<li>All nodes between the starting node and the ending node have values <strong>less than or equal to</strong> the starting node (i.e. the starting node&#39;s value should be the maximum value along the path).</li>
</ol>
<p>Return <em>the number of distinct good paths</em>.</p>
<p>Note that a path and its reverse are counted as the <strong>same</strong> path. For example, <code>0 -&gt; 1</code> is considered to be the same as <code>1 -&gt; 0</code>. A single node is also considered as a valid path.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2421.Number%20of%20Good%20Paths/images/f9caaac15b383af9115c5586779dec5.png" style="width: 400px; height: 333px;" />
<pre>
<strong>Input:</strong> vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There is 1 additional good path: 1 -&gt; 0 -&gt; 2 -&gt; 4.
(The reverse path 4 -&gt; 2 -&gt; 0 -&gt; 1 is treated as the same as 1 -&gt; 0 -&gt; 2 -&gt; 4.)
Note that 0 -&gt; 2 -&gt; 3 is not a good path because vals[2] &gt; vals[0].
</pre>
<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2421.Number%20of%20Good%20Paths/images/149d3065ec165a71a1b9aec890776ff.png" style="width: 273px; height: 350px;" />
<pre>
<strong>Input:</strong> vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There are 2 additional good paths: 0 -&gt; 1 and 2 -&gt; 3.
</pre>
<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2421.Number%20of%20Good%20Paths/images/31705e22af3d9c0a557459bc7d1b62d.png" style="width: 100px; height: 88px;" />
<pre>
<strong>Input:</strong> vals = [1], edges = []
<strong>Output:</strong> 1
<strong>Explanation:</strong> The tree consists of only one node, so there is one good path.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == vals.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= vals[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-5"><a class="header" href="#solutions-5">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-sorting--union-find"><a class="header" href="#solution-1-sorting--union-find">Solution 1: Sorting + Union Find</a></h3>
<p>To ensure that the starting point (or endpoint) of the path is greater than or equal to all points on the path, we can consider sorting all points from small to large first, then traverse and add them to the connected component, specifically as follows:</p>
<p>When traversing to point $a$, for the adjacent point $b$ that is less than or equal to $vals[a]$, if they are not in the same connected component, they can be merged. And we can use all points in the connected component where point $a$ is located with a value of $vals[a]$ as the starting point, and all points in the connected component where point $b$ is located with a value of $vals[a]$ as the endpoint. The product of the number of the two types of points is the contribution to the answer when adding point $a$.</p>
<p>The time complexity is $O(n \times \log n)$.</p>
<!-- tabs:start -->
<h4 id="python3-8"><a class="header" href="#python3-8">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -&gt; int:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        g = defaultdict(list)
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)

        n = len(vals)
        p = list(range(n))
        size = defaultdict(Counter)
        for i, v in enumerate(vals):
            size[i][v] = 1

        ans = n
        for v, a in sorted(zip(vals, range(n))):
            for b in g[a]:
                if vals[b] &gt; v:
                    continue
                pa, pb = find(a), find(b)
                if pa != pb:
                    ans += size[pa][v] * size[pb][v]
                    p[pa] = pb
                    size[pb][v] += size[pa][v]
        return ans
</code></pre>
<h4 id="java-8"><a class="header" href="#java-8">Java</a></h4>
<pre><code class="language-java">class Solution {
    private int[] p;

    public int numberOfGoodPaths(int[] vals, int[][] edges) {
        int n = vals.length;
        p = new int[n];
        int[][] arr = new int[n][2];
        List&lt;Integer&gt;[] g = new List[n];
        Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;());
        for (int[] e : edges) {
            int a = e[0], b = e[1];
            g[a].add(b);
            g[b].add(a);
        }
        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; size = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            arr[i] = new int[] {vals[i], i};
            size.computeIfAbsent(i, k -&gt; new HashMap&lt;&gt;()).put(vals[i], 1);
        }
        Arrays.sort(arr, (a, b) -&gt; a[0] - b[0]);
        int ans = n;
        for (var e : arr) {
            int v = e[0], a = e[1];
            for (int b : g[a]) {
                if (vals[b] &gt; v) {
                    continue;
                }
                int pa = find(a), pb = find(b);
                if (pa != pb) {
                    ans += size.get(pa).getOrDefault(v, 0) * size.get(pb).getOrDefault(v, 0);
                    p[pa] = pb;
                    size.get(pb).put(
                        v, size.get(pb).getOrDefault(v, 0) + size.get(pa).getOrDefault(v, 0));
                }
            }
        }
        return ans;
    }

    private int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
}
</code></pre>
<h4 id="c-10"><a class="header" href="#c-10">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numberOfGoodPaths(vector&lt;int&gt;&amp; vals, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = vals.size();
        vector&lt;int&gt; p(n);
        iota(p.begin(), p.end(), 0);
        function&lt;int(int)&gt; find;
        find = [&amp;](int x) {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        };
        vector&lt;vector&lt;int&gt;&gt; g(n);
        for (auto&amp; e : edges) {
            int a = e[0], b = e[1];
            g[a].push_back(b);
            g[b].push_back(a);
        }
        unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; size;
        vector&lt;pair&lt;int, int&gt;&gt; arr(n);
        for (int i = 0; i &lt; n; ++i) {
            arr[i] = {vals[i], i};
            size[i][vals[i]] = 1;
        }
        sort(arr.begin(), arr.end());
        int ans = n;
        for (auto [v, a] : arr) {
            for (int b : g[a]) {
                if (vals[b] &gt; v) {
                    continue;
                }
                int pa = find(a), pb = find(b);
                if (pa != pb) {
                    ans += size[pa][v] * size[pb][v];
                    p[pa] = pb;
                    size[pb][v] += size[pa][v];
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-8"><a class="header" href="#go-8">Go</a></h4>
<pre><code class="language-go">func numberOfGoodPaths(vals []int, edges [][]int) int {
	n := len(vals)
	p := make([]int, n)
	size := map[int]map[int]int{}
	type pair struct{ v, i int }
	arr := make([]pair, n)
	for i, v := range vals {
		p[i] = i
		if size[i] == nil {
			size[i] = map[int]int{}
		}
		size[i][v] = 1
		arr[i] = pair{v, i}
	}

	var find func(x int) int
	find = func(x int) int {
		if p[x] != x {
			p[x] = find(p[x])
		}
		return p[x]
	}

	sort.Slice(arr, func(i, j int) bool { return arr[i].v &lt; arr[j].v })
	g := make([][]int, n)
	for _, e := range edges {
		a, b := e[0], e[1]
		g[a] = append(g[a], b)
		g[b] = append(g[b], a)
	}
	ans := n
	for _, e := range arr {
		v, a := e.v, e.i
		for _, b := range g[a] {
			if vals[b] &gt; v {
				continue
			}
			pa, pb := find(a), find(b)
			if pa != pb {
				ans += size[pb][v] * size[pa][v]
				p[pa] = pb
				size[pb][v] += size[pa][v]
			}
		}
	}
	return ans
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.Arrays;

// 好路径的数目
// 给你一棵 n 个节点的树（连通无向无环的图）
// 节点编号从0到n-1，且恰好有n-1条边
// 给你一个长度为 n 下标从 0 开始的整数数组 vals
// 分别表示每个节点的值。同时给你一个二维整数数组 edges
// 其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边
// 好路径需要满足以下条件：开始和结束节点的值相同、 路径中所有值都小于等于开始的值
// 请你返回不同好路径的数目
// 注意，一条路径和它反向的路径算作 同一 路径
// 比方说， 0 -&gt; 1 与 1 -&gt; 0 视为同一条路径。单个节点也视为一条合法路径
// 测试链接 : https://leetcode.com/problems/number-of-good-paths/
public class Code03_NumberOfGoodPaths {

	public static int MAXN = 30001;

	// 需要保证集合中，代表节点的值，一定是整个集合的最大值
	public static int[] father = new int[MAXN];

	// 集合中最大值的次数，也就是 集合中代表节点的值有几个
	public static int[] maxcnt = new int[MAXN];

	public static void build(int n) {
		for (int i = 0; i &lt; n; i++) {
			father[i] = i;
			maxcnt[i] = 1;
		}
	}

	// 这个并查集的优化只来自扁平化
	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	// 核心！
	// 注意以下的写法！
	// 谁的值大，谁做代表节点
	// 同时注意 maxcnt 的更新
	public static int union(int x, int y, int[] vals) {
		// fx : x所在集团的代表节点，同时也是x所在集团的最大值下标
		int fx = find(x);
		// fy : y所在集团的代表节点，同时也是y所在集团的最大值下标
		int fy = find(y);
		int path = 0;
		if (vals[fx] &gt; vals[fy]) {
			father[fy] = fx;
		} else if (vals[fx] &lt; vals[fy]) {
			father[fx] = fy;
		} else {
			// 两个集团最大值一样！
			path = maxcnt[fx] * maxcnt[fy];
			father[fy] = fx;
			maxcnt[fx] += maxcnt[fy];
		}
		return path;
	}

	public static int numberOfGoodPaths(int[] vals, int[][] edges) {
		int n = vals.length;
		build(n);
		int ans = n;
		// 课上重点讲这个核心排序！
		// 处理边的时候，依次从小节点往大节点处理
		Arrays.sort(edges, (e1, e2) -&gt; (Math.max(vals[e1[0]], vals[e1[1]]) - Math.max(vals[e2[0]], vals[e2[1]])));
		for (int[] edge : edges) {
			ans += union(edge[0], edge[1], vals);
		}
		return ans;
	}

	// 课上讲解的例子1和例子2
	public static void main(String[] args) {
		// 课上例子1
		//              0  1  2  3  4  5  6  7
		int[] vals1 = { 2, 1, 1, 2, 2, 1, 1, 2 };
		int[][] edges1 = { 
				{ 0, 1 },
				{ 0, 2 },
				{ 1, 3 },
				{ 2, 4 },
				{ 2, 5 },
				{ 5, 6 },
				{ 6, 7 } };
		System.out.println(numberOfGoodPaths(vals1, edges1));

		// 课上例子2
		//              0  1  2  3  4  5  6  7  8  9 10 11 12
		int[] vals2 = { 1, 2, 2, 3, 1, 2, 2, 1, 1, 3, 3, 3, 3 };
		int[][] edges2 = {
				{ 0, 1 },
				{ 0, 2 },
				{ 0, 3 },
				{ 1, 4 },
				{ 4, 7 },
				{ 4, 8 },
				{ 3, 5 },
				{ 3, 6 },
				{ 6, 9 },
				{ 6, 10 },
				{ 6, 11 },
				{ 9, 12 } };
		System.out.println(numberOfGoodPaths(vals2, edges2));
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<h2 id="minimize-malware-spread-ii"><a class="header" href="#minimize-malware-spread-ii">Minimize Malware Spread II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0928.Minimize%20Malware%20Spread%20II/README_EN.md
tags:
    - Depth-First Search
    - Breadth-First Search
    - Union Find
    - Graph
    - Array
    - Hash Table
</code></pre>
<!-- problem:start -->
<h1 id="928-minimize-malware-spread-ii"><a class="header" href="#928-minimize-malware-spread-ii"><a href="https://leetcode.com/problems/minimize-malware-spread-ii">928. Minimize Malware Spread II</a></a></h1>
<p><a href="data-structures//solution/0900-0999/0928.Minimize%20Malware%20Spread%20II/README.html">中文文档</a></p>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<!-- description:start -->
<p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>
<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>
<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>
<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>
<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-6"><a class="header" href="#solutions-6">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-union-find-2"><a class="header" href="#solution-1-union-find-2">Solution 1: Union-Find</a></h3>
<p>We can use the union-find data structure to merge all nodes that are not in $initial$ and satisfy $graph[i][j] = 1$.</p>
<p>Next, we create a hash table $g$, where $g[i]$ represents the root node of the connected component that is connected to node $i$. We also need a counter $cnt$ to count how many initial nodes each root node is infected by.</p>
<p>For each initially infected node $i$, we traverse all nodes $j$ connected to node $i$. If node $j$ is not in $initial$, we add the root node of node $j$ to the set $g[i]$. At the same time, we count how many initial nodes each root node is infected by and save the result in the counter $cnt$.</p>
<p>Then, we use a variable $ans$ to record the answer, and $mx$ to record the maximum number of infected nodes that can be reduced. Initially, $ans = 0$, $mx = -1$.</p>
<p>We traverse all initially infected nodes. For each node $i$, we traverse all root nodes in $g[i]$. If a root node is only infected by one initial node, we add the size of the connected component where the root node is located to $t$. If $t &gt; mx$ or $t = mx$ and $i &lt; ans$, we update $ans = i$, $mx = t$.</p>
<p>Finally, we return $ans$.</p>
<p>The time complexity is $O(n^2 \times \alpha(n))$, and the space complexity is $O(n^2)$. Where $n$ is the number of nodes, and $\alpha(n)$ is the inverse Ackermann function.</p>
<!-- tabs:start -->
<h4 id="python3-9"><a class="header" href="#python3-9">Python3</a></h4>
<pre><code class="language-python">class UnionFind:
    __slots__ = "p", "size"

    def __init__(self, n: int):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -&gt; int:
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a: int, b: int) -&gt; bool:
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.size[pa] &gt; self.size[pb]:
            self.p[pb] = pa
            self.size[pa] += self.size[pb]
        else:
            self.p[pa] = pb
            self.size[pb] += self.size[pa]
        return True

    def get_size(self, root: int) -&gt; int:
        return self.size[root]


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int:
        n = len(graph)
        s = set(initial)
        uf = UnionFind(n)
        for i in range(n):
            if i not in s:
                for j in range(i + 1, n):
                    graph[i][j] and j not in s and uf.union(i, j)

        g = defaultdict(set)
        cnt = Counter()
        for i in initial:
            for j in range(n):
                if j not in s and graph[i][j]:
                    g[i].add(uf.find(j))
            for root in g[i]:
                cnt[root] += 1

        ans, mx = 0, -1
        for i in initial:
            t = sum(uf.get_size(root) for root in g[i] if cnt[root] == 1)
            if t &gt; mx or (t == mx and i &lt; ans):
                ans, mx = i, t
        return ans
</code></pre>
<h4 id="java-9"><a class="header" href="#java-9">Java</a></h4>
<pre><code class="language-java">class UnionFind {
    private final int[] p;
    private final int[] size;

    public UnionFind(int n) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            p[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public boolean union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    public int size(int root) {
        return size[root];
    }
}

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] s = new boolean[n];
        for (int i : initial) {
            s[i] = true;
        }
        UnionFind uf = new UnionFind(n);
        for (int i = 0; i &lt; n; ++i) {
            if (!s[i]) {
                for (int j = i + 1; j &lt; n; ++j) {
                    if (graph[i][j] == 1 &amp;&amp; !s[j]) {
                        uf.union(i, j);
                    }
                }
            }
        }
        Set&lt;Integer&gt;[] g = new Set[n];
        Arrays.setAll(g, k -&gt; new HashSet&lt;&gt;());
        int[] cnt = new int[n];
        for (int i : initial) {
            for (int j = 0; j &lt; n; ++j) {
                if (!s[j] &amp;&amp; graph[i][j] == 1) {
                    g[i].add(uf.find(j));
                }
            }
            for (int root : g[i]) {
                ++cnt[root];
            }
        }
        int ans = 0, mx = -1;
        for (int i : initial) {
            int t = 0;
            for (int root : g[i]) {
                if (cnt[root] == 1) {
                    t += uf.size(root);
                }
            }
            if (t &gt; mx || (t == mx &amp;&amp; i &lt; ans)) {
                ans = i;
                mx = t;
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-11"><a class="header" href="#c-11">C++</a></h4>
<pre><code class="language-cpp">class UnionFind {
public:
    UnionFind(int n) {
        p = vector&lt;int&gt;(n);
        size = vector&lt;int&gt;(n, 1);
        iota(p.begin(), p.end(), 0);
    }

    bool unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa == pb) {
            return false;
        }
        if (size[pa] &gt; size[pb]) {
            p[pb] = pa;
            size[pa] += size[pb];
        } else {
            p[pa] = pb;
            size[pb] += size[pa];
        }
        return true;
    }

    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    int getSize(int root) {
        return size[root];
    }

private:
    vector&lt;int&gt; p, size;
};

class Solution {
public:
    int minMalwareSpread(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; initial) {
        int n = graph.size();
        bool s[n];
        memset(s, false, sizeof(s));
        for (int i : initial) {
            s[i] = true;
        }
        UnionFind uf(n);
        for (int i = 0; i &lt; n; ++i) {
            if (!s[i]) {
                for (int j = i + 1; j &lt; n; ++j) {
                    if (graph[i][j] &amp;&amp; !s[j]) {
                        uf.unite(i, j);
                    }
                }
            }
        }
        unordered_set&lt;int&gt; g[n];
        int cnt[n];
        memset(cnt, 0, sizeof(cnt));
        for (int i : initial) {
            for (int j = 0; j &lt; n; ++j) {
                if (!s[j] &amp;&amp; graph[i][j]) {
                    g[i].insert(uf.find(j));
                }
            }
            for (int root : g[i]) {
                ++cnt[root];
            }
        }
        int ans = 0, mx = -1;
        for (int i : initial) {
            int t = 0;
            for (int root : g[i]) {
                if (cnt[root] == 1) {
                    t += uf.getSize(root);
                }
            }
            if (t &gt; mx || (t == mx &amp;&amp; i &lt; ans)) {
                ans = i;
                mx = t;
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-9"><a class="header" href="#go-9">Go</a></h4>
<pre><code class="language-go">type unionFind struct {
	p, size []int
}

func newUnionFind(n int) *unionFind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &amp;unionFind{p, size}
}

func (uf *unionFind) find(x int) int {
	if uf.p[x] != x {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionFind) union(a, b int) bool {
	pa, pb := uf.find(a), uf.find(b)
	if pa == pb {
		return false
	}
	if uf.size[pa] &gt; uf.size[pb] {
		uf.p[pb] = pa
		uf.size[pa] += uf.size[pb]
	} else {
		uf.p[pa] = pb
		uf.size[pb] += uf.size[pa]
	}
	return true
}

func (uf *unionFind) getSize(root int) int {
	return uf.size[root]
}

func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	s := make([]bool, n)
	for _, i := range initial {
		s[i] = true
	}
	uf := newUnionFind(n)
	for i := range graph {
		if !s[i] {
			for j := i + 1; j &lt; n; j++ {
				if graph[i][j] == 1 &amp;&amp; !s[j] {
					uf.union(i, j)
				}
			}
		}
	}
	g := make([]map[int]bool, n)
	for _, i := range initial {
		g[i] = map[int]bool{}
	}
	cnt := make([]int, n)
	for _, i := range initial {
		for j := 0; j &lt; n; j++ {
			if !s[j] &amp;&amp; graph[i][j] == 1 {
				g[i][uf.find(j)] = true
			}
		}
		for root := range g[i] {
			cnt[root]++
		}
	}
	ans, mx := 0, -1
	for _, i := range initial {
		t := 0
		for root := range g[i] {
			if cnt[root] == 1 {
				t += uf.getSize(root)
			}
		}
		if t &gt; mx || t == mx &amp;&amp; i &lt; ans {
			ans, mx = i, t
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-9"><a class="header" href="#typescript-9">TypeScript</a></h4>
<pre><code class="language-ts">class UnionFind {
    p: number[];
    size: number[];
    constructor(n: number) {
        this.p = Array(n)
            .fill(0)
            .map((_, i) =&gt; i);
        this.size = Array(n).fill(1);
    }

    find(x: number): number {
        if (this.p[x] !== x) {
            this.p[x] = this.find(this.p[x]);
        }
        return this.p[x];
    }

    union(a: number, b: number): boolean {
        const [pa, pb] = [this.find(a), this.find(b)];
        if (pa === pb) {
            return false;
        }
        if (this.size[pa] &gt; this.size[pb]) {
            this.p[pb] = pa;
            this.size[pa] += this.size[pb];
        } else {
            this.p[pa] = pb;
            this.size[pb] += this.size[pa];
        }
        return true;
    }

    getSize(root: number): number {
        return this.size[root];
    }
}

function minMalwareSpread(graph: number[][], initial: number[]): number {
    const n = graph.length;
    const s = new Set(initial);
    const uf = new UnionFind(n);
    for (let i = 0; i &lt; n; ++i) {
        if (!s.has(i)) {
            for (let j = i + 1; j &lt; n; ++j) {
                if (graph[i][j] &amp;&amp; !s.has(j)) {
                    uf.union(i, j);
                }
            }
        }
    }
    const g: Set&lt;number&gt;[] = Array.from({ length: n }, () =&gt; new Set());
    const cnt: number[] = Array(n).fill(0);
    for (const i of initial) {
        for (let j = 0; j &lt; n; ++j) {
            if (graph[i][j] &amp;&amp; !s.has(j)) {
                g[i].add(uf.find(j));
            }
        }
        for (const root of g[i]) {
            ++cnt[root];
        }
    }
    let ans = 0;
    let mx = -1;
    for (const i of initial) {
        let t = 0;
        for (const root of g[i]) {
            if (cnt[root] === 1) {
                t += uf.getSize(root);
            }
        }
        if (t &gt; mx || (t === mx &amp;&amp; i &lt; ans)) {
            [ans, mx] = [i, t];
        }
    }
    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class057;

import java.util.Arrays;

// 尽量减少恶意软件的传播 II
// 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示
// 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
// 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
// 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
// 我们可以从 initial 中删除一个节点，
// 并完全移除该节点以及从该节点到任何其他节点的任何连接。
// 请返回移除后能够使 M(initial) 最小化的节点。
// 如果有多个节点满足条件，返回索引 最小的节点 。
// initial 中每个整数都不同
// 测试链接 : https://leetcode.com/problems/minimize-malware-spread-ii/
public class Code04_MinimizeMalwareSpreadII {

	// 如果测试数据变大，就改变这个值
	public static int MAXN = 301;

	// [3,6,103]
	// virus[3] = true;
	// virus[103] = true;
	// 方便查询
	public static boolean[] virus = new boolean[MAXN];

	// 每个源头点删掉的话，能拯救多少点的数据
	public static int[] cnts = new int[MAXN];

	// 集合的标签 : 集合的感染点是什么点
	// a : 代表点，整个集合源头是 infect[a]
	// infect[a] == -1，目前这个集合没有发现源头
	// infect[a] &gt;= 0，目前这个集合源头是 infect[a]
	// infect[a] == -2，目前这个集合源头不止一个，已经无法拯救了!
	public static int[] infect = new int[MAXN];

	// 并查集固有信息
	public static int[] father = new int[MAXN];

	// 集合的标签 : 集合的大小是多少
	public static int[] size = new int[MAXN];

	// 集合一定只放普通点，源头点根本不参与集合，也不是元素！

	public static void build(int n, int[] initial) {
		for (int i = 0; i &lt; n; i++) {
			virus[i] = false;
			cnts[i] = 0;
			infect[i] = -1;
			size[i] = 1;
			father[i] = i;
		}
		for (int i : initial) {
			virus[i] = true;
		}
	}

	public static int find(int i) {
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			father[fx] = fy;
			size[fy] += size[fx];
		}
	}

	public static int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;
		build(n, initial);
		// 不是病毒的点，普通点合并！
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				if (graph[i][j] == 1 &amp;&amp; !virus[i] &amp;&amp; !virus[j]) {
					union(i, j);
				}
			}
		}
		// 病毒周围的普通点(集合 )去设置源头！
		for (int sick : initial) {
			for (int neighbor = 0; neighbor &lt; n; neighbor++) {
				if (sick != neighbor &amp;&amp; !virus[neighbor] &amp;&amp; graph[sick][neighbor] == 1) {
					int fn = find(neighbor);
					if (infect[fn] == -1) {
						infect[fn] = sick;
					} else if (infect[fn] != -2 &amp;&amp; infect[fn] != sick) {
						infect[fn] = -2;
					}
				}
			}
		}
		// 统计拯救数据
		for (int i = 0; i &lt; n; i++) {
			// 不是代表点，不看
			if (i == find(i) &amp;&amp; infect[i] &gt;= 0) {
				cnts[infect[i]] += size[i];
			}
		}
		Arrays.sort(initial);
		int ans = initial[0];
		int max = cnts[ans];
		for (int i : initial) {
			if (cnts[i] &gt; max) {
				ans = i;
				max = cnts[i];
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/udLkbanV8sg?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trie-prefix-tree"><a class="header" href="#trie-prefix-tree">Trie (Prefix Tree)</a></h1>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="dynamic-implementation"><a class="header" href="#dynamic-implementation">Dynamic Implementation</a></h3>
<details><summary>Java Code</summary>
<pre><code class="language-java">package class044;

import java.util.HashMap;

// 用类描述实现前缀树。不推荐！
// 测试链接 : https://leetcode.com/problems/implement-trie-ii-prefix-tree/
public class Code01_TrieTree {

	// 路是数组实现的
	// 提交时把类名、构造方法改为Trie
	class Trie1 {

		class TrieNode {
			public int pass;
			public int end;
			public TrieNode[] nexts;

			public TrieNode() {
				pass = 0;
				end = 0;
				nexts = new TrieNode[26];
			}
		}

		private TrieNode root;

		public Trie1() {
			root = new TrieNode();
		}

		public void insert(String word) {
			TrieNode node = root;
			node.pass++;
			for (int i = 0, path; i &lt; word.length(); i++) { // 从左往右遍历字符
				path = word.charAt(i) - 'a'; // 由字符，对应成走向哪条路
				if (node.nexts[path] == null) {
					node.nexts[path] = new TrieNode();
				}
				node = node.nexts[path];
				node.pass++;
			}
			node.end++;
		}

		// 如果之前word插入过前缀树，那么此时删掉一次
		// 如果之前word没有插入过前缀树，那么什么也不做
		public void erase(String word) {
			if (countWordsEqualTo(word) &gt; 0) {
				TrieNode node = root;
				node.pass--;
				for (int i = 0, path; i &lt; word.length(); i++) {
					path = word.charAt(i) - 'a';
					if (--node.nexts[path].pass == 0) {
						node.nexts[path] = null;
						return;
					}
					node = node.nexts[path];
				}
				node.end--;
			}
		}

		// 查询前缀树里，word单词出现了几次
		public int countWordsEqualTo(String word) {
			TrieNode node = root;
			for (int i = 0, path; i &lt; word.length(); i++) {
				path = word.charAt(i) - 'a';
				if (node.nexts[path] == null) {
					return 0;
				}
				node = node.nexts[path];
			}
			return node.end;
		}

		// 查询前缀树里，有多少单词以pre做前缀
		public int countWordsStartingWith(String pre) {
			TrieNode node = root;
			for (int i = 0, path; i &lt; pre.length(); i++) {
				path = pre.charAt(i) - 'a';
				if (node.nexts[path] == null) {
					return 0;
				}
				node = node.nexts[path];
			}
			return node.pass;
		}

	}

	// 路是哈希表实现的
	// 提交时把类名、构造方法改为Trie
	class Trie2 {

		class TrieNode {
			public int pass;
			public int end;
			HashMap&lt;Integer, TrieNode&gt; nexts;

			public TrieNode() {
				pass = 0;
				end = 0;
				nexts = new HashMap&lt;&gt;();
			}
		}

		private TrieNode root;

		public Trie2() {
			root = new TrieNode();
		}

		public void insert(String word) {
			TrieNode node = root;
			node.pass++;
			for (int i = 0, path; i &lt; word.length(); i++) { // 从左往右遍历字符
				path = word.charAt(i);
				if (!node.nexts.containsKey(path)) {
					node.nexts.put(path, new TrieNode());
				}
				node = node.nexts.get(path);
				node.pass++;
			}
			node.end++;
		}

		public void erase(String word) {
			if (countWordsEqualTo(word) &gt; 0) {
				TrieNode node = root;
				TrieNode next;
				node.pass--;
				for (int i = 0, path; i &lt; word.length(); i++) {
					path = word.charAt(i);
					next = node.nexts.get(path);
					if (--next.pass == 0) {
						node.nexts.remove(path);
						return;
					}
					node = next;
				}
				node.end--;
			}
		}

		public int countWordsEqualTo(String word) {
			TrieNode node = root;
			for (int i = 0, path; i &lt; word.length(); i++) {
				path = word.charAt(i);
				if (!node.nexts.containsKey(path)) {
					return 0;
				}
				node = node.nexts.get(path);
			}
			return node.end;
		}

		public int countWordsStartingWith(String pre) {
			TrieNode node = root;
			for (int i = 0, path; i &lt; pre.length(); i++) {
				path = pre.charAt(i);
				if (!node.nexts.containsKey(path)) {
					return 0;
				}
				node = node.nexts.get(path);
			}
			return node.pass;
		}

	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/I3GZIJzg4y4?start=0">
    </iframe>
</details>
<h3 id="static-implementation"><a class="header" href="#static-implementation">Static Implementation</a></h3>
<details><summary>Java Code</summary>
<pre><code class="language-java">package class044;

// 用固定数组实现前缀树，空间使用是静态的。推荐！
// 测试链接 : https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;

public class Code02_TrieTree {

	// 如果将来增加了数据量，就改大这个值
	public static int MAXN = 150001;

	public static int[][] tree = new int[MAXN][26];

	public static int[] end = new int[MAXN];

	public static int[] pass = new int[MAXN];

	public static int cnt;

	public static void build() {
		cnt = 1;
	}

	public static void insert(String word) {
		int cur = 1;
		pass[cur]++;
		for (int i = 0, path; i &lt; word.length(); i++) {
			path = word.charAt(i) - 'a';
			if (tree[cur][path] == 0) {
				tree[cur][path] = ++cnt;
			}
			cur = tree[cur][path];
			pass[cur]++;
		}
		end[cur]++;
	}

	public static int search(String word) {
		int cur = 1;
		for (int i = 0, path; i &lt; word.length(); i++) {
			path = word.charAt(i) - 'a';
			if (tree[cur][path] == 0) {
				return 0;
			}
			cur = tree[cur][path];
		}
		return end[cur];
	}

	public static int prefixNumber(String pre) {
		int cur = 1;
		for (int i = 0, path; i &lt; pre.length(); i++) {
			path = pre.charAt(i) - 'a';
			if (tree[cur][path] == 0) {
				return 0;
			}
			cur = tree[cur][path];
		}
		return pass[cur];
	}

	public static void delete(String word) {
		if (search(word) &gt; 0) {
			int cur = 1;
			for (int i = 0, path; i &lt; word.length(); i++) {
				path = word.charAt(i) - 'a';
				if (--pass[tree[cur][path]] == 0) {
					tree[cur][path] = 0;
					return;
				}
				cur = tree[cur][path];
			}
			end[cur]--;
		}
	}

	public static void clear() {
		for (int i = 1; i &lt;= cnt; i++) {
			Arrays.fill(tree[i], 0);
			end[i] = 0;
			pass[i] = 0;
		}
	}

	public static int m, op;

	public static String[] splits;

	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		String line = null;
		while ((line = in.readLine()) != null) {
			build();
			m = Integer.valueOf(line);
			for (int i = 1; i &lt;= m; i++) {
				splits = in.readLine().split(" ");
				op = Integer.valueOf(splits[0]);
				if (op == 1) {
					insert(splits[1]);
				} else if (op == 2) {
					delete(splits[1]);
				} else if (op == 3) {
					out.println(search(splits[1]) &gt; 0 ? "YES" : "NO");
				} else if (op == 4) {
					out.println(prefixNumber(splits[1]));
				}
			}
			clear();
		}
		out.flush();
		in.close();
		out.close();
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/I3GZIJzg4y4?start=2714">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-number-and-bitwise-operations"><a class="header" href="#binary-number-and-bitwise-operations">Binary Number and Bitwise Operations</a></h1>
<h2 id="2s-complement"><a class="header" href="#2s-complement">2's complement</a></h2>
<p>For a negative number</p>
<ul>
<li>leading bit is <code>1</code></li>
<li>absolute value is <code>~n + 1</code></li>
</ul>
<p>For any number n, <code>-n == (~n + 1)</code></p>
<h2 id="signed-integer-overflow-and-underflow"><a class="header" href="#signed-integer-overflow-and-underflow">Signed Integer Overflow and Underflow</a></h2>
<p>The following are <code>true</code>:</p>
<ul>
<li><code>Integer.MAX_VALUE + 1 == Integer.MIN_VALUE</code></li>
<li><code>Integer.MIN_VALUE - 1 == Integer.MAX_VALUE</code></li>
<li><code>-Integer.MIN_VALUE == Intger.MIN_VALUE</code></li>
</ul>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<ul>
<li><code>&amp;</code></li>
<li><code>|</code></li>
<li><code>^</code></li>
<li><code>~</code></li>
<li><code>&lt;&lt;</code></li>
<li><code>&gt;&gt;</code></li>
<li><code>&gt;&gt;&gt;</code></li>
</ul>
<h2 id="common-bitwise-operations"><a class="header" href="#common-bitwise-operations">Common Bitwise Operations</a></h2>
<ul>
<li>set the i-th bit of a number <code>n |= (1 &lt;&lt; i)</code></li>
<li>unset the i-th bit of a number <code>n &amp;= ~(1 &lt;&lt; i)</code></li>
<li>clear the rightmost set bit <code>n &amp;= (n - 1)</code></li>
<li>extract the rightmost set bit <code>a = n &amp; -n</code></li>
<li>encryption/decryption with XOR <code>m ^ k = c; c ^ k</code></li>
<li>swapping two integers <code>a = a ^ b; b = a ^ b; a = a ^ b;</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xor-operation-problems"><a class="header" href="#xor-operation-problems">XOR Operation Problems</a></h1>
<h2 id="swap-exclusive-or"><a class="header" href="#swap-exclusive-or">Swap Exclusive Or</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class030;

// 用异或运算交换两数的值
public class Code01_SwapExclusiveOr {

	public static void main(String[] args) {
		int a = -2323;
		int b = 10;
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;
		System.out.println(a);
		System.out.println(b);

		int[] arr = { 3, 5 };
		swap(arr, 0, 1);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		swap(arr, 0, 0);
		System.out.println(arr[0]);
	}

	// 当i!=j，没问题，会完成交换功能
	// 当i==j，会出错
	// 所以知道这种写法即可，并不推荐
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 用异或运算交换两数的值
public class Code01_SwapExclusiveOr {

	public static void main(String[] args) {
		int a = -2323;
		int b = 10;
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;
		System.out.println(a);
		System.out.println(b);

		int[] arr = { 3, 5 };
		swap(arr, 0, 1);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		swap(arr, 0, 0);
		System.out.println(arr[0]);
	}

	// 当i!=j，没问题，会完成交换功能
	// 当i==j，会出错
	// 所以知道这种写法即可，并不推荐
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="get-max-without-logic-operators"><a class="header" href="#get-max-without-logic-operators">Get Max Without Logic Operators</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class030;

// 不用任何判断语句和比较操作，返回两个数的最大值
// 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76
public class Code02_GetMaxWithoutJudge {

	// 必须保证n一定是0或者1
	// 0变1，1变0
	public static int flip(int n) {
		return n ^ 1;
	}

	// 非负数返回1
	// 负数返回0
	public static int sign(int n) {
		return flip(n &gt;&gt;&gt; 31);
	}

	// 有溢出风险的实现
	public static int getMax1(int a, int b) {
		int c = a - b;
		// c非负，returnA -&gt; 1
		// c非负，returnB -&gt; 0
		// c负数，returnA -&gt; 0
		// c负数，returnB -&gt; 1
		int returnA = sign(c);
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	// 没有任何问题的实现
	public static int getMax2(int a, int b) {
		// c可能是溢出的
		int c = a - b;
		// a的符号
		int sa = sign(a);
		// b的符号
		int sb = sign(b);
		// c的符号
		int sc = sign(c);
		// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0
		int diffAB = sa ^ sb;
		// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0
		int sameAB = flip(diffAB);
		int returnA = diffAB * sa + sameAB * sc;
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	public static void main(String[] args) {
		int a = Integer.MIN_VALUE;
		int b = Integer.MAX_VALUE;
		// getMax1方法会错误，因为溢出
		System.out.println(getMax1(a, b));
		// getMax2方法永远正确
		System.out.println(getMax2(a, b));
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 不用任何判断语句和比较操作，返回两个数的最大值
// 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76
public class Code02_GetMaxWithoutJudge {

	// 必须保证n一定是0或者1
	// 0变1，1变0
	public static int flip(int n) {
		return n ^ 1;
	}

	// 非负数返回1
	// 负数返回0
	public static int sign(int n) {
		return flip(n &gt;&gt;&gt; 31);
	}

	// 有溢出风险的实现
	public static int getMax1(int a, int b) {
		int c = a - b;
		// c非负，returnA -&gt; 1
		// c非负，returnB -&gt; 0
		// c负数，returnA -&gt; 0
		// c负数，returnB -&gt; 1
		int returnA = sign(c);
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	// 没有任何问题的实现
	public static int getMax2(int a, int b) {
		// c可能是溢出的
		int c = a - b;
		// a的符号
		int sa = sign(a);
		// b的符号
		int sb = sign(b);
		// c的符号
		int sc = sign(c);
		// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0
		int diffAB = sa ^ sb;
		// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0
		int sameAB = flip(diffAB);
		int returnA = diffAB * sa + sameAB * sc;
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	public static void main(String[] args) {
		int a = Integer.MIN_VALUE;
		int b = Integer.MAX_VALUE;
		// getMax1方法会错误，因为溢出
		System.out.println(getMax1(a, b));
		// getMax2方法永远正确
		System.out.println(getMax2(a, b));
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="missing-number"><a class="header" href="#missing-number">Missing Number</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Easy
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0268.Missing%20Number/README_EN.md
tags:
    - Bit Manipulation
    - Array
    - Hash Table
    - Math
    - Binary Search
    - Sorting
</code></pre>
<!-- problem:start -->
<h1 id="268-missing-number"><a class="header" href="#268-missing-number"><a href="https://leetcode.com/problems/missing-number">268. Missing Number</a></a></h1>
<p><a href="binary-number//solution/0200-0299/0268.Missing%20Number/README.html">中文文档</a></p>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<!-- description:start -->
<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [3,0,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]
<strong>Output:</strong> 8
<strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= n</code></li>
	<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p>
<!-- description:end -->
<h2 id="solutions-7"><a class="header" href="#solutions-7">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-bitwise-operation"><a class="header" href="#solution-1-bitwise-operation">Solution 1: Bitwise Operation</a></h3>
<p>The XOR operation has the following properties:</p>
<ul>
<li>Any number XOR 0 is still the original number, i.e., $x \oplus 0 = x$;</li>
<li>Any number XOR itself is 0, i.e., $x \oplus x = 0$;</li>
</ul>
<p>Therefore, we can traverse the array, perform XOR operation between each element and the numbers $[0,..n]$, and the final result will be the missing number.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-10"><a class="header" href="#python3-10">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        return reduce(xor, (i ^ v for i, v in enumerate(nums, 1)))
</code></pre>
<h4 id="java-10"><a class="header" href="#java-10">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans ^= (i ^ nums[i]);
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-12"><a class="header" href="#c-12">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans ^= (i ^ nums[i]);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-10"><a class="header" href="#go-10">Go</a></h4>
<pre><code class="language-go">func missingNumber(nums []int) (ans int) {
	n := len(nums)
	ans = n
	for i, v := range nums {
		ans ^= (i ^ v)
	}
	return
}
</code></pre>
<h4 id="typescript-10"><a class="header" href="#typescript-10">TypeScript</a></h4>
<pre><code class="language-ts">function missingNumber(nums: number[]): number {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans ^= i ^ nums[i];
    }
    return ans;
}
</code></pre>
<h4 id="rust-3"><a class="header" href="#rust-3">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn missing_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len() as i32;
        let mut ans = n;
        for (i, v) in nums.iter().enumerate() {
            ans ^= (i as i32) ^ v;
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans ^= i ^ nums[i];
    }
    return ans;
};
</code></pre>
<h4 id="php"><a class="header" href="#php">PHP</a></h4>
<pre><code class="language-php">class Solution {
    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function missingNumber($nums) {
        $n = count($nums);
        $sumN = (($n + 1) * $n) / 2;
        for ($i = 0; $i &lt; $n; $i++) {
            $sumN -= $nums[$i];
        }
        return $sumN;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-mathematics"><a class="header" href="#solution-2-mathematics">Solution 2: Mathematics</a></h3>
<p>We can also solve this problem using mathematics. By calculating the sum of $[0,..n]$, subtracting the sum of all numbers in the array, we can obtain the missing number.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-11"><a class="header" href="#python3-11">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        n = len(nums)
        return (1 + n) * n // 2 - sum(nums)
</code></pre>
<h4 id="java-11"><a class="header" href="#java-11">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans += i - nums[i];
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-13"><a class="header" href="#c-13">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        return (1 + n) * n / 2 - accumulate(nums.begin(), nums.end(), 0);
    }
};
</code></pre>
<h4 id="go-11"><a class="header" href="#go-11">Go</a></h4>
<pre><code class="language-go">func missingNumber(nums []int) (ans int) {
	n := len(nums)
	ans = n
	for i, v := range nums {
		ans += i - v
	}
	return
}
</code></pre>
<h4 id="typescript-11"><a class="header" href="#typescript-11">TypeScript</a></h4>
<pre><code class="language-ts">function missingNumber(nums: number[]): number {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans += i - nums[i];
    }
    return ans;
}
</code></pre>
<h4 id="rust-4"><a class="header" href="#rust-4">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn missing_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len() as i32;
        let mut ans = n;
        for (i, &amp;v) in nums.iter().enumerate() {
            ans += (i as i32) - v;
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-2"><a class="header" href="#javascript-2">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans += i - nums[i];
    }
    return ans;
};
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 找到缺失的数字
// 测试链接 : https://leetcode.com/problems/missing-number/
public class Code03_MissingNumber {

	public static int missingNumber(int[] nums) {
		int eorAll = 0, eorHas = 0;
		for (int i = 0; i &lt; nums.length; i++) {
			eorAll ^= i;
			eorHas ^= nums[i];
		}
		eorAll ^= nums.length;
		return eorAll ^ eorHas;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="biggest-single-number"><a class="header" href="#biggest-single-number">Biggest Single Number</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Easy
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0619.Biggest%20Single%20Number/README_EN.md
tags:
    - Database
</code></pre>
<!-- problem:start -->
<h1 id="619-biggest-single-number"><a class="header" href="#619-biggest-single-number"><a href="https://leetcode.com/problems/biggest-single-number">619. Biggest Single Number</a></a></h1>
<p><a href="binary-number//solution/0600-0699/0619.Biggest%20Single%20Number/README.html">中文文档</a></p>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<!-- description:start -->
<p>Table: <code>MyNumbers</code></p>
<pre>
+-------------+------+
| Column Name | Type |
+-------------+------+
| num         | int  |
+-------------+------+
This table may contain duplicates (In other words, there is no primary key for this table in SQL).
Each row of this table contains an integer.
</pre>
<p>&nbsp;</p>
<p>A <strong>single number</strong> is a number that appeared only once in the <code>MyNumbers</code> table.</p>
<p>Find the largest <strong>single number</strong>. If there is no <strong>single number</strong>, report <code>null</code>.</p>
<p>The result format is in the following example.</p>
<ptable> </ptable>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> 
MyNumbers table:
+-----+
| num |
+-----+
| 8   |
| 8   |
| 3   |
| 3   |
| 1   |
| 4   |
| 5   |
| 6   |
+-----+
<strong>Output:</strong> 
+-----+
| num |
+-----+
| 6   |
+-----+
<strong>Explanation:</strong> The single numbers are 1, 4, 5, and 6.
Since 6 is the largest single number, we return it.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> 
MyNumbers table:
+-----+
| num |
+-----+
| 8   |
| 8   |
| 7   |
| 7   |
| 3   |
| 3   |
| 3   |
+-----+
<strong>Output:</strong> 
+------+
| num  |
+------+
| null |
+------+
<strong>Explanation:</strong> There are no single numbers in the input table so we return null.
</pre>
<!-- description:end -->
<h2 id="solutions-8"><a class="header" href="#solutions-8">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-grouping-and-subquery"><a class="header" href="#solution-1-grouping-and-subquery">Solution 1: Grouping and Subquery</a></h3>
<p>We can first group the <code>MyNumbers</code> table by <code>num</code> and count the number of occurrences of each number. Then, we can use a subquery to find the maximum number among the numbers that appear only once.</p>
<!-- tabs:start -->
<h4 id="mysql"><a class="header" href="#mysql">MySQL</a></h4>
<pre><code class="language-sql"># Write your MySQL query statement below
SELECT MAX(num) AS num
FROM
    (
        SELECT num
        FROM MyNumbers
        GROUP BY 1
        HAVING COUNT(1) = 1
    ) AS t;
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-grouping-and-case-expression"><a class="header" href="#solution-2-grouping-and-case-expression">Solution 2: Grouping and <code>CASE</code> Expression</a></h3>
<p>Similar to Solution 1, we can first group the <code>MyNumbers</code> table by <code>num</code> and count the number of occurrences of each number. Then, we can use a <code>CASE</code> expression to find the numbers that appear only once, sort them in descending order by number, and take the first one.</p>
<!-- tabs:start -->
<h4 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h4>
<pre><code class="language-sql"># Write your MySQL query statement below
SELECT
    CASE
        WHEN COUNT(1) = 1 THEN num
        ELSE NULL
    END AS num
FROM MyNumbers
GROUP BY num
ORDER BY 1 DESC
LIMIT 1;
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 数组中1种数出现了奇数次，其他的数都出现了偶数次
// 返回出现了奇数次的数
// 测试链接 : https://leetcode.com/problems/single-number/
public class Code04_SingleNumber {

	public static int singleNumber(int[] nums) {
		int eor = 0;
		for (int num : nums) {
			eor ^= num;
		}
		return eor;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="single-number-iii"><a class="header" href="#single-number-iii">Single Number III</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0260.Single%20Number%20III/README_EN.md
tags:
    - Bit Manipulation
    - Array
</code></pre>
<!-- problem:start -->
<h1 id="260-single-number-iii"><a class="header" href="#260-single-number-iii"><a href="https://leetcode.com/problems/single-number-iii">260. Single Number III</a></a></h1>
<p><a href="binary-number//solution/0200-0299/0260.Single%20Number%20III/README.html">中文文档</a></p>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>
<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,1,3,2,5]
<strong>Output:</strong> [3,5]
<strong>Explanation: </strong> [5, 3] is also a valid answer.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [-1,0]
<strong>Output:</strong> [-1,0]
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [1,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-9"><a class="header" href="#solutions-9">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-bitwise-operation-1"><a class="header" href="#solution-1-bitwise-operation-1">Solution 1: Bitwise Operation</a></h3>
<p>The XOR operation has the following properties:</p>
<ul>
<li>Any number XOR 0 is still the original number, i.e., $x \oplus 0 = x$;</li>
<li>Any number XOR itself is 0, i.e., $x \oplus x = 0$;</li>
</ul>
<p>Since all numbers in the array appear twice except for two numbers, we can perform XOR operation on all numbers in the array to get the XOR result of the two numbers that only appear once.</p>
<p>Since these two numbers are not equal, there is at least one bit that is 1 in the XOR result. We can use the <code>lowbit</code> operation to find the lowest bit of 1 in the XOR result, and divide all numbers in the array into two groups based on whether this bit is 1 or not. This way, the two numbers that only appear once are separated into different groups.</p>
<p>Perform XOR operation on each group separately to obtain the two numbers $a$ and $b$ that only appear once.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-12"><a class="header" href="#python3-12">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        xs = reduce(xor, nums)
        a = 0
        lb = xs &amp; -xs
        for x in nums:
            if x &amp; lb:
                a ^= x
        b = xs ^ a
        return [a, b]
</code></pre>
<h4 id="java-12"><a class="header" href="#java-12">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int[] singleNumber(int[] nums) {
        int xs = 0;
        for (int x : nums) {
            xs ^= x;
        }
        int lb = xs &amp; -xs;
        int a = 0;
        for (int x : nums) {
            if ((x &amp; lb) != 0) {
                a ^= x;
            }
        }
        int b = xs ^ a;
        return new int[] {a, b};
    }
}
</code></pre>
<h4 id="c-14"><a class="header" href="#c-14">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
        long long xs = 0;
        for (int&amp; x : nums) {
            xs ^= x;
        }
        int lb = xs &amp; -xs;
        int a = 0;
        for (int&amp; x : nums) {
            if (x &amp; lb) {
                a ^= x;
            }
        }
        int b = xs ^ a;
        return {a, b};
    }
};
</code></pre>
<h4 id="go-12"><a class="header" href="#go-12">Go</a></h4>
<pre><code class="language-go">func singleNumber(nums []int) []int {
	xs := 0
	for _, x := range nums {
		xs ^= x
	}
	lb := xs &amp; -xs
	a := 0
	for _, x := range nums {
		if x&amp;lb != 0 {
			a ^= x
		}
	}
	b := xs ^ a
	return []int{a, b}
}
</code></pre>
<h4 id="typescript-12"><a class="header" href="#typescript-12">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number[] {
    const xs = nums.reduce((a, b) =&gt; a ^ b);
    const lb = xs &amp; -xs;
    let a = 0;
    for (const x of nums) {
        if (x &amp; lb) {
            a ^= x;
        }
    }
    const b = xs ^ a;
    return [a, b];
}
</code></pre>
<h4 id="rust-5"><a class="header" href="#rust-5">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        let xs = nums.iter().fold(0, |r, v| r ^ v);
        let lb = xs &amp; -xs;
        let mut a = 0;
        for x in &amp;nums {
            if (x &amp; lb) != 0 {
                a ^= x;
            }
        }
        let b = xs ^ a;
        vec![a, b]
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-3"><a class="header" href="#javascript-3">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function (nums) {
    const xs = nums.reduce((a, b) =&gt; a ^ b);
    const lb = xs &amp; -xs;
    let a = 0;
    for (const x of nums) {
        if (x &amp; lb) {
            a ^= x;
        }
    }
    const b = xs ^ a;
    return [a, b];
};
</code></pre>
<h4 id="c-15"><a class="header" href="#c-15">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int[] SingleNumber(int[] nums) {
        int xs = nums.Aggregate(0, (a, b) =&gt; a ^ b);
        int lb = xs &amp; -xs;
        int a = 0;
        foreach(int x in nums) {
            if ((x &amp; lb) != 0) {
                a ^= x;
            }
        }
        int b = xs ^ a;
        return new int[] {a, b};
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-hash-table"><a class="header" href="#solution-2-hash-table">Solution 2: Hash Table</a></h3>
<!-- tabs:start -->
<h4 id="typescript-13"><a class="header" href="#typescript-13">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number[] {
    const set = new Set&lt;number&gt;();

    for (const x of nums) {
        if (set.has(x)) set.delete(x);
        else set.add(x);
    }

    return [...set];
}
</code></pre>
<h4 id="javascript-4"><a class="header" href="#javascript-4">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number[]}
 */
function singleNumber(nums) {
    const set = new Set();

    for (const x of nums) {
        if (set.has(x)) set.delete(x);
        else set.add(x);
    }

    return [...set];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 数组中有2种数出现了奇数次，其他的数都出现了偶数次
// 返回这2种出现了奇数次的数
// 测试链接 : https://leetcode.com/problems/single-number-iii/
public class Code05_DoubleNumber {

	public static int[] singleNumber(int[] nums) {
		int eor1 = 0;
		for (int num : nums) {
			// nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次
			eor1 ^= num;
		}
		// eor1 : a ^ b
		// Brian Kernighan算法
		// 提取出二进制里最右侧的1
		int rightOne = eor1 &amp; (-eor1);
		int eor2 = 0;
		for (int num : nums) {
			if ((num &amp; rightOne) == 0) {
				eor2 ^= num;
			}
		}
		return new int[] { eor2, eor1 ^ eor2 };
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="single-number-ii"><a class="header" href="#single-number-ii">Single Number II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0100-0199/0137.Single%20Number%20II/README_EN.md
tags:
    - Bit Manipulation
    - Array
</code></pre>
<!-- problem:start -->
<h1 id="137-single-number-ii"><a class="header" href="#137-single-number-ii"><a href="https://leetcode.com/problems/single-number-ii">137. Single Number II</a></a></h1>
<p><a href="binary-number//solution/0100-0199/0137.Single%20Number%20II/README.html">中文文档</a></p>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>
<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [2,2,3,2]
<strong>Output:</strong> 3
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]
<strong>Output:</strong> 99
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-10"><a class="header" href="#solutions-10">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-bitwise-operation-2"><a class="header" href="#solution-1-bitwise-operation-2">Solution 1: Bitwise Operation</a></h3>
<p>We can enumerate each binary bit $i$, and for each binary bit, we calculate the sum of all numbers on that bit. If the sum of the numbers on that bit can be divided by 3, then the number that only appears once on that bit is 0, otherwise it is 1.</p>
<p>The time complexity is $O(n \times \log M)$, where $n$ and $M$ are the length of the array and the range of elements in the array, respectively. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-13"><a class="header" href="#python3-13">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        ans = 0
        for i in range(32):
            cnt = sum(num &gt;&gt; i &amp; 1 for num in nums)
            if cnt % 3:
                if i == 31:
                    ans -= 1 &lt;&lt; i
                else:
                    ans |= 1 &lt;&lt; i
        return ans
</code></pre>
<h4 id="java-13"><a class="header" href="#java-13">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i &lt; 32; i++) {
            int cnt = 0;
            for (int num : nums) {
                cnt += num &gt;&gt; i &amp; 1;
            }
            cnt %= 3;
            ans |= cnt &lt;&lt; i;
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-16"><a class="header" href="#c-16">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for (int i = 0; i &lt; 32; ++i) {
            int cnt = 0;
            for (int num : nums) {
                cnt += ((num &gt;&gt; i) &amp; 1);
            }
            cnt %= 3;
            ans |= cnt &lt;&lt; i;
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-13"><a class="header" href="#go-13">Go</a></h4>
<pre><code class="language-go">func singleNumber(nums []int) int {
	ans := int32(0)
	for i := 0; i &lt; 32; i++ {
		cnt := int32(0)
		for _, num := range nums {
			cnt += int32(num) &gt;&gt; i &amp; 1
		}
		cnt %= 3
		ans |= cnt &lt;&lt; i
	}
	return int(ans)
}
</code></pre>
<h4 id="typescript-14"><a class="header" href="#typescript-14">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    let ans = 0;
    for (let i = 0; i &lt; 32; i++) {
        const count = nums.reduce((r, v) =&gt; r + ((v &gt;&gt; i) &amp; 1), 0);
        ans |= count % 3 &lt;&lt; i;
    }
    return ans;
}
</code></pre>
<h4 id="javascript-5"><a class="header" href="#javascript-5">JavaScript</a></h4>
<pre><code class="language-js">function singleNumber(nums) {
    let ans = 0;
    for (let i = 0; i &lt; 32; i++) {
        const count = nums.reduce((r, v) =&gt; r + ((v &gt;&gt; i) &amp; 1), 0);
        ans |= count % 3 &lt;&lt; i;
    }
    return ans;
}
</code></pre>
<h4 id="rust-6"><a class="header" href="#rust-6">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut ans = 0;
        for i in 0..32 {
            let count = nums.iter().map(|v| (v &gt;&gt; i) &amp; 1).sum::&lt;i32&gt;();
            ans |= count % 3 &lt;&lt; i;
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="c-17"><a class="header" href="#c-17">C</a></h4>
<pre><code class="language-c">int singleNumber(int* nums, int numsSize) {
    int ans = 0;
    for (int i = 0; i &lt; 32; i++) {
        int count = 0;
        for (int j = 0; j &lt; numsSize; j++) {
            if (nums[j] &gt;&gt; i &amp; 1) {
                count++;
            }
        }
        ans |= (uint) (count % 3) &lt;&lt; i;
    }
    return ans;
}
</code></pre>
<h4 id="swift"><a class="header" href="#swift">Swift</a></h4>
<pre><code class="language-swift">class Solution {
    func singleNumber(_ nums: [Int]) -&gt; Int {
        var a = nums.sorted()
        var n = a.count
        for i in stride(from: 0, through: n - 2, by: 3) {
            if a[i] != a[i + 1] {
                return a[i]
            }
        }
        return a[n - 1]
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-digital-circuit"><a class="header" href="#solution-2-digital-circuit">Solution 2: Digital Circuit</a></h3>
<p>We can use a more efficient method that uses digital circuits to simulate the above bitwise operation.</p>
<p>Each binary bit of an integer can only represent 2 states, 0 or 1. However, we need to represent the sum of the $i$-th bit of all integers traversed so far modulo 3. Therefore, we can use two integers $a$ and $b$ to represent it. There are three possible cases:</p>
<ol>
<li>The $i$-th bit of integer $a$ is 0 and the $i$-th bit of integer $b$ is 0, which means the modulo 3 result is 0;</li>
<li>The $i$-th bit of integer $a$ is 0 and the $i$-th bit of integer $b$ is 1, which means the modulo 3 result is 1;</li>
<li>The $i$-th bit of integer $a$ is 1 and the $i$-th bit of integer $b$ is 0, which means the modulo 3 result is 2.</li>
</ol>
<p>We use integer $c$ to represent the number to be read in, and the truth table is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>$a_i$</th><th>$b_i$</th><th>$c_i$</th><th>New $a_i$</th><th>New $b_i$</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>Based on the truth table, we can write the logical expression:</p>
<p>$$
a_i = a_i' b_i c_i + a_i b_i' c_i'
$$</p>
<p>and:</p>
<p>$$
b_i = a_i' b_i' c_i + a_i' b_i c_i' = a_i' (b_i \oplus c_i)
$$</p>
<p>The final result is $b$, because when the binary bit of $b$ is 1, it means that the number appears only once.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-14"><a class="header" href="#python3-14">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        a = b = 0
        for c in nums:
            aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c)
            bb = ~a &amp; (b ^ c)
            a, b = aa, bb
        return b
</code></pre>
<h4 id="java-14"><a class="header" href="#java-14">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int singleNumber(int[] nums) {
        int a = 0, b = 0;
        for (int c : nums) {
            int aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
            int bb = ~a &amp; (b ^ c);
            a = aa;
            b = bb;
        }
        return b;
    }
}
</code></pre>
<h4 id="c-18"><a class="header" href="#c-18">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int a = 0, b = 0;
        for (int c : nums) {
            int aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
            int bb = ~a &amp; (b ^ c);
            a = aa;
            b = bb;
        }
        return b;
    }
};
</code></pre>
<h4 id="go-14"><a class="header" href="#go-14">Go</a></h4>
<pre><code class="language-go">func singleNumber(nums []int) int {
	a, b := 0, 0
	for _, c := range nums {
		aa := (^a &amp; b &amp; c) | (a &amp; ^b &amp; ^c)
		bb := ^a &amp; (b ^ c)
		a, b = aa, bb
	}
	return b
}
</code></pre>
<h4 id="typescript-15"><a class="header" href="#typescript-15">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    let a = 0;
    let b = 0;
    for (const c of nums) {
        const aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
        const bb = ~a &amp; (b ^ c);
        a = aa;
        b = bb;
    }
    return b;
}
</code></pre>
<h4 id="javascript-6"><a class="header" href="#javascript-6">JavaScript</a></h4>
<pre><code class="language-js">function singleNumber(nums) {
    let a = 0;
    let b = 0;
    for (const c of nums) {
        const aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
        const bb = ~a &amp; (b ^ c);
        a = aa;
        b = bb;
    }
    return b;
}
</code></pre>
<h4 id="rust-7"><a class="header" href="#rust-7">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut a = 0;
        let mut b = 0;

        for c in nums {
            let aa = (!a &amp; b &amp; c) | (a &amp; !b &amp; !c);
            let bb = !a &amp; (b ^ c);
            a = aa;
            b = bb;
        }

        return b;
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-set--math"><a class="header" href="#solution-3-set--math">Solution 3: Set + Math</a></h3>
<!-- tabs:start -->
<h4 id="typescript-16"><a class="header" href="#typescript-16">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    const sumOfUnique = [...new Set(nums)].reduce((a, b) =&gt; a + b, 0);
    const sum = nums.reduce((a, b) =&gt; a + b, 0);
    return (sumOfUnique * 3 - sum) / 2;
}
</code></pre>
<h4 id="javascript-7"><a class="header" href="#javascript-7">JavaScript</a></h4>
<pre><code class="language-js">function singleNumber(nums) {
    const sumOfUnique = [...new Set(nums)].reduce((a, b) =&gt; a + b, 0);
    const sum = nums.reduce((a, b) =&gt; a + b, 0);
    return (sumOfUnique * 3 - sum) / 2;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-4-bit-manipulation"><a class="header" href="#solution-4-bit-manipulation">Solution 4: Bit Manipulation</a></h3>
<!-- tabs:start -->
<h4 id="typescript-17"><a class="header" href="#typescript-17">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    let [ans, acc] = [0, 0];

    for (const x of nums) {
        ans ^= x &amp; ~acc;
        acc ^= x &amp; ~ans;
    }

    return ans;
}
</code></pre>
<h4 id="javascript-8"><a class="header" href="#javascript-8">JavaScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums) {
    let [ans, acc] = [0, 0];

    for (const x of nums) {
        ans ^= x &amp; ~acc;
        acc ^= x &amp; ~ans;
    }

    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 数组中只有1种数出现次数少于m次，其他数都出现了m次
// 返回出现次数小于m次的那种数
// 测试链接 : https://leetcode.com/problems/single-number-ii/
// 注意 : 测试题目只是通用方法的一个特例，课上讲了更通用的情况
public class Code06_OneKindNumberLessMtimes {

	public static int singleNumber(int[] nums) {
		return find(nums, 3);
	}

	// 更通用的方法
	// 已知数组中只有1种数出现次数少于m次，其他数都出现了m次
	// 返回出现次数小于m次的那种数
	public static int find(int[] arr, int m) {
		// cnts[0] : 0位上有多少个1
		// cnts[i] : i位上有多少个1
		// cnts[31] : 31位上有多少个1
		int[] cnts = new int[32];
		for (int num : arr) {
			for (int i = 0; i &lt; 32; i++) {
				cnts[i] += (num &gt;&gt; i) &amp; 1;
			}
		}
		int ans = 0;
		for (int i = 0; i &lt; 32; i++) {
			if (cnts[i] % m != 0) {
				ans |= 1 &lt;&lt; i;
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xor-operation-problems-1"><a class="header" href="#xor-operation-problems-1">XOR Operation Problems</a></h1>
<h2 id="swap-exclusive-or-1"><a class="header" href="#swap-exclusive-or-1">Swap Exclusive Or</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class030;

// 用异或运算交换两数的值
public class Code01_SwapExclusiveOr {

	public static void main(String[] args) {
		int a = -2323;
		int b = 10;
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;
		System.out.println(a);
		System.out.println(b);

		int[] arr = { 3, 5 };
		swap(arr, 0, 1);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		swap(arr, 0, 0);
		System.out.println(arr[0]);
	}

	// 当i!=j，没问题，会完成交换功能
	// 当i==j，会出错
	// 所以知道这种写法即可，并不推荐
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 用异或运算交换两数的值
public class Code01_SwapExclusiveOr {

	public static void main(String[] args) {
		int a = -2323;
		int b = 10;
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;
		System.out.println(a);
		System.out.println(b);

		int[] arr = { 3, 5 };
		swap(arr, 0, 1);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		swap(arr, 0, 0);
		System.out.println(arr[0]);
	}

	// 当i!=j，没问题，会完成交换功能
	// 当i==j，会出错
	// 所以知道这种写法即可，并不推荐
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="get-max-without-logic-operators-1"><a class="header" href="#get-max-without-logic-operators-1">Get Max Without Logic Operators</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class030;

// 不用任何判断语句和比较操作，返回两个数的最大值
// 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76
public class Code02_GetMaxWithoutJudge {

	// 必须保证n一定是0或者1
	// 0变1，1变0
	public static int flip(int n) {
		return n ^ 1;
	}

	// 非负数返回1
	// 负数返回0
	public static int sign(int n) {
		return flip(n &gt;&gt;&gt; 31);
	}

	// 有溢出风险的实现
	public static int getMax1(int a, int b) {
		int c = a - b;
		// c非负，returnA -&gt; 1
		// c非负，returnB -&gt; 0
		// c负数，returnA -&gt; 0
		// c负数，returnB -&gt; 1
		int returnA = sign(c);
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	// 没有任何问题的实现
	public static int getMax2(int a, int b) {
		// c可能是溢出的
		int c = a - b;
		// a的符号
		int sa = sign(a);
		// b的符号
		int sb = sign(b);
		// c的符号
		int sc = sign(c);
		// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0
		int diffAB = sa ^ sb;
		// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0
		int sameAB = flip(diffAB);
		int returnA = diffAB * sa + sameAB * sc;
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	public static void main(String[] args) {
		int a = Integer.MIN_VALUE;
		int b = Integer.MAX_VALUE;
		// getMax1方法会错误，因为溢出
		System.out.println(getMax1(a, b));
		// getMax2方法永远正确
		System.out.println(getMax2(a, b));
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 不用任何判断语句和比较操作，返回两个数的最大值
// 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76
public class Code02_GetMaxWithoutJudge {

	// 必须保证n一定是0或者1
	// 0变1，1变0
	public static int flip(int n) {
		return n ^ 1;
	}

	// 非负数返回1
	// 负数返回0
	public static int sign(int n) {
		return flip(n &gt;&gt;&gt; 31);
	}

	// 有溢出风险的实现
	public static int getMax1(int a, int b) {
		int c = a - b;
		// c非负，returnA -&gt; 1
		// c非负，returnB -&gt; 0
		// c负数，returnA -&gt; 0
		// c负数，returnB -&gt; 1
		int returnA = sign(c);
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	// 没有任何问题的实现
	public static int getMax2(int a, int b) {
		// c可能是溢出的
		int c = a - b;
		// a的符号
		int sa = sign(a);
		// b的符号
		int sb = sign(b);
		// c的符号
		int sc = sign(c);
		// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0
		int diffAB = sa ^ sb;
		// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0
		int sameAB = flip(diffAB);
		int returnA = diffAB * sa + sameAB * sc;
		int returnB = flip(returnA);
		return a * returnA + b * returnB;
	}

	public static void main(String[] args) {
		int a = Integer.MIN_VALUE;
		int b = Integer.MAX_VALUE;
		// getMax1方法会错误，因为溢出
		System.out.println(getMax1(a, b));
		// getMax2方法永远正确
		System.out.println(getMax2(a, b));
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="missing-number-1"><a class="header" href="#missing-number-1">Missing Number</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Easy
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0268.Missing%20Number/README_EN.md
tags:
    - Bit Manipulation
    - Array
    - Hash Table
    - Math
    - Binary Search
    - Sorting
</code></pre>
<!-- problem:start -->
<h1 id="268-missing-number-1"><a class="header" href="#268-missing-number-1"><a href="https://leetcode.com/problems/missing-number">268. Missing Number</a></a></h1>
<p><a href="binary-number//solution/0200-0299/0268.Missing%20Number/README.html">中文文档</a></p>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<!-- description:start -->
<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [3,0,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]
<strong>Output:</strong> 8
<strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= n</code></li>
	<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p>
<!-- description:end -->
<h2 id="solutions-11"><a class="header" href="#solutions-11">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-bitwise-operation-3"><a class="header" href="#solution-1-bitwise-operation-3">Solution 1: Bitwise Operation</a></h3>
<p>The XOR operation has the following properties:</p>
<ul>
<li>Any number XOR 0 is still the original number, i.e., $x \oplus 0 = x$;</li>
<li>Any number XOR itself is 0, i.e., $x \oplus x = 0$;</li>
</ul>
<p>Therefore, we can traverse the array, perform XOR operation between each element and the numbers $[0,..n]$, and the final result will be the missing number.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-15"><a class="header" href="#python3-15">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        return reduce(xor, (i ^ v for i, v in enumerate(nums, 1)))
</code></pre>
<h4 id="java-15"><a class="header" href="#java-15">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans ^= (i ^ nums[i]);
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-19"><a class="header" href="#c-19">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans ^= (i ^ nums[i]);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-15"><a class="header" href="#go-15">Go</a></h4>
<pre><code class="language-go">func missingNumber(nums []int) (ans int) {
	n := len(nums)
	ans = n
	for i, v := range nums {
		ans ^= (i ^ v)
	}
	return
}
</code></pre>
<h4 id="typescript-18"><a class="header" href="#typescript-18">TypeScript</a></h4>
<pre><code class="language-ts">function missingNumber(nums: number[]): number {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans ^= i ^ nums[i];
    }
    return ans;
}
</code></pre>
<h4 id="rust-8"><a class="header" href="#rust-8">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn missing_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len() as i32;
        let mut ans = n;
        for (i, v) in nums.iter().enumerate() {
            ans ^= (i as i32) ^ v;
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-9"><a class="header" href="#javascript-9">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans ^= i ^ nums[i];
    }
    return ans;
};
</code></pre>
<h4 id="php-1"><a class="header" href="#php-1">PHP</a></h4>
<pre><code class="language-php">class Solution {
    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function missingNumber($nums) {
        $n = count($nums);
        $sumN = (($n + 1) * $n) / 2;
        for ($i = 0; $i &lt; $n; $i++) {
            $sumN -= $nums[$i];
        }
        return $sumN;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-mathematics-1"><a class="header" href="#solution-2-mathematics-1">Solution 2: Mathematics</a></h3>
<p>We can also solve this problem using mathematics. By calculating the sum of $[0,..n]$, subtracting the sum of all numbers in the array, we can obtain the missing number.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-16"><a class="header" href="#python3-16">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        n = len(nums)
        return (1 + n) * n // 2 - sum(nums)
</code></pre>
<h4 id="java-16"><a class="header" href="#java-16">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int ans = n;
        for (int i = 0; i &lt; n; ++i) {
            ans += i - nums[i];
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-20"><a class="header" href="#c-20">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        return (1 + n) * n / 2 - accumulate(nums.begin(), nums.end(), 0);
    }
};
</code></pre>
<h4 id="go-16"><a class="header" href="#go-16">Go</a></h4>
<pre><code class="language-go">func missingNumber(nums []int) (ans int) {
	n := len(nums)
	ans = n
	for i, v := range nums {
		ans += i - v
	}
	return
}
</code></pre>
<h4 id="typescript-19"><a class="header" href="#typescript-19">TypeScript</a></h4>
<pre><code class="language-ts">function missingNumber(nums: number[]): number {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans += i - nums[i];
    }
    return ans;
}
</code></pre>
<h4 id="rust-9"><a class="header" href="#rust-9">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn missing_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len() as i32;
        let mut ans = n;
        for (i, &amp;v) in nums.iter().enumerate() {
            ans += (i as i32) - v;
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-10"><a class="header" href="#javascript-10">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
    const n = nums.length;
    let ans = n;
    for (let i = 0; i &lt; n; ++i) {
        ans += i - nums[i];
    }
    return ans;
};
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 找到缺失的数字
// 测试链接 : https://leetcode.com/problems/missing-number/
public class Code03_MissingNumber {

	public static int missingNumber(int[] nums) {
		int eorAll = 0, eorHas = 0;
		for (int i = 0; i &lt; nums.length; i++) {
			eorAll ^= i;
			eorHas ^= nums[i];
		}
		eorAll ^= nums.length;
		return eorAll ^ eorHas;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="biggest-single-number-1"><a class="header" href="#biggest-single-number-1">Biggest Single Number</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Easy
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0619.Biggest%20Single%20Number/README_EN.md
tags:
    - Database
</code></pre>
<!-- problem:start -->
<h1 id="619-biggest-single-number-1"><a class="header" href="#619-biggest-single-number-1"><a href="https://leetcode.com/problems/biggest-single-number">619. Biggest Single Number</a></a></h1>
<p><a href="binary-number//solution/0600-0699/0619.Biggest%20Single%20Number/README.html">中文文档</a></p>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<!-- description:start -->
<p>Table: <code>MyNumbers</code></p>
<pre>
+-------------+------+
| Column Name | Type |
+-------------+------+
| num         | int  |
+-------------+------+
This table may contain duplicates (In other words, there is no primary key for this table in SQL).
Each row of this table contains an integer.
</pre>
<p>&nbsp;</p>
<p>A <strong>single number</strong> is a number that appeared only once in the <code>MyNumbers</code> table.</p>
<p>Find the largest <strong>single number</strong>. If there is no <strong>single number</strong>, report <code>null</code>.</p>
<p>The result format is in the following example.</p>
<ptable> </ptable>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> 
MyNumbers table:
+-----+
| num |
+-----+
| 8   |
| 8   |
| 3   |
| 3   |
| 1   |
| 4   |
| 5   |
| 6   |
+-----+
<strong>Output:</strong> 
+-----+
| num |
+-----+
| 6   |
+-----+
<strong>Explanation:</strong> The single numbers are 1, 4, 5, and 6.
Since 6 is the largest single number, we return it.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> 
MyNumbers table:
+-----+
| num |
+-----+
| 8   |
| 8   |
| 7   |
| 7   |
| 3   |
| 3   |
| 3   |
+-----+
<strong>Output:</strong> 
+------+
| num  |
+------+
| null |
+------+
<strong>Explanation:</strong> There are no single numbers in the input table so we return null.
</pre>
<!-- description:end -->
<h2 id="solutions-12"><a class="header" href="#solutions-12">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-grouping-and-subquery-1"><a class="header" href="#solution-1-grouping-and-subquery-1">Solution 1: Grouping and Subquery</a></h3>
<p>We can first group the <code>MyNumbers</code> table by <code>num</code> and count the number of occurrences of each number. Then, we can use a subquery to find the maximum number among the numbers that appear only once.</p>
<!-- tabs:start -->
<h4 id="mysql-2"><a class="header" href="#mysql-2">MySQL</a></h4>
<pre><code class="language-sql"># Write your MySQL query statement below
SELECT MAX(num) AS num
FROM
    (
        SELECT num
        FROM MyNumbers
        GROUP BY 1
        HAVING COUNT(1) = 1
    ) AS t;
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-grouping-and-case-expression-1"><a class="header" href="#solution-2-grouping-and-case-expression-1">Solution 2: Grouping and <code>CASE</code> Expression</a></h3>
<p>Similar to Solution 1, we can first group the <code>MyNumbers</code> table by <code>num</code> and count the number of occurrences of each number. Then, we can use a <code>CASE</code> expression to find the numbers that appear only once, sort them in descending order by number, and take the first one.</p>
<!-- tabs:start -->
<h4 id="mysql-3"><a class="header" href="#mysql-3">MySQL</a></h4>
<pre><code class="language-sql"># Write your MySQL query statement below
SELECT
    CASE
        WHEN COUNT(1) = 1 THEN num
        ELSE NULL
    END AS num
FROM MyNumbers
GROUP BY num
ORDER BY 1 DESC
LIMIT 1;
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 数组中1种数出现了奇数次，其他的数都出现了偶数次
// 返回出现了奇数次的数
// 测试链接 : https://leetcode.com/problems/single-number/
public class Code04_SingleNumber {

	public static int singleNumber(int[] nums) {
		int eor = 0;
		for (int num : nums) {
			eor ^= num;
		}
		return eor;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="single-number-iii-1"><a class="header" href="#single-number-iii-1">Single Number III</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0260.Single%20Number%20III/README_EN.md
tags:
    - Bit Manipulation
    - Array
</code></pre>
<!-- problem:start -->
<h1 id="260-single-number-iii-1"><a class="header" href="#260-single-number-iii-1"><a href="https://leetcode.com/problems/single-number-iii">260. Single Number III</a></a></h1>
<p><a href="binary-number//solution/0200-0299/0260.Single%20Number%20III/README.html">中文文档</a></p>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>
<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,1,3,2,5]
<strong>Output:</strong> [3,5]
<strong>Explanation: </strong> [5, 3] is also a valid answer.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [-1,0]
<strong>Output:</strong> [-1,0]
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [1,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-13"><a class="header" href="#solutions-13">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-bitwise-operation-4"><a class="header" href="#solution-1-bitwise-operation-4">Solution 1: Bitwise Operation</a></h3>
<p>The XOR operation has the following properties:</p>
<ul>
<li>Any number XOR 0 is still the original number, i.e., $x \oplus 0 = x$;</li>
<li>Any number XOR itself is 0, i.e., $x \oplus x = 0$;</li>
</ul>
<p>Since all numbers in the array appear twice except for two numbers, we can perform XOR operation on all numbers in the array to get the XOR result of the two numbers that only appear once.</p>
<p>Since these two numbers are not equal, there is at least one bit that is 1 in the XOR result. We can use the <code>lowbit</code> operation to find the lowest bit of 1 in the XOR result, and divide all numbers in the array into two groups based on whether this bit is 1 or not. This way, the two numbers that only appear once are separated into different groups.</p>
<p>Perform XOR operation on each group separately to obtain the two numbers $a$ and $b$ that only appear once.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-17"><a class="header" href="#python3-17">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        xs = reduce(xor, nums)
        a = 0
        lb = xs &amp; -xs
        for x in nums:
            if x &amp; lb:
                a ^= x
        b = xs ^ a
        return [a, b]
</code></pre>
<h4 id="java-17"><a class="header" href="#java-17">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int[] singleNumber(int[] nums) {
        int xs = 0;
        for (int x : nums) {
            xs ^= x;
        }
        int lb = xs &amp; -xs;
        int a = 0;
        for (int x : nums) {
            if ((x &amp; lb) != 0) {
                a ^= x;
            }
        }
        int b = xs ^ a;
        return new int[] {a, b};
    }
}
</code></pre>
<h4 id="c-21"><a class="header" href="#c-21">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
        long long xs = 0;
        for (int&amp; x : nums) {
            xs ^= x;
        }
        int lb = xs &amp; -xs;
        int a = 0;
        for (int&amp; x : nums) {
            if (x &amp; lb) {
                a ^= x;
            }
        }
        int b = xs ^ a;
        return {a, b};
    }
};
</code></pre>
<h4 id="go-17"><a class="header" href="#go-17">Go</a></h4>
<pre><code class="language-go">func singleNumber(nums []int) []int {
	xs := 0
	for _, x := range nums {
		xs ^= x
	}
	lb := xs &amp; -xs
	a := 0
	for _, x := range nums {
		if x&amp;lb != 0 {
			a ^= x
		}
	}
	b := xs ^ a
	return []int{a, b}
}
</code></pre>
<h4 id="typescript-20"><a class="header" href="#typescript-20">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number[] {
    const xs = nums.reduce((a, b) =&gt; a ^ b);
    const lb = xs &amp; -xs;
    let a = 0;
    for (const x of nums) {
        if (x &amp; lb) {
            a ^= x;
        }
    }
    const b = xs ^ a;
    return [a, b];
}
</code></pre>
<h4 id="rust-10"><a class="header" href="#rust-10">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        let xs = nums.iter().fold(0, |r, v| r ^ v);
        let lb = xs &amp; -xs;
        let mut a = 0;
        for x in &amp;nums {
            if (x &amp; lb) != 0 {
                a ^= x;
            }
        }
        let b = xs ^ a;
        vec![a, b]
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-11"><a class="header" href="#javascript-11">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function (nums) {
    const xs = nums.reduce((a, b) =&gt; a ^ b);
    const lb = xs &amp; -xs;
    let a = 0;
    for (const x of nums) {
        if (x &amp; lb) {
            a ^= x;
        }
    }
    const b = xs ^ a;
    return [a, b];
};
</code></pre>
<h4 id="c-22"><a class="header" href="#c-22">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int[] SingleNumber(int[] nums) {
        int xs = nums.Aggregate(0, (a, b) =&gt; a ^ b);
        int lb = xs &amp; -xs;
        int a = 0;
        foreach(int x in nums) {
            if ((x &amp; lb) != 0) {
                a ^= x;
            }
        }
        int b = xs ^ a;
        return new int[] {a, b};
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-hash-table-1"><a class="header" href="#solution-2-hash-table-1">Solution 2: Hash Table</a></h3>
<!-- tabs:start -->
<h4 id="typescript-21"><a class="header" href="#typescript-21">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number[] {
    const set = new Set&lt;number&gt;();

    for (const x of nums) {
        if (set.has(x)) set.delete(x);
        else set.add(x);
    }

    return [...set];
}
</code></pre>
<h4 id="javascript-12"><a class="header" href="#javascript-12">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number[]}
 */
function singleNumber(nums) {
    const set = new Set();

    for (const x of nums) {
        if (set.has(x)) set.delete(x);
        else set.add(x);
    }

    return [...set];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 数组中有2种数出现了奇数次，其他的数都出现了偶数次
// 返回这2种出现了奇数次的数
// 测试链接 : https://leetcode.com/problems/single-number-iii/
public class Code05_DoubleNumber {

	public static int[] singleNumber(int[] nums) {
		int eor1 = 0;
		for (int num : nums) {
			// nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次
			eor1 ^= num;
		}
		// eor1 : a ^ b
		// Brian Kernighan算法
		// 提取出二进制里最右侧的1
		int rightOne = eor1 &amp; (-eor1);
		int eor2 = 0;
		for (int num : nums) {
			if ((num &amp; rightOne) == 0) {
				eor2 ^= num;
			}
		}
		return new int[] { eor2, eor1 ^ eor2 };
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<h2 id="single-number-ii-1"><a class="header" href="#single-number-ii-1">Single Number II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0100-0199/0137.Single%20Number%20II/README_EN.md
tags:
    - Bit Manipulation
    - Array
</code></pre>
<!-- problem:start -->
<h1 id="137-single-number-ii-1"><a class="header" href="#137-single-number-ii-1"><a href="https://leetcode.com/problems/single-number-ii">137. Single Number II</a></a></h1>
<p><a href="binary-number//solution/0100-0199/0137.Single%20Number%20II/README.html">中文文档</a></p>
<h2 id="description-14"><a class="header" href="#description-14">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>
<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [2,2,3,2]
<strong>Output:</strong> 3
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]
<strong>Output:</strong> 99
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-14"><a class="header" href="#solutions-14">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-bitwise-operation-5"><a class="header" href="#solution-1-bitwise-operation-5">Solution 1: Bitwise Operation</a></h3>
<p>We can enumerate each binary bit $i$, and for each binary bit, we calculate the sum of all numbers on that bit. If the sum of the numbers on that bit can be divided by 3, then the number that only appears once on that bit is 0, otherwise it is 1.</p>
<p>The time complexity is $O(n \times \log M)$, where $n$ and $M$ are the length of the array and the range of elements in the array, respectively. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-18"><a class="header" href="#python3-18">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        ans = 0
        for i in range(32):
            cnt = sum(num &gt;&gt; i &amp; 1 for num in nums)
            if cnt % 3:
                if i == 31:
                    ans -= 1 &lt;&lt; i
                else:
                    ans |= 1 &lt;&lt; i
        return ans
</code></pre>
<h4 id="java-18"><a class="header" href="#java-18">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i &lt; 32; i++) {
            int cnt = 0;
            for (int num : nums) {
                cnt += num &gt;&gt; i &amp; 1;
            }
            cnt %= 3;
            ans |= cnt &lt;&lt; i;
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-23"><a class="header" href="#c-23">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for (int i = 0; i &lt; 32; ++i) {
            int cnt = 0;
            for (int num : nums) {
                cnt += ((num &gt;&gt; i) &amp; 1);
            }
            cnt %= 3;
            ans |= cnt &lt;&lt; i;
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-18"><a class="header" href="#go-18">Go</a></h4>
<pre><code class="language-go">func singleNumber(nums []int) int {
	ans := int32(0)
	for i := 0; i &lt; 32; i++ {
		cnt := int32(0)
		for _, num := range nums {
			cnt += int32(num) &gt;&gt; i &amp; 1
		}
		cnt %= 3
		ans |= cnt &lt;&lt; i
	}
	return int(ans)
}
</code></pre>
<h4 id="typescript-22"><a class="header" href="#typescript-22">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    let ans = 0;
    for (let i = 0; i &lt; 32; i++) {
        const count = nums.reduce((r, v) =&gt; r + ((v &gt;&gt; i) &amp; 1), 0);
        ans |= count % 3 &lt;&lt; i;
    }
    return ans;
}
</code></pre>
<h4 id="javascript-13"><a class="header" href="#javascript-13">JavaScript</a></h4>
<pre><code class="language-js">function singleNumber(nums) {
    let ans = 0;
    for (let i = 0; i &lt; 32; i++) {
        const count = nums.reduce((r, v) =&gt; r + ((v &gt;&gt; i) &amp; 1), 0);
        ans |= count % 3 &lt;&lt; i;
    }
    return ans;
}
</code></pre>
<h4 id="rust-11"><a class="header" href="#rust-11">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut ans = 0;
        for i in 0..32 {
            let count = nums.iter().map(|v| (v &gt;&gt; i) &amp; 1).sum::&lt;i32&gt;();
            ans |= count % 3 &lt;&lt; i;
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="c-24"><a class="header" href="#c-24">C</a></h4>
<pre><code class="language-c">int singleNumber(int* nums, int numsSize) {
    int ans = 0;
    for (int i = 0; i &lt; 32; i++) {
        int count = 0;
        for (int j = 0; j &lt; numsSize; j++) {
            if (nums[j] &gt;&gt; i &amp; 1) {
                count++;
            }
        }
        ans |= (uint) (count % 3) &lt;&lt; i;
    }
    return ans;
}
</code></pre>
<h4 id="swift-1"><a class="header" href="#swift-1">Swift</a></h4>
<pre><code class="language-swift">class Solution {
    func singleNumber(_ nums: [Int]) -&gt; Int {
        var a = nums.sorted()
        var n = a.count
        for i in stride(from: 0, through: n - 2, by: 3) {
            if a[i] != a[i + 1] {
                return a[i]
            }
        }
        return a[n - 1]
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-digital-circuit-1"><a class="header" href="#solution-2-digital-circuit-1">Solution 2: Digital Circuit</a></h3>
<p>We can use a more efficient method that uses digital circuits to simulate the above bitwise operation.</p>
<p>Each binary bit of an integer can only represent 2 states, 0 or 1. However, we need to represent the sum of the $i$-th bit of all integers traversed so far modulo 3. Therefore, we can use two integers $a$ and $b$ to represent it. There are three possible cases:</p>
<ol>
<li>The $i$-th bit of integer $a$ is 0 and the $i$-th bit of integer $b$ is 0, which means the modulo 3 result is 0;</li>
<li>The $i$-th bit of integer $a$ is 0 and the $i$-th bit of integer $b$ is 1, which means the modulo 3 result is 1;</li>
<li>The $i$-th bit of integer $a$ is 1 and the $i$-th bit of integer $b$ is 0, which means the modulo 3 result is 2.</li>
</ol>
<p>We use integer $c$ to represent the number to be read in, and the truth table is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>$a_i$</th><th>$b_i$</th><th>$c_i$</th><th>New $a_i$</th><th>New $b_i$</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>Based on the truth table, we can write the logical expression:</p>
<p>$$
a_i = a_i' b_i c_i + a_i b_i' c_i'
$$</p>
<p>and:</p>
<p>$$
b_i = a_i' b_i' c_i + a_i' b_i c_i' = a_i' (b_i \oplus c_i)
$$</p>
<p>The final result is $b$, because when the binary bit of $b$ is 1, it means that the number appears only once.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-19"><a class="header" href="#python3-19">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        a = b = 0
        for c in nums:
            aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c)
            bb = ~a &amp; (b ^ c)
            a, b = aa, bb
        return b
</code></pre>
<h4 id="java-19"><a class="header" href="#java-19">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int singleNumber(int[] nums) {
        int a = 0, b = 0;
        for (int c : nums) {
            int aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
            int bb = ~a &amp; (b ^ c);
            a = aa;
            b = bb;
        }
        return b;
    }
}
</code></pre>
<h4 id="c-25"><a class="header" href="#c-25">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int a = 0, b = 0;
        for (int c : nums) {
            int aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
            int bb = ~a &amp; (b ^ c);
            a = aa;
            b = bb;
        }
        return b;
    }
};
</code></pre>
<h4 id="go-19"><a class="header" href="#go-19">Go</a></h4>
<pre><code class="language-go">func singleNumber(nums []int) int {
	a, b := 0, 0
	for _, c := range nums {
		aa := (^a &amp; b &amp; c) | (a &amp; ^b &amp; ^c)
		bb := ^a &amp; (b ^ c)
		a, b = aa, bb
	}
	return b
}
</code></pre>
<h4 id="typescript-23"><a class="header" href="#typescript-23">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    let a = 0;
    let b = 0;
    for (const c of nums) {
        const aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
        const bb = ~a &amp; (b ^ c);
        a = aa;
        b = bb;
    }
    return b;
}
</code></pre>
<h4 id="javascript-14"><a class="header" href="#javascript-14">JavaScript</a></h4>
<pre><code class="language-js">function singleNumber(nums) {
    let a = 0;
    let b = 0;
    for (const c of nums) {
        const aa = (~a &amp; b &amp; c) | (a &amp; ~b &amp; ~c);
        const bb = ~a &amp; (b ^ c);
        a = aa;
        b = bb;
    }
    return b;
}
</code></pre>
<h4 id="rust-12"><a class="header" href="#rust-12">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut a = 0;
        let mut b = 0;

        for c in nums {
            let aa = (!a &amp; b &amp; c) | (a &amp; !b &amp; !c);
            let bb = !a &amp; (b ^ c);
            a = aa;
            b = bb;
        }

        return b;
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-set--math-1"><a class="header" href="#solution-3-set--math-1">Solution 3: Set + Math</a></h3>
<!-- tabs:start -->
<h4 id="typescript-24"><a class="header" href="#typescript-24">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    const sumOfUnique = [...new Set(nums)].reduce((a, b) =&gt; a + b, 0);
    const sum = nums.reduce((a, b) =&gt; a + b, 0);
    return (sumOfUnique * 3 - sum) / 2;
}
</code></pre>
<h4 id="javascript-15"><a class="header" href="#javascript-15">JavaScript</a></h4>
<pre><code class="language-js">function singleNumber(nums) {
    const sumOfUnique = [...new Set(nums)].reduce((a, b) =&gt; a + b, 0);
    const sum = nums.reduce((a, b) =&gt; a + b, 0);
    return (sumOfUnique * 3 - sum) / 2;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-4-bit-manipulation-1"><a class="header" href="#solution-4-bit-manipulation-1">Solution 4: Bit Manipulation</a></h3>
<!-- tabs:start -->
<h4 id="typescript-25"><a class="header" href="#typescript-25">TypeScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums: number[]): number {
    let [ans, acc] = [0, 0];

    for (const x of nums) {
        ans ^= x &amp; ~acc;
        acc ^= x &amp; ~ans;
    }

    return ans;
}
</code></pre>
<h4 id="javascript-16"><a class="header" href="#javascript-16">JavaScript</a></h4>
<pre><code class="language-ts">function singleNumber(nums) {
    let [ans, acc] = [0, 0];

    for (const x of nums) {
        ans ^= x &amp; ~acc;
        acc ^= x &amp; ~ans;
    }

    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class030;

// 数组中只有1种数出现次数少于m次，其他数都出现了m次
// 返回出现次数小于m次的那种数
// 测试链接 : https://leetcode.com/problems/single-number-ii/
// 注意 : 测试题目只是通用方法的一个特例，课上讲了更通用的情况
public class Code06_OneKindNumberLessMtimes {

	public static int singleNumber(int[] nums) {
		return find(nums, 3);
	}

	// 更通用的方法
	// 已知数组中只有1种数出现次数少于m次，其他数都出现了m次
	// 返回出现次数小于m次的那种数
	public static int find(int[] arr, int m) {
		// cnts[0] : 0位上有多少个1
		// cnts[i] : i位上有多少个1
		// cnts[31] : 31位上有多少个1
		int[] cnts = new int[32];
		for (int num : arr) {
			for (int i = 0; i &lt; 32; i++) {
				cnts[i] += (num &gt;&gt; i) &amp; 1;
			}
		}
		int ans = 0;
		for (int i = 0; i &lt; 32; i++) {
			if (cnts[i] % m != 0) {
				ans |= 1 &lt;&lt; i;
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/WwYJVQuN_UI?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h1>
<h2 id="top-down-approach-recursive-solution"><a class="header" href="#top-down-approach-recursive-solution">Top-Down Approach (Recursive Solution)</a></h2>
<ul>
<li>Divide the original problem into smaller sub-problems</li>
<li>Recursively solve the sub-problems</li>
<li>Compute the final answer from the sub-problems solutions</li>
</ul>
<h2 id="bottom-up-approach-iterative-solution"><a class="header" href="#bottom-up-approach-iterative-solution">Bottom-Up Approach (Iterative Solution)</a></h2>
<ul>
<li>Construct the <code>State Table</code> (DP table)</li>
<li>Design the <code>State Transition Plan</code></li>
<li>Initialize <code>State Table</code> with the base-case solutions</li>
<li>Fill the rest of <code>State Table</code> using the <code>State Transition Plan</code></li>
<li>Return the final state</li>
</ul>
<h2 id="optimization"><a class="header" href="#optimization">Optimization</a></h2>
<ul>
<li>Using memoization (caching) with the recursive solution</li>
<li>Considering state compression (space optimization) for the iterative solution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-dimentional-dp-problems"><a class="header" href="#one-dimentional-dp-problems">One-Dimentional DP Problems</a></h1>
<h2 id="fibonacci-number"><a class="header" href="#fibonacci-number">Fibonacci Number</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Easy
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0500-0599/0509.Fibonacci%20Number/README_EN.md
tags:
    - Recursion
    - Memoization
    - Math
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="509-fibonacci-number"><a class="header" href="#509-fibonacci-number"><a href="https://leetcode.com/problems/fibonacci-number">509. Fibonacci Number</a></a></h1>
<p><a href="dynamic-programming//solution/0500-0599/0509.Fibonacci%20Number/README.html">中文文档</a></p>
<h2 id="description-15"><a class="header" href="#description-15">Description</a></h2>
<!-- description:start -->
<p>The <b>Fibonacci numbers</b>, commonly denoted <code>F(n)</code> form a sequence, called the <b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<pre>
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n &gt; 1.
</pre>
<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-15"><a class="header" href="#solutions-15">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-recurrence"><a class="header" href="#solution-1-recurrence">Solution 1: Recurrence</a></h3>
<p>We define two variables $a$ and $b$, initially $a = 0$ and $b = 1$.</p>
<p>Next, we perform $n$ iterations. In each iteration, we update the values of $a$ and $b$ to $b$ and $a + b$, respectively.</p>
<p>Finally, we return $a$.</p>
<p>The time complexity is $O(n)$, where $n$ is the given integer. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-20"><a class="header" href="#python3-20">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def fib(self, n: int) -&gt; int:
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a
</code></pre>
<h4 id="java-20"><a class="header" href="#java-20">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int fib(int n) {
        int a = 0, b = 1;
        while (n-- &gt; 0) {
            int c = a + b;
            a = b;
            b = c;
        }
        return a;
    }
}
</code></pre>
<h4 id="c-26"><a class="header" href="#c-26">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int fib(int n) {
        int a = 0, b = 1;
        while (n--) {
            int c = a + b;
            a = b;
            b = c;
        }
        return a;
    }
};
</code></pre>
<h4 id="go-20"><a class="header" href="#go-20">Go</a></h4>
<pre><code class="language-go">func fib(n int) int {
	a, b := 0, 1
	for i := 0; i &lt; n; i++ {
		a, b = b, a+b
	}
	return a
}
</code></pre>
<h4 id="typescript-26"><a class="header" href="#typescript-26">TypeScript</a></h4>
<pre><code class="language-ts">function fib(n: number): number {
    let [a, b] = [0, 1];
    while (n--) {
        [a, b] = [b, a + b];
    }
    return a;
}
</code></pre>
<h4 id="rust-13"><a class="header" href="#rust-13">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn fib(n: i32) -&gt; i32 {
        let mut a = 0;
        let mut b = 1;
        for _ in 0..n {
            let t = b;
            b = a + b;
            a = t;
        }
        a
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-17"><a class="header" href="#javascript-17">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number} n
 * @return {number}
 */
var fib = function (n) {
    let [a, b] = [0, 1];
    while (n--) {
        [a, b] = [b, a + b];
    }
    return a;
};
</code></pre>
<h4 id="php-2"><a class="header" href="#php-2">PHP</a></h4>
<pre><code class="language-php">class Solution {
    /**
     * @param Integer $n
     * @return Integer
     */
    function fib($n) {
        $a = 0;
        $b = 1;
        for ($i = 0; $i &lt; $n; $i++) {
            $temp = $a;
            $a = $b;
            $b = $temp + $b;
        }
        return $a;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-matrix-exponentiation"><a class="header" href="#solution-2-matrix-exponentiation">Solution 2: Matrix Exponentiation</a></h3>
<p>We define $\textit{Fib}(n)$ as a $1 \times 2$ matrix $\begin{bmatrix} F_n &amp; F_{n - 1} \end{bmatrix}$, where $F_n$ and $F_{n - 1}$ are the $n$-th and $(n - 1)$-th Fibonacci numbers, respectively.</p>
<p>We want to derive $\textit{Fib}(n)$ from $\textit{Fib}(n - 1) = \begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \end{bmatrix}$. In other words, we need a matrix $\textit{base}$ such that $\textit{Fib}(n - 1) \times \textit{base} = \textit{Fib}(n)$, i.e.:</p>
<p>$$
\begin{bmatrix}
F_{n - 1} &amp; F_{n - 2}
\end{bmatrix} \times \textit{base} = \begin{bmatrix} F_n &amp; F_{n - 1} \end{bmatrix}
$$</p>
<p>Since $F_n = F_{n - 1} + F_{n - 2}$, the first column of the matrix $\textit{base}$ is:</p>
<p>$$
\begin{bmatrix}
1 \
1
\end{bmatrix}
$$</p>
<p>The second column is:</p>
<p>$$
\begin{bmatrix}
1 \
0
\end{bmatrix}
$$</p>
<p>Thus, we have:</p>
<p>$$
\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \end{bmatrix} \times \begin{bmatrix}1 &amp; 1 \ 1 &amp; 0\end{bmatrix} = \begin{bmatrix} F_n &amp; F_{n - 1} \end{bmatrix}
$$</p>
<p>We define the initial matrix $res = \begin{bmatrix} 1 &amp; 0 \end{bmatrix}$, then $F_n$ is equal to the second element of the first row of the result matrix obtained by multiplying $res$ with $\textit{base}^{n}$. We can solve this using matrix exponentiation.</p>
<p>The time complexity is $O(\log n)$, and the space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-21"><a class="header" href="#python3-21">Python3</a></h4>
<pre><code class="language-python">import numpy as np


class Solution:
    def fib(self, n: int) -&gt; int:
        factor = np.asmatrix([(1, 1), (1, 0)], np.dtype("O"))
        res = np.asmatrix([(1, 0)], np.dtype("O"))
        while n:
            if n &amp; 1:
                res = res * factor
            factor = factor * factor
            n &gt;&gt;= 1
        return res[0, 1]
</code></pre>
<h4 id="java-21"><a class="header" href="#java-21">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int fib(int n) {
        int[][] a = {{1, 1}, {1, 0}};
        return pow(a, n)[0][1];
    }

    private int[][] mul(int[][] a, int[][] b) {
        int m = a.length, n = b[0].length;
        int[][] c = new int[m][n];
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                for (int k = 0; k &lt; b.length; ++k) {
                    c[i][j] = c[i][j] + a[i][k] * b[k][j];
                }
            }
        }
        return c;
    }

    private int[][] pow(int[][] a, int n) {
        int[][] res = {{1, 0}};
        while (n &gt; 0) {
            if ((n &amp; 1) == 1) {
                res = mul(res, a);
            }
            a = mul(a, a);
            n &gt;&gt;= 1;
        }
        return res;
    }
}
</code></pre>
<h4 id="c-27"><a class="header" href="#c-27">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int fib(int n) {
        vector&lt;vector&lt;int&gt;&gt; a = {{1, 1}, {1, 0}};
        return qpow(a, n)[0][1];
    }

    vector&lt;vector&lt;int&gt;&gt; mul(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;vector&lt;int&gt;&gt;&amp; b) {
        int m = a.size(), n = b[0].size();
        vector&lt;vector&lt;int&gt;&gt; c(m, vector&lt;int&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                for (int k = 0; k &lt; b.size(); ++k) {
                    c[i][j] = c[i][j] + a[i][k] * b[k][j];
                }
            }
        }
        return c;
    }

    vector&lt;vector&lt;int&gt;&gt; qpow(vector&lt;vector&lt;int&gt;&gt;&amp; a, int n) {
        vector&lt;vector&lt;int&gt;&gt; res = {{1, 0}};
        while (n) {
            if (n &amp; 1) {
                res = mul(res, a);
            }
            a = mul(a, a);
            n &gt;&gt;= 1;
        }
        return res;
    }
};
</code></pre>
<h4 id="go-21"><a class="header" href="#go-21">Go</a></h4>
<pre><code class="language-go">func fib(n int) int {
	a := [][]int{{1, 1}, {1, 0}}
	return pow(a, n)[0][1]
}

func mul(a, b [][]int) [][]int {
	m, n := len(a), len(b[0])
	c := make([][]int, m)
	for i := range c {
		c[i] = make([]int, n)
	}
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			for k := 0; k &lt; len(b); k++ {
				c[i][j] = c[i][j] + a[i][k]*b[k][j]
			}
		}
	}
	return c
}

func pow(a [][]int, n int) [][]int {
	res := [][]int{{1, 0}}
	for n &gt; 0 {
		if n&amp;1 == 1 {
			res = mul(res, a)
		}
		a = mul(a, a)
		n &gt;&gt;= 1
	}
	return res
}
</code></pre>
<h4 id="typescript-27"><a class="header" href="#typescript-27">TypeScript</a></h4>
<pre><code class="language-ts">function fib(n: number): number {
    const a: number[][] = [
        [1, 1],
        [1, 0],
    ];
    return pow(a, n)[0][1];
}

function mul(a: number[][], b: number[][]): number[][] {
    const [m, n] = [a.length, b[0].length];
    const c = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; 0));
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            for (let k = 0; k &lt; b.length; ++k) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return c;
}

function pow(a: number[][], n: number): number[][] {
    let res = [[1, 0]];
    while (n) {
        if (n &amp; 1) {
            res = mul(res, a);
        }
        a = mul(a, a);
        n &gt;&gt;= 1;
    }
    return res;
}
</code></pre>
<h4 id="rust-14"><a class="header" href="#rust-14">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn fib(n: i32) -&gt; i32 {
        let a = vec![vec![1, 1], vec![1, 0]];
        pow(a, n as usize)[0][1]
    }
}

fn mul(a: Vec&lt;Vec&lt;i32&gt;&gt;, b: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let m = a.len();
    let n = b[0].len();
    let mut c = vec![vec![0; n]; m];

    for i in 0..m {
        for j in 0..n {
            for k in 0..b.len() {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    c
}

fn pow(mut a: Vec&lt;Vec&lt;i32&gt;&gt;, mut n: usize) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut res = vec![vec![1, 0], vec![0, 1]];

    while n &gt; 0 {
        if n &amp; 1 == 1 {
            res = mul(res, a.clone());
        }
        a = mul(a.clone(), a);
        n &gt;&gt;= 1;
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-18"><a class="header" href="#javascript-18">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number} n
 * @return {number}
 */
var fib = function (n) {
    const a = [
        [1, 1],
        [1, 0],
    ];
    return pow(a, n)[0][1];
};

function mul(a, b) {
    const m = a.length,
        n = b[0].length;
    const c = Array.from({ length: m }, () =&gt; Array(n).fill(0));
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            for (let k = 0; k &lt; b.length; ++k) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return c;
}

function pow(a, n) {
    let res = [
        [1, 0],
        [0, 1],
    ];
    while (n &gt; 0) {
        if (n &amp; 1) {
            res = mul(res, a);
        }
        a = mul(a, a);
        n &gt;&gt;= 1;
    }
    return res;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class FibonacciNumber {

    // 1. Recursive solution without memoization
	public static int fib1(int n) {
		return f1(n);
	}

	public static int f1(int i) {
		if (i == 0) {
			return 0;
		}
		if (i == 1) {
			return 1;
		}
		return f1(i - 1) + f1(i - 2);
	}

    // 2. Recursive solution with memoization
	public static int fib2(int n) {
		int[] dp = new int[n + 1];
		Arrays.fill(dp, -1);
		return f2(n, dp);
	}

	public static int f2(int i, int[] dp) {
		if (i == 0) {
			return 0;
		}
		if (i == 1) {
			return 1;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		int ans = f2(i - 1, dp) + f2(i - 2, dp);
		dp[i] = ans;
		return ans;
	}

    // Iterative solution (state transition)
	public static int fib3(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		int[] dp = new int[n + 1];
		dp[1] = 1;
		for (int i = 2; i &lt;= n; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[n];
	}

    // Interative solution with space optimization
	public static int fib4(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		int lastLast = 0, last = 1;
		for (int i = 2, cur; i &lt;= n; i++) {
			cur = lastLast + last;
			lastLast = last;
			last = cur;
		}
		return last;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="minimum-cost-for-tickets"><a class="header" href="#minimum-cost-for-tickets">Minimum Cost for Tickets</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0983.Minimum%20Cost%20For%20Tickets/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="983-minimum-cost-for-tickets"><a class="header" href="#983-minimum-cost-for-tickets"><a href="https://leetcode.com/problems/minimum-cost-for-tickets">983. Minimum Cost For Tickets</a></a></h1>
<p><a href="dynamic-programming//solution/0900-0999/0983.Minimum%20Cost%20For%20Tickets/README.html">中文文档</a></p>
<h2 id="description-16"><a class="header" href="#description-16">Description</a></h2>
<!-- description:start -->
<p>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array <code>days</code>. Each day is an integer from <code>1</code> to <code>365</code>.</p>
<p>Train tickets are sold in <strong>three different ways</strong>:</p>
<ul>
	<li>a <strong>1-day</strong> pass is sold for <code>costs[0]</code> dollars,</li>
	<li>a <strong>7-day</strong> pass is sold for <code>costs[1]</code> dollars, and</li>
	<li>a <strong>30-day</strong> pass is sold for <code>costs[2]</code> dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.</p>
<ul>
	<li>For example, if we get a <strong>7-day</strong> pass on day <code>2</code>, then we can travel for <code>7</code> days: <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, and <code>8</code>.</li>
</ul>
<p>Return <em>the minimum number of dollars you need to travel every day in the given list of days</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> days = [1,4,6,7,8,20], costs = [2,7,15]
<strong>Output:</strong> 11
<strong>Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
<strong>Output:</strong> 17
<strong>Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= days.length &lt;= 365</code></li>
	<li><code>1 &lt;= days[i] &lt;= 365</code></li>
	<li><code>days</code> is in strictly increasing order.</li>
	<li><code>costs.length == 3</code></li>
	<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-16"><a class="header" href="#solutions-16">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-memoization-search--binary-search"><a class="header" href="#solution-1-memoization-search--binary-search">Solution 1: Memoization Search + Binary Search</a></h3>
<p>We define a function $\textit{dfs(i)}$, which represents the minimum cost required from the $i$-th trip to the last trip. Thus, the answer is $\textit{dfs(0)}$.</p>
<p>The execution process of the function $\textit{dfs(i)}$ is as follows:</p>
<ul>
<li>If $i \geq n$, it means all trips have ended, return $0$;</li>
<li>Otherwise, we need to consider three types of purchases: buying a 1-day pass, buying a 7-day pass, and buying a 30-day pass. We calculate the cost for these three purchasing methods separately and use binary search to find the index $j$ of the next trip, then recursively call $\textit{dfs(j)}$, and finally return the minimum cost among these three purchasing methods.</li>
</ul>
<p>To avoid repeated calculations, we use memoization search to save the results that have already been calculated.</p>
<p>The time complexity is $O(n \times \log n)$, and the space complexity is $O(n)$. Here, $n$ represents the number of trips.</p>
<!-- tabs:start -->
<h4 id="python3-22"><a class="header" href="#python3-22">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int:
        @cache
        def dfs(i: int) -&gt; int:
            if i &gt;= n:
                return 0
            ans = inf
            for c, v in zip(costs, valid):
                j = bisect_left(days, days[i] + v)
                ans = min(ans, c + dfs(j))
            return ans

        n = len(days)
        valid = [1, 7, 30]
        return dfs(0)
</code></pre>
<h4 id="java-22"><a class="header" href="#java-22">Java</a></h4>
<pre><code class="language-java">class Solution {
    private final int[] valid = {1, 7, 30};
    private int[] days;
    private int[] costs;
    private Integer[] f;
    private int n;

    public int mincostTickets(int[] days, int[] costs) {
        n = days.length;
        f = new Integer[n];
        this.days = days;
        this.costs = costs;
        return dfs(0);
    }

    private int dfs(int i) {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i] != null) {
            return f[i];
        }
        f[i] = Integer.MAX_VALUE;
        for (int k = 0; k &lt; 3; ++k) {
            int j = Arrays.binarySearch(days, days[i] + valid[k]);
            j = j &lt; 0 ? -j - 1 : j;
            f[i] = Math.min(f[i], dfs(j) + costs[k]);
        }
        return f[i];
    }
}
</code></pre>
<h4 id="c-28"><a class="header" href="#c-28">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) {
        int valid[3] = {1, 7, 30};
        int n = days.size();
        int f[n];
        memset(f, 0, sizeof(f));
        function&lt;int(int)&gt; dfs = [&amp;](int i) {
            if (i &gt;= n) {
                return 0;
            }
            if (f[i]) {
                return f[i];
            }
            f[i] = INT_MAX;
            for (int k = 0; k &lt; 3; ++k) {
                int j = lower_bound(days.begin(), days.end(), days[i] + valid[k]) - days.begin();
                f[i] = min(f[i], dfs(j) + costs[k]);
            }
            return f[i];
        };
        return dfs(0);
    }
};
</code></pre>
<h4 id="go-22"><a class="header" href="#go-22">Go</a></h4>
<pre><code class="language-go">func mincostTickets(days []int, costs []int) int {
	valid := [3]int{1, 7, 30}
	n := len(days)
	f := make([]int, n)
	var dfs func(int) int
	dfs = func(i int) int {
		if i &gt;= n {
			return 0
		}
		if f[i] &gt; 0 {
			return f[i]
		}
		f[i] = 1 &lt;&lt; 30
		for k := 0; k &lt; 3; k++ {
			j := sort.SearchInts(days, days[i]+valid[k])
			f[i] = min(f[i], dfs(j)+costs[k])
		}
		return f[i]
	}
	return dfs(0)
}
</code></pre>
<h4 id="typescript-28"><a class="header" href="#typescript-28">TypeScript</a></h4>
<pre><code class="language-ts">function mincostTickets(days: number[], costs: number[]): number {
    const n = days.length;
    const f: number[] = Array(n).fill(0);
    const valid: number[] = [1, 7, 30];
    const search = (x: number): number =&gt; {
        let [l, r] = [0, n];
        while (l &lt; r) {
            const mid = (l + r) &gt;&gt; 1;
            if (days[mid] &gt;= x) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    };
    const dfs = (i: number): number =&gt; {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i]) {
            return f[i];
        }
        f[i] = Infinity;
        for (let k = 0; k &lt; 3; ++k) {
            const j = search(days[i] + valid[k]);
            f[i] = Math.min(f[i], dfs(j) + costs[k]);
        }
        return f[i];
    };
    return dfs(0);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-dynamic-programming"><a class="header" href="#solution-2-dynamic-programming">Solution 2: Dynamic Programming</a></h3>
<p>Let's denote the last day in the $\textit{days}$ array as $m$. We can define an array $f$ of length $m + 1$, where $f[i]$ represents the minimum cost from day $1$ to day $i$.</p>
<p>We can calculate the value of $f[i]$ in increasing order of the dates in the $\textit{days}$ array, starting from day $1$. If day $i$ is a travel day, we can consider three purchasing options: buying a 1-day pass, buying a 7-day pass, and buying a 30-day pass. We calculate the cost for these three purchasing methods separately and take the minimum cost among these three as the value of $f[i]$. If day $i$ is not a travel day, then $f[i] = f[i - 1]$.</p>
<p>The final answer is $f[m]$.</p>
<p>The time complexity is $O(m)$, and the space complexity is $O(m)$. Here, $m$ represents the last day of travel.</p>
<!-- tabs:start -->
<h4 id="python3-23"><a class="header" href="#python3-23">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int:
        m = days[-1]
        f = [0] * (m + 1)
        valid = [1, 7, 30]
        j = 0
        for i in range(1, m + 1):
            if i == days[j]:
                f[i] = inf
                for c, v in zip(costs, valid):
                    f[i] = min(f[i], f[max(0, i - v)] + c)
                j += 1
            else:
                f[i] = f[i - 1]
        return f[m]
</code></pre>
<h4 id="java-23"><a class="header" href="#java-23">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        int m = days[days.length - 1];
        int[] f = new int[m + 1];
        final int[] valid = {1, 7, 30};
        for (int i = 1, j = 0; i &lt;= m; ++i) {
            if (i == days[j]) {
                f[i] = Integer.MAX_VALUE;
                for (int k = 0; k &lt; 3; ++k) {
                    int c = costs[k], v = valid[k];
                    f[i] = Math.min(f[i], f[Math.max(0, i - v)] + c);
                }
                ++j;
            } else {
                f[i] = f[i - 1];
            }
        }
        return f[m];
    }
}
</code></pre>
<h4 id="c-29"><a class="header" href="#c-29">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) {
        int m = days.back();
        int f[m + 1];
        f[0] = 0;
        int valid[3] = {1, 7, 30};
        for (int i = 1, j = 0; i &lt;= m; ++i) {
            if (i == days[j]) {
                f[i] = INT_MAX;
                for (int k = 0; k &lt; 3; ++k) {
                    int c = costs[k], v = valid[k];
                    f[i] = min(f[i], f[max(0, i - v)] + c);
                }
                ++j;
            } else {
                f[i] = f[i - 1];
            }
        }
        return f[m];
    }
};
</code></pre>
<h4 id="go-23"><a class="header" href="#go-23">Go</a></h4>
<pre><code class="language-go">func mincostTickets(days []int, costs []int) int {
	m := days[len(days)-1]
	f := make([]int, m+1)
	valid := [3]int{1, 7, 30}
	for i, j := 1, 0; i &lt;= m; i++ {
		if i == days[j] {
			f[i] = 1 &lt;&lt; 30
			for k, v := range valid {
				c := costs[k]
				f[i] = min(f[i], f[max(0, i-v)]+c)
			}
			j++
		} else {
			f[i] = f[i-1]
		}
	}
	return f[m]
}
</code></pre>
<h4 id="typescript-29"><a class="header" href="#typescript-29">TypeScript</a></h4>
<pre><code class="language-ts">function mincostTickets(days: number[], costs: number[]): number {
    const m = days.at(-1)!;
    const f: number[] = Array(m).fill(0);
    const valid: number[] = [1, 7, 30];
    for (let i = 1, j = 0; i &lt;= m; ++i) {
        if (i === days[j]) {
            f[i] = Infinity;
            for (let k = 0; k &lt; 3; ++k) {
                const [c, v] = [costs[k], valid[k]];
                f[i] = Math.min(f[i], f[Math.max(0, i - v)] + c);
            }
            ++j;
        } else {
            f[i] = f[i - 1];
        }
    }
    return f[m];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class MinimumCostForTickets {

	// global variable, accessible from all methods
	public static int[] durations = { 1, 7, 30 };

	// 1. brute-force solution
	public static int mincostTickets1(int[] days, int[] costs) {
		return f1(days, costs, 0);
	}

	// compute the minimum cost starting from day i
	public static int f1(int[] days, int[] costs, int i) {
		if (i == days.length) {
			// no more trips
			return 0;
		}
		int ans = Integer.MAX_VALUE;
		for (int k = 0, j = i; k &lt; 3; k++) {
			while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
				j++; // Is the days[j] covered by the durations[k] ticket purchased at days[i]?
			}
			ans = Math.min(ans, costs[k] + f1(days, costs, j));
		}
		return ans;
	}

	// 2. recursion with memoization
	public static int mincostTickets2(int[] days, int[] costs) {
		int[] dp = new int[days.length];
		for (int i = 0; i &lt; days.length; i++) {
			dp[i] = Integer.MAX_VALUE;
		}
		return f2(days, costs, 0, dp);
	}

	// int[] dp is the memo table
	public static int f2(int[] days, int[] costs, int i, int[] dp) {
		if (i == days.length) {
			return 0;
		}
		if (dp[i] != Integer.MAX_VALUE) {
			return dp[i];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = 0, j = i; k &lt; 3; k++) {
			while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
				j++;
			}
			ans = Math.min(ans, costs[k] + f2(days, costs, j, dp));
		}
		dp[i] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int MAXN = 366;

	public static int[] dp = new int[MAXN];

	public static int mincostTickets3(int[] days, int[] costs) {
		int n = days.length;
		Arrays.fill(dp, 0, n + 1, Integer.MAX_VALUE);
		dp[n] = 0;
		for (int i = n - 1; i &gt;= 0; i--) {
			for (int k = 0, j = i; k &lt; 3; k++) {
				while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
					j++;
				}
				dp[i] = Math.min(dp[i], costs[k] + dp[j]);
			}
		}
		return dp[0];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=2053">
    </iframe>
</details>
<h2 id="decode-ways"><a class="header" href="#decode-ways">Decode Ways</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0000-0099/0091.Decode%20Ways/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="91-decode-ways"><a class="header" href="#91-decode-ways"><a href="https://leetcode.com/problems/decode-ways">91. Decode Ways</a></a></h1>
<p><a href="dynamic-programming//solution/0000-0099/0091.Decode%20Ways/README.html">中文文档</a></p>
<h2 id="description-17"><a class="header" href="#description-17">Description</a></h2>
<!-- description:start -->
<p>You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:</p>
<p><code>&quot;1&quot; -&gt; &#39;A&#39;<br />
&quot;2&quot; -&gt; &#39;B&#39;<br />
...<br />
&quot;25&quot; -&gt; &#39;Y&#39;<br />
&quot;26&quot; -&gt; &#39;Z&#39;</code></p>
<p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code>&quot;2&quot;</code> and <code>&quot;5&quot;</code> vs <code>&quot;25&quot;</code>).</p>
<p>For example, <code>&quot;11106&quot;</code> can be decoded into:</p>
<ul>
	<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1, 1, 10, 6)</code></li>
	<li><code>&quot;KJF&quot;</code> with the grouping <code>(11, 10, 6)</code></li>
	<li>The grouping <code>(1, 11, 06)</code> is invalid because <code>&quot;06&quot;</code> is not a valid code (only <code>&quot;6&quot;</code> is valid).</li>
</ul>
<p>Note: there may be strings that are impossible to decode.<br />
<br />
Given a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code>0</code>.</p>
<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;12&quot;</span></p>
<p><strong>Output:</strong> <span class="example-io">2</span></p>
<p><strong>Explanation:</strong></p>
<p>&quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>
</div>
<p><strong class="example">Example 2:</strong></p>
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;226&quot;</span></p>
<p><strong>Output:</strong> <span class="example-io">3</span></p>
<p><strong>Explanation:</strong></p>
<p>&quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</p>
</div>
<p><strong class="example">Example 3:</strong></p>
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;06&quot;</span></p>
<p><strong>Output:</strong> <span class="example-io">0</span></p>
<p><strong>Explanation:</strong></p>
<p>&quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;). In this case, the string is not a valid encoding, so return 0.</p>
</div>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> contains only digits and may contain leading zero(s).</li>
</ul>
<!-- description:end -->
<h2 id="solutions-17"><a class="header" href="#solutions-17">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming"><a class="header" href="#solution-1-dynamic-programming">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i]$ to represent the number of decoding methods for the first $i$ characters of the string. Initially, $f[0]=1$, and the rest $f[i]=0$.</p>
<p>Consider how $f[i]$ transitions.</p>
<ul>
<li>If the $i$th character (i.e., $s[i-1]$) forms a code on its own, it corresponds to one decoding method, i.e., $f[i]=f[i-1]$. The premise is $s[i-1] \neq 0$.</li>
<li>If the string formed by the $i-1$th character and the $i$th character is within the range $[1,26]$, then they can be treated as a whole, corresponding to one decoding method, i.e., $f[i] = f[i] + f[i-2]$. The premise is $s[i-2] \neq 0$, and $s[i-2]s[i-1]$ is within the range $[1,26]$.</li>
</ul>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p>
<!-- tabs:start -->
<h4 id="python3-24"><a class="header" href="#python3-24">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        n = len(s)
        f = [1] + [0] * n
        for i, c in enumerate(s, 1):
            if c != "0":
                f[i] = f[i - 1]
            if i &gt; 1 and s[i - 2] != "0" and int(s[i - 2 : i]) &lt;= 26:
                f[i] += f[i - 2]
        return f[n]
</code></pre>
<h4 id="java-24"><a class="header" href="#java-24">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            if (s.charAt(i - 1) != '0') {
                f[i] = f[i - 1];
            }
            if (i &gt; 1 &amp;&amp; s.charAt(i - 2) != '0' &amp;&amp; Integer.valueOf(s.substring(i - 2, i)) &lt;= 26) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
}
</code></pre>
<h4 id="c-30"><a class="header" href="#c-30">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        int f[n + 1];
        memset(f, 0, sizeof(f));
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            if (s[i - 1] != '0') {
                f[i] = f[i - 1];
            }
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6')) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
</code></pre>
<h4 id="go-24"><a class="header" href="#go-24">Go</a></h4>
<pre><code class="language-go">func numDecodings(s string) int {
	n := len(s)
	f := make([]int, n+1)
	f[0] = 1
	for i := 1; i &lt;= n; i++ {
		if s[i-1] != '0' {
			f[i] = f[i-1]
		}
		if i &gt; 1 &amp;&amp; (s[i-2] == '1' || (s[i-2] == '2' &amp;&amp; s[i-1] &lt;= '6')) {
			f[i] += f[i-2]
		}
	}
	return f[n]
}
</code></pre>
<h4 id="typescript-30"><a class="header" href="#typescript-30">TypeScript</a></h4>
<pre><code class="language-ts">function numDecodings(s: string): number {
    const n = s.length;
    const f: number[] = new Array(n + 1).fill(0);
    f[0] = 1;
    for (let i = 1; i &lt;= n; ++i) {
        if (s[i - 1] !== '0') {
            f[i] = f[i - 1];
        }
        if (i &gt; 1 &amp;&amp; (s[i - 2] === '1' || (s[i - 2] === '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
            f[i] += f[i - 2];
        }
    }
    return f[n];
}
</code></pre>
<h4 id="c-31"><a class="header" href="#c-31">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int NumDecodings(string s) {
        int n = s.Length;
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            if (s[i - 1] != '0') {
                f[i] = f[i - 1];
            }
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
}
</code></pre>
<!-- tabs:end -->
<p>We notice that the state $f[i]$ is only related to the states $f[i-1]$ and $f[i-2]$, and is irrelevant to other states. Therefore, we can use two variables to replace these two states, reducing the original space complexity from $O(n)$ to $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-25"><a class="header" href="#python3-25">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        f, g = 0, 1
        for i, c in enumerate(s, 1):
            h = g if c != "0" else 0
            if i &gt; 1 and s[i - 2] != "0" and int(s[i - 2 : i]) &lt;= 26:
                h += f
            f, g = g, h
        return g
</code></pre>
<h4 id="java-25"><a class="header" href="#java-25">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int f = 0, g = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int h = s.charAt(i - 1) != '0' ? g : 0;
            if (i &gt; 1 &amp;&amp; s.charAt(i - 2) != '0' &amp;&amp; Integer.valueOf(s.substring(i - 2, i)) &lt;= 26) {
                h += f;
            }
            f = g;
            g = h;
        }
        return g;
    }
}
</code></pre>
<h4 id="c-32"><a class="header" href="#c-32">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        int f = 0, g = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int h = s[i - 1] != '0' ? g : 0;
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
                h += f;
            }
            f = g;
            g = h;
        }
        return g;
    }
};
</code></pre>
<h4 id="go-25"><a class="header" href="#go-25">Go</a></h4>
<pre><code class="language-go">func numDecodings(s string) int {
	n := len(s)
	f, g := 0, 1
	for i := 1; i &lt;= n; i++ {
		h := 0
		if s[i-1] != '0' {
			h = g
		}
		if i &gt; 1 &amp;&amp; (s[i-2] == '1' || (s[i-2] == '2' &amp;&amp; s[i-1] &lt;= '6')) {
			h += f
		}
		f, g = g, h
	}
	return g
}
</code></pre>
<h4 id="typescript-31"><a class="header" href="#typescript-31">TypeScript</a></h4>
<pre><code class="language-ts">function numDecodings(s: string): number {
    const n = s.length;
    let [f, g] = [0, 1];
    for (let i = 1; i &lt;= n; ++i) {
        let h = s[i - 1] !== '0' ? g : 0;
        if (i &gt; 1 &amp;&amp; (s[i - 2] === '1' || (s[i - 2] === '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
            h += f;
        }
        [f, g] = [g, h];
    }
    return g;
}
</code></pre>
<h4 id="c-33"><a class="header" href="#c-33">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int NumDecodings(string s) {
        int n = s.Length;
        int f = 0, g = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int h = s[i - 1] != '0' ? g : 0;
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
                h += f;
            }
            f = g;
            g = h;
        }
        return g;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class DecodeWays {

	// 1. Recursive brute-force solution
	public static int numDecodings1(String s) {
		return f1(s.toCharArray(), 0);
	}

	// compute decoding ways for substring s[i..]
	public static int f1(char[] s, int i) {
		if (i == s.length) {
			return 1;
		}
		int ans;
		if (s[i] == '0') {
			ans = 0;
		} else {
			ans = f1(s, i + 1);
			if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
				ans += f1(s, i + 2);
			}
		}
		return ans;
	}

	// 2. recursive solution with memoization
	public static int numDecodings2(String s) {
		int[] dp = new int[s.length()];
		Arrays.fill(dp, -1);
		return f2(s.toCharArray(), 0, dp);
	}

	public static int f2(char[] s, int i, int[] dp) {
		if (i == s.length) {
			return 1;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		int ans;
		if (s[i] == '0') {
			ans = 0;
		} else {
			ans = f2(s, i + 1, dp);
			if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
				ans += f2(s, i + 2, dp);
			}
		}
		dp[i] = ans;
		return ans;
	}

	// 3. bottom-up iterative solution
	public static int numDecodings3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[] dp = new int[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') {
				dp[i] = 0;
			} else {
				dp[i] = dp[i + 1];
				if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
					dp[i] += dp[i + 2];
				}
			}
		}
		return dp[0];
	}

	// 4. iterative solution + space optimization
	public static int numDecodings4(String s) {
		// dp[i+1]
		int next = 1;
		// dp[i+2]
		int nextNext = 0;
		for (int i = s.length() - 1, cur; i &gt;= 0; i--) {
			if (s.charAt(i) == '0') {
				cur = 0;
			} else {
				cur = next;
				if (i + 1 &lt; s.length() &amp;&amp; ((s.charAt(i) - '0') * 10 + s.charAt(i + 1) - '0') &lt;= 26) {
					cur += nextNext;
				}
			}
			nextNext = next;
			next = cur;
		}
		return next;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=4249">
    </iframe>
</details>
<h2 id="decode-ways-ii"><a class="header" href="#decode-ways-ii">Decode Ways II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0639.Decode%20Ways%20II/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="639-decode-ways-ii"><a class="header" href="#639-decode-ways-ii"><a href="https://leetcode.com/problems/decode-ways-ii">639. Decode Ways II</a></a></h1>
<p><a href="dynamic-programming//solution/0600-0699/0639.Decode%20Ways%20II/README.html">中文文档</a></p>
<h2 id="description-18"><a class="header" href="#description-18">Description</a></h2>
<!-- description:start -->
<p>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p>
<pre>
&#39;A&#39; -&gt; &quot;1&quot;
&#39;B&#39; -&gt; &quot;2&quot;
...
&#39;Z&#39; -&gt; &quot;26&quot;
</pre>
<p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p>
<ul>
	<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li>
	<li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li>
</ul>
<p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p>
<p><strong>In addition</strong> to the mapping above, an encoded message may contain the <code>&#39;*&#39;</code> character, which can represent any digit from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code> (<code>&#39;0&#39;</code> is excluded). For example, the encoded message <code>&quot;1*&quot;</code> may represent any of the encoded messages <code>&quot;11&quot;</code>, <code>&quot;12&quot;</code>, <code>&quot;13&quot;</code>, <code>&quot;14&quot;</code>, <code>&quot;15&quot;</code>, <code>&quot;16&quot;</code>, <code>&quot;17&quot;</code>, <code>&quot;18&quot;</code>, or <code>&quot;19&quot;</code>. Decoding <code>&quot;1*&quot;</code> is equivalent to decoding <strong>any</strong> of the encoded messages it can represent.</p>
<p>Given a string <code>s</code> consisting of digits and <code>&#39;*&#39;</code> characters, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p>
<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;*&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, or &quot;9&quot;.
Each of these can be decoded to the strings &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, and &quot;I&quot; respectively.
Hence, there are a total of 9 ways to decode &quot;*&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;1*&quot;
<strong>Output:</strong> 18
<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, or &quot;19&quot;.
Each of these encoded messages have 2 ways to be decoded (e.g. &quot;11&quot; can be decoded to &quot;AA&quot; or &quot;K&quot;).
Hence, there are a total of 9 * 2 = 18 ways to decode &quot;1*&quot;.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;2*&quot;
<strong>Output:</strong> 15
<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, or &quot;29&quot;.
&quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, and &quot;26&quot; have 2 ways of being decoded, but &quot;27&quot;, &quot;28&quot;, and &quot;29&quot; only have 1 way.
Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode &quot;2*&quot;.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is a digit or <code>&#39;*&#39;</code>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-18"><a class="header" href="#solutions-18">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-3"><a class="header" href="#solution-1-3">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-26"><a class="header" href="#python3-26">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        mod = int(1e9 + 7)
        n = len(s)

        # dp[i - 2], dp[i - 1], dp[i]
        a, b, c = 0, 1, 0
        for i in range(1, n + 1):
            # 1 digit
            if s[i - 1] == "*":
                c = 9 * b % mod
            elif s[i - 1] != "0":
                c = b
            else:
                c = 0

            # 2 digits
            if i &gt; 1:
                if s[i - 2] == "*" and s[i - 1] == "*":
                    c = (c + 15 * a) % mod
                elif s[i - 2] == "*":
                    if s[i - 1] &gt; "6":
                        c = (c + a) % mod
                    else:
                        c = (c + 2 * a) % mod
                elif s[i - 1] == "*":
                    if s[i - 2] == "1":
                        c = (c + 9 * a) % mod
                    elif s[i - 2] == "2":
                        c = (c + 6 * a) % mod
                elif (
                    s[i - 2] != "0"
                    and (ord(s[i - 2]) - ord("0")) * 10 + ord(s[i - 1]) - ord("0") &lt;= 26
                ):
                    c = (c + a) % mod

            a, b = b, c

        return c
</code></pre>
<h4 id="java-26"><a class="header" href="#java-26">Java</a></h4>
<pre><code class="language-java">class Solution {

    private static final int MOD = 1000000007;

    public int numDecodings(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();

        // dp[i - 2], dp[i - 1], dp[i]
        long a = 0, b = 1, c = 0;
        for (int i = 1; i &lt;= n; i++) {
            // 1 digit
            if (cs[i - 1] == '*') {
                c = 9 * b % MOD;
            } else if (cs[i - 1] != '0') {
                c = b;
            } else {
                c = 0;
            }

            // 2 digits
            if (i &gt; 1) {
                if (cs[i - 2] == '*' &amp;&amp; cs[i - 1] == '*') {
                    c = (c + 15 * a) % MOD;
                } else if (cs[i - 2] == '*') {
                    if (cs[i - 1] &gt; '6') {
                        c = (c + a) % MOD;
                    } else {
                        c = (c + 2 * a) % MOD;
                    }
                } else if (cs[i - 1] == '*') {
                    if (cs[i - 2] == '1') {
                        c = (c + 9 * a) % MOD;
                    } else if (cs[i - 2] == '2') {
                        c = (c + 6 * a) % MOD;
                    }
                } else if (cs[i - 2] != '0' &amp;&amp; (cs[i - 2] - '0') * 10 + cs[i - 1] - '0' &lt;= 26) {
                    c = (c + a) % MOD;
                }
            }

            a = b;
            b = c;
        }

        return (int) c;
    }
}
</code></pre>
<h4 id="go-26"><a class="header" href="#go-26">Go</a></h4>
<pre><code class="language-go">const mod int = 1e9 + 7

func numDecodings(s string) int {
	n := len(s)

	// dp[i - 2], dp[i - 1], dp[i]
	a, b, c := 0, 1, 0
	for i := 1; i &lt;= n; i++ {
		// 1 digit
		if s[i-1] == '*' {
			c = 9 * b % mod
		} else if s[i-1] != '0' {
			c = b
		} else {
			c = 0
		}

		// 2 digits
		if i &gt; 1 {
			if s[i-2] == '*' &amp;&amp; s[i-1] == '*' {
				c = (c + 15*a) % mod
			} else if s[i-2] == '*' {
				if s[i-1] &gt; '6' {
					c = (c + a) % mod
				} else {
					c = (c + 2*a) % mod
				}
			} else if s[i-1] == '*' {
				if s[i-2] == '1' {
					c = (c + 9*a) % mod
				} else if s[i-2] == '2' {
					c = (c + 6*a) % mod
				}
			} else if s[i-2] != '0' &amp;&amp; (s[i-2]-'0')*10+s[i-1]-'0' &lt;= 26 {
				c = (c + a) % mod
			}
		}

		a, b = b, c
	}
	return c
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class DecodeWaysII {

	// 1. brute-force solution without modulus (incorrect answer)
	public static int numDecodings1(String str) {
		return f1(str.toCharArray(), 0);
	}

	// compute decode ways for substring s[i..]
	public static int f1(char[] s, int i) {
		if (i == s.length) {
			return 1;
		}
		if (s[i] == '0') {
			return 0;
		}
		// s[i] != '0'
		// decode s[i] only
		int ans = f1(s, i + 1) * (s[i] == '*' ? 9 : 1);
		// decode s[i] and s[i+1] combined
		if (i + 1 &lt; s.length) { // s[i+1] exists
			if (s[i] != '*' &amp;&amp; s[i+1] != '*') { // case 1: digit + digit
				if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
					ans += f1(s, i + 2);
				}
			} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') { // case 2: digit + '*'
				if (s[i] == '1') {
					ans += f1(s, i + 2) * 9;
				}
				if (s[i] == '2') {
					ans += f1(s, i + 2) * 6;
				}
			} else if (s[i] == '*' &amp;&amp; s[i+1] != '*') { // case 3: '*' + digit
				if (s[i + 1] &lt;= '6') {
					ans += f1(s, i + 2) * 2;
				} else {
					ans += f1(s, i + 2);
				}
			} else { // case 4: '*' + '*'
				ans += f1(s, i + 2) * 15;
			}
		}
		return ans;
	}

	// 2. recursive solution with memoization, answer modulo 10^9+7
	public static long mod = 1000000007;

	public static int numDecodings2(String str) {
		char[] s = str.toCharArray();
		long[] dp = new long[s.length];
		Arrays.fill(dp, -1);
		return (int) f2(s, 0, dp);
	}

	public static long f2(char[] s, int i, long[] dp) {
		if (i == s.length) {
			return 1;
		}
		if (s[i] == '0') {
			return 0;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		long ans = f2(s, i + 1, dp) * (s[i] == '*' ? 9 : 1); // decode s[i] only
		if (i + 1 &lt; s.length) { // decode s[i] and s[i+1] together
			if (s[i] != '*' &amp;&amp; s[i+1] != '*') {
				if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
					ans += f2(s, i + 2, dp);
				}
			} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') {
				if (s[i] == '1') {
					ans += f2(s, i + 2, dp) * 9;
				}
				if (s[i] == '2') {
					ans += f2(s, i + 2, dp) * 6;
				}
			} else if (s[i] == '*' &amp;&amp; s[i + 1] != '*') {
				if (s[i + 1] &lt;= '6') {
					ans += f2(s, i + 2, dp) * 2;
				} else {
					ans += f2(s, i + 2, dp);
				}
			} else {
				ans += f2(s, i + 2, dp) * 15;
			}
		}
		ans %= mod;
		dp[i] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int numDecodings3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		long[] dp = new long[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') continue;
			dp[i] = (s[i] == '*' ? 9 : 1) * dp[i + 1];
			if (i + 1 &lt; n) {
				if (s[i] != '*' &amp;&amp; s[i + 1] != '*') {
					if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
						dp[i] += dp[i + 2];
					}
				} else if (s[i] != '*' &amp;&amp; s[i + 1] == '*') {
					if (s[i] == '1') {
						dp[i] += dp[i + 2] * 9;
					}
					if (s[i] == '2') {
						dp[i] += dp[i + 2] * 6;
					}
				} else if (s[i] == '*' &amp;&amp; s[i + 1] != '*') {
					if (s[i + 1] &lt;= '6') {
						dp[i] += dp[i + 2] * 2;
					} else {
						dp[i] += dp[i + 2];
					}
				} else {
					dp[i] += dp[i + 2] * 15;
				}
			}
			dp[i] %= mod;
		}
		return (int) dp[0];
	}

	// 4. iterative solution with space optimization
	public static int numDecodings4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		long cur = 0, next = 1, nextNext = 0;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') continue;
			cur = (s[i] == '*' ? 9 : 1) * next;
			if (i + 1 &lt; n) {
				if (s[i] != '*' &amp;&amp; s[i+1] != '*') {
					if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
						cur += nextNext;
					}
				} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') {
					if (s[i] == '1') {
						cur += nextNext * 9;
					}
					if (s[i] == '2') {
						cur += nextNext * 6;
					}
				} else if (s[i] == '*' &amp;&amp; s[i+1] != '*') {
					if (s[i + 1] &lt;= '6') {
						cur += nextNext * 2;
					} else {
						cur += nextNext;
					}
				} else {
					cur += nextNext * 15;
				}
			}
			cur %= mod;
			nextNext = next;
			next = cur;
			cur = 0;
		}
		return (int) next;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=5985">
    </iframe>
</details>
<h2 id="ugly-number-ii"><a class="header" href="#ugly-number-ii">Ugly Number II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0264.Ugly%20Number%20II/README_EN.md
tags:
    - Hash Table
    - Math
    - Dynamic Programming
    - Heap (Priority Queue)
</code></pre>
<!-- problem:start -->
<h1 id="264-ugly-number-ii"><a class="header" href="#264-ugly-number-ii"><a href="https://leetcode.com/problems/ugly-number-ii">264. Ugly Number II</a></a></h1>
<p><a href="dynamic-programming//solution/0200-0299/0264.Ugly%20Number%20II/README.html">中文文档</a></p>
<h2 id="description-19"><a class="header" href="#description-19">Description</a></h2>
<!-- description:start -->
<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>
<p>Given an integer <code>n</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>ugly number</strong></em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 12
<strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= n &lt;= 1690</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-19"><a class="header" href="#solutions-19">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-4"><a class="header" href="#solution-1-4">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-27"><a class="header" href="#python3-27">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        h = [1]
        vis = {1}
        ans = 1
        for _ in range(n):
            ans = heappop(h)
            for v in [2, 3, 5]:
                nxt = ans * v
                if nxt not in vis:
                    vis.add(nxt)
                    heappush(h, nxt)
        return ans
</code></pre>
<h4 id="java-27"><a class="header" href="#java-27">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int nthUglyNumber(int n) {
        Set&lt;Long&gt; vis = new HashSet&lt;&gt;();
        PriorityQueue&lt;Long&gt; q = new PriorityQueue&lt;&gt;();
        int[] f = new int[] {2, 3, 5};
        q.offer(1L);
        vis.add(1L);
        long ans = 0;
        while (n-- &gt; 0) {
            ans = q.poll();
            for (int v : f) {
                long next = ans * v;
                if (vis.add(next)) {
                    q.offer(next);
                }
            }
        }
        return (int) ans;
    }
}
</code></pre>
<h4 id="c-34"><a class="header" href="#c-34">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; q;
        q.push(1l);
        unordered_set&lt;long&gt; vis{{1l}};
        long ans = 1;
        vector&lt;int&gt; f = {2, 3, 5};
        while (n--) {
            ans = q.top();
            q.pop();
            for (int&amp; v : f) {
                long nxt = ans * v;
                if (!vis.count(nxt)) {
                    vis.insert(nxt);
                    q.push(nxt);
                }
            }
        }
        return (int) ans;
    }
};
</code></pre>
<h4 id="go-27"><a class="header" href="#go-27">Go</a></h4>
<pre><code class="language-go">func nthUglyNumber(n int) int {
	h := IntHeap([]int{1})
	heap.Init(&amp;h)
	ans := 1
	vis := map[int]bool{1: true}
	for n &gt; 0 {
		ans = heap.Pop(&amp;h).(int)
		for _, v := range []int{2, 3, 5} {
			nxt := ans * v
			if !vis[nxt] {
				vis[nxt] = true
				heap.Push(&amp;h, nxt)
			}
		}
		n--
	}
	return ans
}

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *IntHeap) Push(x any) {
	*h = append(*h, x.(int))
}
func (h *IntHeap) Pop() any {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}
</code></pre>
<h4 id="javascript-19"><a class="header" href="#javascript-19">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function (n) {
    let dp = [1];
    let p2 = 0,
        p3 = 0,
        p5 = 0;
    for (let i = 1; i &lt; n; ++i) {
        const next2 = dp[p2] * 2,
            next3 = dp[p3] * 3,
            next5 = dp[p5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        if (dp[i] == next2) ++p2;
        if (dp[i] == next3) ++p3;
        if (dp[i] == next5) ++p5;
        dp.push(dp[i]);
    }
    return dp[n - 1];
};
</code></pre>
<h4 id="c-35"><a class="header" href="#c-35">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int NthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i &lt; n; ++i) {
            int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
            dp[i] = Math.Min(next2, Math.Min(next3, next5));
            if (dp[i] == next2) {
                ++p2;
            }
            if (dp[i] == next3) {
                ++p3;
            }
            if (dp[i] == next5) {
                ++p5;
            }
        }
        return dp[n - 1];
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-1"><a class="header" href="#solution-2-1">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-28"><a class="header" href="#python3-28">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp = [1] * n
        p2 = p3 = p5 = 0
        for i in range(1, n):
            next2, next3, next5 = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
            dp[i] = min(next2, next3, next5)
            if dp[i] == next2:
                p2 += 1
            if dp[i] == next3:
                p3 += 1
            if dp[i] == next5:
                p5 += 1
        return dp[-1]
</code></pre>
<h4 id="java-28"><a class="header" href="#java-28">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i &lt; n; ++i) {
            int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
            dp[i] = Math.min(next2, Math.min(next3, next5));
            if (dp[i] == next2) ++p2;
            if (dp[i] == next3) ++p3;
            if (dp[i] == next5) ++p5;
        }
        return dp[n - 1];
    }
}
</code></pre>
<h4 id="c-36"><a class="header" href="#c-36">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int nthUglyNumber(int n) {
        vector&lt;int&gt; dp(n);
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i &lt; n; ++i) {
            int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
            dp[i] = min(next2, min(next3, next5));
            if (dp[i] == next2) ++p2;
            if (dp[i] == next3) ++p3;
            if (dp[i] == next5) ++p5;
        }
        return dp[n - 1];
    }
};
</code></pre>
<h4 id="go-28"><a class="header" href="#go-28">Go</a></h4>
<pre><code class="language-go">func nthUglyNumber(n int) int {
	dp := make([]int, n)
	dp[0] = 1
	p2, p3, p5 := 0, 0, 0
	for i := 1; i &lt; n; i++ {
		next2, next3, next5 := dp[p2]*2, dp[p3]*3, dp[p5]*5
		dp[i] = min(next2, min(next3, next5))
		if dp[i] == next2 {
			p2++
		}
		if dp[i] == next3 {
			p3++
		}
		if dp[i] == next5 {
			p5++
		}
	}
	return dp[n-1]
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class UglyNumberII {

	public static int nthUglyNumber(int n) {
		int[] dp = new int[n + 1];
		dp[1] = 1;
		int i2 = 1, i3 = 1, i5 = 1, a, b, c, cur;
		for (int i = 2; i &lt;= n; i++) {
			a = dp[i2] * 2;
			b = dp[i3] * 3;
			c = dp[i5] * 5;
			cur = Math.min(Math.min(a, b), c);
			if (cur == a) {
				i2++;
			}
			if (cur == b) {
				i3++;
			}
			if (cur == c) {
				i5++;
			}
			dp[i] = cur;
		}
		return dp[n];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=7739">
    </iframe>
</details>
<h2 id="longest-valid-parentheses"><a class="header" href="#longest-valid-parentheses">Longest Valid Parentheses</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0000-0099/0032.Longest%20Valid%20Parentheses/README_EN.md
tags:
    - Stack
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="32-longest-valid-parentheses"><a class="header" href="#32-longest-valid-parentheses"><a href="https://leetcode.com/problems/longest-valid-parentheses">32. Longest Valid Parentheses</a></a></h1>
<p><a href="dynamic-programming//solution/0000-0099/0032.Longest%20Valid%20Parentheses/README.html">中文文档</a></p>
<h2 id="description-20"><a class="header" href="#description-20">Description</a></h2>
<!-- description:start -->
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, return <em>the length of the longest valid (well-formed) parentheses </em><span data-keyword="substring-nonempty"><em>substring</em></span>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;(()&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;)()())&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()()&quot;.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;&quot;
<strong>Output:</strong> 0
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>s[i]</code> is <code>&#39;(&#39;</code>, or <code>&#39;)&#39;</code>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-20"><a class="header" href="#solutions-20">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-1"><a class="header" href="#solution-1-dynamic-programming-1">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i]$ to be the length of the longest valid parentheses that ends with $s[i-1]$, and the answer is $max(f[i])$.</p>
<p>When $i \lt 2$, the length of the string is less than $2$, and there is no valid parentheses, so $f[i] = 0$.</p>
<p>When $i \ge 2$, we consider the length of the longest valid parentheses that ends with $s[i-1]$, that is, $f[i]$:</p>
<ul>
<li>If $s[i-1]$ is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ must be $0$, so $f[i] = 0$.</li>
<li>If $s[i-1]$ is a right parenthesis, there are the following two cases:
<ul>
<li>If $s[i-2]$ is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-2] + 2$.</li>
<li>If $s[i-2]$ is a right parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-1] + 2$, but we also need to consider whether $s[i-f[i-1]-2]$ is a left parenthesis. If it is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-1] + 2 + f[i-f[i-1]-2]$.</li>
</ul>
</li>
</ul>
<p>Therefore, we can get the state transition equation:</p>
<p>$$
\begin{cases}
f[i] = 0, &amp; \textit{if } s[i-1] = '(',\
f[i] = f[i-2] + 2, &amp; \textit{if } s[i-1] = ')' \textit{ and } s[i-2] = '(',\
f[i] = f[i-1] + 2 + f[i-f[i-1]-2], &amp; \textit{if } s[i-1] = ')' \textit{ and } s[i-2] = ')' \textit{ and } s[i-f[i-1]-2] = '(',\
\end{cases}
$$</p>
<p>Finally, we only need to return $max(f)$.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string.</p>
<!-- tabs:start -->
<h4 id="python3-29"><a class="header" href="#python3-29">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        n = len(s)
        f = [0] * (n + 1)
        for i, c in enumerate(s, 1):
            if c == ")":
                if i &gt; 1 and s[i - 2] == "(":
                    f[i] = f[i - 2] + 2
                else:
                    j = i - f[i - 1] - 1
                    if j and s[j - 1] == "(":
                        f[i] = f[i - 1] + 2 + f[j - 1]
        return max(f)
</code></pre>
<h4 id="java-29"><a class="header" href="#java-29">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        int ans = 0;
        for (int i = 2; i &lt;= n; ++i) {
            if (s.charAt(i - 1) == ')') {
                if (s.charAt(i - 2) == '(') {
                    f[i] = f[i - 2] + 2;
                } else {
                    int j = i - f[i - 1] - 1;
                    if (j &gt; 0 &amp;&amp; s.charAt(j - 1) == '(') {
                        f[i] = f[i - 1] + 2 + f[j - 1];
                    }
                }
                ans = Math.max(ans, f[i]);
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-37"><a class="header" href="#c-37">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        int f[n + 1];
        memset(f, 0, sizeof(f));
        for (int i = 2; i &lt;= n; ++i) {
            if (s[i - 1] == ')') {
                if (s[i - 2] == '(') {
                    f[i] = f[i - 2] + 2;
                } else {
                    int j = i - f[i - 1] - 1;
                    if (j &amp;&amp; s[j - 1] == '(') {
                        f[i] = f[i - 1] + 2 + f[j - 1];
                    }
                }
            }
        }
        return *max_element(f, f + n + 1);
    }
};
</code></pre>
<h4 id="go-29"><a class="header" href="#go-29">Go</a></h4>
<pre><code class="language-go">func longestValidParentheses(s string) int {
	n := len(s)
	f := make([]int, n+1)
	for i := 2; i &lt;= n; i++ {
		if s[i-1] == ')' {
			if s[i-2] == '(' {
				f[i] = f[i-2] + 2
			} else if j := i - f[i-1] - 1; j &gt; 0 &amp;&amp; s[j-1] == '(' {
				f[i] = f[i-1] + 2 + f[j-1]
			}
		}
	}
	return slices.Max(f)
}
</code></pre>
<h4 id="typescript-32"><a class="header" href="#typescript-32">TypeScript</a></h4>
<pre><code class="language-ts">function longestValidParentheses(s: string): number {
    const n = s.length;
    const f: number[] = new Array(n + 1).fill(0);
    for (let i = 2; i &lt;= n; ++i) {
        if (s[i - 1] === ')') {
            if (s[i - 2] === '(') {
                f[i] = f[i - 2] + 2;
            } else {
                const j = i - f[i - 1] - 1;
                if (j &amp;&amp; s[j - 1] === '(') {
                    f[i] = f[i - 1] + 2 + f[j - 1];
                }
            }
        }
    }
    return Math.max(...f);
}
</code></pre>
<h4 id="rust-15"><a class="header" href="#rust-15">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn longest_valid_parentheses(s: String) -&gt; i32 {
        let mut ans = 0;
        let mut f = vec![0; s.len() + 1];
        for i in 2..=s.len() {
            if s.chars().nth(i - 1).unwrap() == ')' {
                if s.chars().nth(i - 2).unwrap() == '(' {
                    f[i] = f[i - 2] + 2;
                } else if (i as i32) - f[i - 1] - 1 &gt; 0
                    &amp;&amp; s.chars().nth(i - (f[i - 1] as usize) - 2).unwrap() == '('
                {
                    f[i] = f[i - 1] + 2 + f[i - (f[i - 1] as usize) - 2];
                }
                ans = ans.max(f[i]);
            }
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-20"><a class="header" href="#javascript-20">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function (s) {
    const n = s.length;
    const f = new Array(n + 1).fill(0);
    for (let i = 2; i &lt;= n; ++i) {
        if (s[i - 1] === ')') {
            if (s[i - 2] === '(') {
                f[i] = f[i - 2] + 2;
            } else {
                const j = i - f[i - 1] - 1;
                if (j &amp;&amp; s[j - 1] === '(') {
                    f[i] = f[i - 1] + 2 + f[j - 1];
                }
            }
        }
    }
    return Math.max(...f);
};
</code></pre>
<h4 id="c-38"><a class="header" href="#c-38">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int LongestValidParentheses(string s) {
        int n = s.Length;
        int[] f = new int[n + 1];
        int ans = 0;
        for (int i = 2; i &lt;= n; ++i) {
            if (s[i - 1] == ')') {
                if (s[i - 2] == '(') {
                    f[i] = f[i - 2] + 2;
                } else {
                    int j = i - f[i - 1] - 1;
                    if (j &gt; 0 &amp;&amp; s[j - 1] == '(') {
                        f[i] = f[i - 1] + 2 + f[j - 1];
                    }
                }
                ans = Math.Max(ans, f[i]);
            }
        }
        return ans;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-using-stack"><a class="header" href="#solution-2-using-stack">Solution 2: Using Stack</a></h3>
<ul>
<li>Maintain a stack to store the indices of left parentheses. Initialize the bottom element of the stack with the value -1 to facilitate the calculation of the length of valid parentheses.</li>
<li>Iterate through each element of the string:
<ul>
<li>If the character is a left parenthesis, push the index of the character onto the stack.</li>
<li>If the character is a right parenthesis, pop an element from the stack to represent that we have found a valid pair of parentheses.
<ul>
<li>If the stack is empty, it means we couldn't find a left parenthesis to match the right parenthesis. In this case, push the index of the character as a new starting point.</li>
<li>If the stack is not empty, calculate the length of the valid parentheses and update it.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Summary:</p>
<p>The key to this algorithm is to maintain a stack to store the indices of left parentheses and then update the length of the valid substring of parentheses by pushing and popping elements.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string.</p>
<!-- tabs:start -->
<h4 id="python3-30"><a class="header" href="#python3-30">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        stack = [-1]
        ans = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    ans = max(ans, i - stack[-1])
        return ans
</code></pre>
<h4 id="go-30"><a class="header" href="#go-30">Go</a></h4>
<pre><code class="language-go">func longestValidParentheses(s string) int {
	ans := 0
	stack := []int{-1}
	for i, v := range s {
		if v == '(' {
			stack = append(stack, i)
		} else {
			stack = stack[:len(stack)-1]
			if len(stack) == 0 {
				stack = append(stack, i)
			} else {
				if ans &lt; i-stack[len(stack)-1] {
					ans = i - stack[len(stack)-1]
				}
			}
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-33"><a class="header" href="#typescript-33">TypeScript</a></h4>
<pre><code class="language-ts">function longestValidParentheses(s: string): number {
    let max_length: number = 0;
    const stack: number[] = [-1];
    for (let i = 0; i &lt; s.length; i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            stack.pop();

            if (stack.length === 0) {
                stack.push(i);
            } else {
                max_length = Math.max(max_length, i - stack[stack.length - 1]);
            }
        }
    }

    return max_length;
}
</code></pre>
<h4 id="rust-16"><a class="header" href="#rust-16">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn longest_valid_parentheses(s: String) -&gt; i32 {
        let mut stack = vec![-1];
        let mut res = 0;
        for i in 0..s.len() {
            if let Some('(') = s.chars().nth(i) {
                stack.push(i as i32);
            } else {
                stack.pop().unwrap();
                if stack.is_empty() {
                    stack.push(i as i32);
                } else {
                    res = std::cmp::max(res, (i as i32) - stack.last().unwrap());
                }
            }
        }
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-21"><a class="header" href="#javascript-21">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function (s) {
    let ans = 0;
    const stack = [-1];
    for (i = 0; i &lt; s.length; i++) {
        if (s.charAt(i) === '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.length === 0) {
                stack.push(i);
            } else {
                ans = Math.max(ans, i - stack[stack.length - 1]);
            }
        }
    }
    return ans;
};
</code></pre>
<h4 id="php-3"><a class="header" href="#php-3">PHP</a></h4>
<pre><code class="language-php">class Solution {
    /**
     * @param string $s
     * @return integer
     */

    function longestValidParentheses($s) {
        $stack = [];
        $maxLength = 0;

        array_push($stack, -1);
        for ($i = 0; $i &lt; strlen($s); $i++) {
            if ($s[$i] === '(') {
                array_push($stack, $i);
            } else {
                array_pop($stack);

                if (empty($stack)) {
                    array_push($stack, $i);
                } else {
                    $length = $i - end($stack);
                    $maxLength = max($maxLength, $length);
                }
            }
        }
        return $maxLength;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class LongestValidParentheses {

	public static int longestValidParentheses(String str) {
		char[] s = str.toCharArray();
		// dp[i] : the longest valid parentheses for substring ending at i 
		int[] dp = new int[s.length];
		int ans = 0, p;
		for (int i = 1; i &lt; s.length; i++) {
			if (s[i] == ')') {
				p = i - dp[i - 1] - 1;  // position of the matching left parenthese
				if (p &gt;= 0 &amp;&amp; s[p] == '(') {  // found matching left parenthese
					dp[i] = dp[i - 1] + 2 + (p - 1 &gt;= 0 ? dp[p - 1] : 0);
				}
			}
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=8666">
    </iframe>
</details>
<h2 id="unique-substring-in-wraparound-string"><a class="header" href="#unique-substring-in-wraparound-string">Unique Substring in Wraparound String</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0400-0499/0467.Unique%20Substrings%20in%20Wraparound%20String/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="467-unique-substrings-in-wraparound-string"><a class="header" href="#467-unique-substrings-in-wraparound-string"><a href="https://leetcode.com/problems/unique-substrings-in-wraparound-string">467. Unique Substrings in Wraparound String</a></a></h1>
<p><a href="dynamic-programming//solution/0400-0499/0467.Unique%20Substrings%20in%20Wraparound%20String/README.html">中文文档</a></p>
<h2 id="description-21"><a class="header" href="#description-21">Description</a></h2>
<!-- description:start -->
<p>We define the string <code>base</code> to be the infinite wraparound string of <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, so <code>base</code> will look like this:</p>
<ul>
	<li><code>&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;</code>.</li>
</ul>
<p>Given a string <code>s</code>, return <em>the number of <strong>unique non-empty substrings</strong> of </em><code>s</code><em> are present in </em><code>base</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;a&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> Only the substring &quot;a&quot; of s is in base.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;cac&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two substrings (&quot;a&quot;, &quot;c&quot;) of s in base.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;zab&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are six substrings (&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, and &quot;zab&quot;) of s in base.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-21"><a class="header" href="#solutions-21">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-2"><a class="header" href="#solution-1-dynamic-programming-2">Solution 1: Dynamic Programming</a></h3>
<p>We can define an array $f$ of length $26$, where $f[i]$ represents the length of the longest consecutive substring ending with the $i$th character. The answer is the sum of all elements in $f$.</p>
<p>We define a variable $k$ to represent the length of the longest consecutive substring ending with the current character. We iterate through the string $s$. For each character $c$, if the difference between $c$ and the previous character $s[i - 1]$ is $1$, then we increment $k$ by $1$, otherwise, we reset $k$ to $1$. Then we update $f[c]$ to be the larger value of $f[c]$ and $k$.</p>
<p>Finally, we return the sum of all elements in $f$.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(|\Sigma|)$, where $\Sigma$ is the character set, in this case, the set of lowercase letters.</p>
<!-- tabs:start -->
<h4 id="python3-31"><a class="header" href="#python3-31">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def findSubstringInWraproundString(self, s: str) -&gt; int:
        f = defaultdict(int)
        k = 0
        for i, c in enumerate(s):
            if i and (ord(c) - ord(s[i - 1])) % 26 == 1:
                k += 1
            else:
                k = 1
            f[c] = max(f[c], k)
        return sum(f.values())
</code></pre>
<h4 id="java-30"><a class="header" href="#java-30">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int findSubstringInWraproundString(String s) {
        int[] f = new int[26];
        int n = s.length();
        for (int i = 0, k = 0; i &lt; n; ++i) {
            if (i &gt; 0 &amp;&amp; (s.charAt(i) - s.charAt(i - 1) + 26) % 26 == 1) {
                ++k;
            } else {
                k = 1;
            }
            f[s.charAt(i) - 'a'] = Math.max(f[s.charAt(i) - 'a'], k);
        }
        return Arrays.stream(f).sum();
    }
}
</code></pre>
<h4 id="c-39"><a class="header" href="#c-39">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int findSubstringInWraproundString(string s) {
        int f[26]{};
        int n = s.length();
        for (int i = 0, k = 0; i &lt; n; ++i) {
            if (i &amp;&amp; (s[i] - s[i - 1] + 26) % 26 == 1) {
                ++k;
            } else {
                k = 1;
            }
            f[s[i] - 'a'] = max(f[s[i] - 'a'], k);
        }
        return accumulate(begin(f), end(f), 0);
    }
};
</code></pre>
<h4 id="go-31"><a class="header" href="#go-31">Go</a></h4>
<pre><code class="language-go">func findSubstringInWraproundString(s string) (ans int) {
	f := [26]int{}
	k := 0
	for i := range s {
		if i &gt; 0 &amp;&amp; (s[i]-s[i-1]+26)%26 == 1 {
			k++
		} else {
			k = 1
		}
		f[s[i]-'a'] = max(f[s[i]-'a'], k)
	}
	for _, x := range f {
		ans += x
	}
	return
}
</code></pre>
<h4 id="typescript-34"><a class="header" href="#typescript-34">TypeScript</a></h4>
<pre><code class="language-ts">function findSubstringInWraproundString(s: string): number {
    const idx = (c: string): number =&gt; c.charCodeAt(0) - 97;
    const f: number[] = Array(26).fill(0);
    const n = s.length;
    for (let i = 0, k = 0; i &lt; n; ++i) {
        const j = idx(s[i]);
        if (i &amp;&amp; (j - idx(s[i - 1]) + 26) % 26 === 1) {
            ++k;
        } else {
            k = 1;
        }
        f[j] = Math.max(f[j], k);
    }
    return f.reduce((acc, cur) =&gt; acc + cur, 0);
}
</code></pre>
<h4 id="rust-17"><a class="header" href="#rust-17">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn find_substring_in_wrapround_string(s: String) -&gt; i32 {
        let idx = |c: u8| -&gt; usize { (c - b'a') as usize };
        let mut f = vec![0; 26];
        let n = s.len();
        let s = s.as_bytes();
        let mut k = 0;
        for i in 0..n {
            let j = idx(s[i]);
            if i &gt; 0 &amp;&amp; ((j as i32) - (idx(s[i - 1]) as i32) + 26) % 26 == 1 {
                k += 1;
            } else {
                k = 1;
            }
            f[j] = f[j].max(k);
        }

        f.iter().sum()
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class UniqueSubstringInWraparoundString {

	public static int findSubstringInWraproundString(String str) {
		int n = str.length();
		int[] s = new int[n]; 
		// converting input str to int[] s
		// a -&gt; 0, b -&gt; 1, c -&gt; 2, ... y -&gt; 24, z -&gt; 25
		for (int i = 0; i &lt; n; i++) {
			s[i] = str.charAt(i) - 'a';
		}
		// dp[i] : the longest substring ending with character i in both str and base
		// e.g., if dp[i] = 4 (abcd, bcde, xyza, and etc), then there are 4 unique common substrings 
		int[] dp = new int[26];
		dp[s[0]] = 1;
		int len = 1, // length of the longest common substring
			cur, 	 // current character in s
			pre;	 // previous character in s
		for (int i = 1; i &lt; n; i++) {
			cur = s[i];
			pre = s[i - 1];
			if ((pre == 25 &amp;&amp; cur == 0) || pre + 1 == cur) {
				len++;
			} else {
				len = 1;
			}
			dp[cur] = Math.max(dp[cur], len);
		}
		int ans = 0;
		for (int i = 0; i &lt; 26; i++) {
			ans += dp[i];
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=10261">
    </iframe>
</details>
<h2 id="distinct-subsequences-ii"><a class="header" href="#distinct-subsequences-ii">Distinct Subsequences II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0940.Distinct%20Subsequences%20II/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="940-distinct-subsequences-ii"><a class="header" href="#940-distinct-subsequences-ii"><a href="https://leetcode.com/problems/distinct-subsequences-ii">940. Distinct Subsequences II</a></a></h1>
<p><a href="dynamic-programming//solution/0900-0999/0940.Distinct%20Subsequences%20II/README.html">中文文档</a></p>
<h2 id="description-22"><a class="header" href="#description-22">Description</a></h2>
<!-- description:start -->
<p>Given a string s, return <em>the number of <strong>distinct non-empty subsequences</strong> of</em> <code>s</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;abc&quot;
<strong>Output:</strong> 7
<strong>Explanation:</strong> The 7 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, and &quot;abc&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;aba&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> The 6 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;aa&quot;, &quot;ba&quot;, and &quot;aba&quot;.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;aaa&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 distinct subsequences are &quot;a&quot;, &quot;aa&quot; and &quot;aaa&quot;.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 2000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-22"><a class="header" href="#solutions-22">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-5"><a class="header" href="#solution-1-5">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-32"><a class="header" href="#python3-32">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10**9 + 7
        n = len(s)
        dp = [[0] * 26 for _ in range(n + 1)]
        for i, c in enumerate(s, 1):
            k = ord(c) - ord('a')
            for j in range(26):
                if j == k:
                    dp[i][j] = sum(dp[i - 1]) % mod + 1
                else:
                    dp[i][j] = dp[i - 1][j]
        return sum(dp[-1]) % mod
</code></pre>
<h4 id="java-31"><a class="header" href="#java-31">Java</a></h4>
<pre><code class="language-java">class Solution {
    private static final int MOD = (int) 1e9 + 7;

    public int distinctSubseqII(String s) {
        int[] dp = new int[26];
        for (int i = 0; i &lt; s.length(); ++i) {
            int j = s.charAt(i) - 'a';
            dp[j] = sum(dp) + 1;
        }
        return sum(dp);
    }

    private int sum(int[] arr) {
        int x = 0;
        for (int v : arr) {
            x = (x + v) % MOD;
        }
        return x;
    }
}
</code></pre>
<h4 id="c-40"><a class="header" href="#c-40">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    const int mod = 1e9 + 7;

    int distinctSubseqII(string s) {
        vector&lt;long&gt; dp(26);
        for (char&amp; c : s) {
            int i = c - 'a';
            dp[i] = accumulate(dp.begin(), dp.end(), 1l) % mod;
        }
        return accumulate(dp.begin(), dp.end(), 0l) % mod;
    }
};
</code></pre>
<h4 id="go-32"><a class="header" href="#go-32">Go</a></h4>
<pre><code class="language-go">func distinctSubseqII(s string) int {
	const mod int = 1e9 + 7
	sum := func(arr []int) int {
		x := 0
		for _, v := range arr {
			x = (x + v) % mod
		}
		return x
	}

	dp := make([]int, 26)
	for _, c := range s {
		c -= 'a'
		dp[c] = sum(dp) + 1
	}
	return sum(dp)
}
</code></pre>
<h4 id="typescript-35"><a class="header" href="#typescript-35">TypeScript</a></h4>
<pre><code class="language-ts">function distinctSubseqII(s: string): number {
    const mod = 1e9 + 7;
    const dp = new Array(26).fill(0);
    for (const c of s) {
        dp[c.charCodeAt(0) - 'a'.charCodeAt(0)] = dp.reduce((r, v) =&gt; (r + v) % mod, 0) + 1;
    }
    return dp.reduce((r, v) =&gt; (r + v) % mod, 0);
}
</code></pre>
<h4 id="rust-18"><a class="header" href="#rust-18">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn distinct_subseq_ii(s: String) -&gt; i32 {
        const MOD: i32 = (1e9 as i32) + 7;
        let mut dp = [0; 26];
        for u in s.as_bytes() {
            let i = (u - &amp;b'a') as usize;
            dp[i] = ({
                let mut sum = 0;
                dp.iter().for_each(|&amp;v| {
                    sum = (sum + v) % MOD;
                });
                sum
            }) + 1;
        }
        let mut res = 0;
        dp.iter().for_each(|&amp;v| {
            res = (res + v) % MOD;
        });
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="c-41"><a class="header" href="#c-41">C</a></h4>
<pre><code class="language-c">int distinctSubseqII(char* s) {
    int mod = 1e9 + 7;
    int n = strlen(s);
    int dp[26] = {0};
    for (int i = 0; i &lt; n; i++) {
        int sum = 0;
        for (int j = 0; j &lt; 26; j++) {
            sum = (sum + dp[j]) % mod;
        }
        dp[s[i] - 'a'] = sum + 1;
    }
    int res = 0;
    for (int i = 0; i &lt; 26; i++) {
        res = (res + dp[i]) % mod;
    }
    return res;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-2"><a class="header" href="#solution-2-2">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-33"><a class="header" href="#python3-33">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10**9 + 7
        dp = [0] * 26
        for c in s:
            i = ord(c) - ord('a')
            dp[i] = sum(dp) % mod + 1
        return sum(dp) % mod
</code></pre>
<h4 id="java-32"><a class="header" href="#java-32">Java</a></h4>
<pre><code class="language-java">class Solution {
    private static final int MOD = (int) 1e9 + 7;

    public int distinctSubseqII(String s) {
        int[] dp = new int[26];
        int ans = 0;
        for (int i = 0; i &lt; s.length(); ++i) {
            int j = s.charAt(i) - 'a';
            int add = (ans - dp[j] + 1) % MOD;
            ans = (ans + add) % MOD;
            dp[j] = (dp[j] + add) % MOD;
        }
        return (ans + MOD) % MOD;
    }
}
</code></pre>
<h4 id="c-42"><a class="header" href="#c-42">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    const int mod = 1e9 + 7;

    int distinctSubseqII(string s) {
        vector&lt;long&gt; dp(26);
        long ans = 0;
        for (char&amp; c : s) {
            int i = c - 'a';
            long add = ans - dp[i] + 1;
            ans = (ans + add + mod) % mod;
            dp[i] = (dp[i] + add) % mod;
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-33"><a class="header" href="#go-33">Go</a></h4>
<pre><code class="language-go">func distinctSubseqII(s string) int {
	const mod int = 1e9 + 7
	dp := make([]int, 26)
	ans := 0
	for _, c := range s {
		c -= 'a'
		add := ans - dp[c] + 1
		ans = (ans + add) % mod
		dp[c] = (dp[c] + add) % mod
	}
	return (ans + mod) % mod
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-1"><a class="header" href="#solution-3-1">Solution 3</a></h3>
<!-- tabs:start -->
<h4 id="python3-34"><a class="header" href="#python3-34">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10**9 + 7
        dp = [0] * 26
        ans = 0
        for c in s:
            i = ord(c) - ord('a')
            add = ans - dp[i] + 1
            ans = (ans + add) % mod
            dp[i] += add
        return ans
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class DistinctSubsequencesII {

	// a b a a
	// 0 1 2 3
	//    {}                      all = 1
	// 0: {} {a}                  newAdd = 1 (all-cnt['a']); all = 2 (+=newAdd); cnt['a'] = 1 (+=newAdd)
	// 1: {}  {a}                 newAdd = 2 (all-cnt['b']); all = 4 (+=newAdd); cnt['b'] = 2 (+=newAdd) 
	//    {b} {ab}
	// 2: {}   {a}  {b}  {ab}     newAdd = 3 (all-cnt['a']); all = 7 (all + newAdd); cnt['a'] = 4 (+=newAdd)
	//    {a}* {aa} {ba} {aba}
	// 3: {}   {a}  {b}  {ab}     newAdd = 3 (all-cnt['a']); all = 10 (all + newAdd); cnt['a'] = 7 (+=newAdd)
	//    {aa} {ba} {aba}
	//    {a}* {aa}* {ba}* {aba}* 
	//    {aaa}  {baa}  {abaa}

	public static int distinctSubseqII(String s) {
		int mod = 1000000007;
		char[] str = s.toCharArray();
		int[] cnt = new int[26]; // number of subsequences ending with chr - 'a'
		int all = 1, // include empty string
			newAdd;
		for (char x : str) {
			newAdd = (all - cnt[x - 'a'] + mod) % mod;
			cnt[x - 'a'] = (cnt[x - 'a'] + newAdd) % mod;
			all = (all + newAdd) % mod;
		}
		return (all - 1 + mod) % mod;  // exclude empty string
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=11518">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-dimensional-dp-problems-part-1"><a class="header" href="#two-dimensional-dp-problems-part-1">Two-Dimensional DP Problems (part 1)</a></h1>
<h2 id="minimum-path-sum"><a class="header" href="#minimum-path-sum">Minimum Path Sum</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-path-sum">LeetCode 64. Minimum Path Sum</a></p>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<pre><code>Example 1:

Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1  3  1  1  1 minimizes the sum.

Example 2:

Input: grid = [[1,2,3],[4,5,6]]
Output: 12
</code></pre>
<p>Constraints:</p>
<ul>
<li>m = grid.length</li>
<li>n = grid[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>0 &lt;= grid[i][j] &lt;= 200</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class MinimumPathSum {

	// 1. brute-force recursive solution
	public static int minPathSum1(int[][] grid) {
		return f1(grid, grid.length - 1, grid[0].length - 1);
	}

	// compute the minimum path sum from grid[0][0] to grid[i][j]
	public static int f1(int[][] grid, int i, int j) {
		if (i == 0 &amp;&amp; j == 0) {
			return grid[0][0];
		}
		int up = Integer.MAX_VALUE;
		int left = Integer.MAX_VALUE;
		if (i - 1 &gt;= 0) {
			up = f1(grid, i - 1, j);
		}
		if (j - 1 &gt;= 0) {
			left = f1(grid, i, j - 1);
		}
		return grid[i][j] + Math.min(up, left);
	}

	// 2. recusive solution with memoization
	public static int minPathSum2(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int[][] dp = new int[n][m];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; m; j++) {
				dp[i][j] = -1;
			}
		}
		return f2(grid, grid.length - 1, grid[0].length - 1, dp);
	}

	public static int f2(int[][] grid, int i, int j, int[][] dp) {
		if (dp[i][j] != -1) {
			return dp[i][j];
		}
		int ans;
		if (i == 0 &amp;&amp; j == 0) {
			ans = grid[0][0];
		} else {
			int up = Integer.MAX_VALUE;
			int left = Integer.MAX_VALUE;
			if (i - 1 &gt;= 0) {
				up = f2(grid, i - 1, j, dp);
			}
			if (j - 1 &gt;= 0) {
				left = f2(grid, i, j - 1, dp);
			}
			ans = grid[i][j] + Math.min(up, left);
		}
		dp[i][j] = ans;
		return ans;
	}

	// 3. iterative bottom-up solution
	public static int minPathSum3(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int[][] dp = new int[n][m];
		dp[0][0] = grid[0][0];
		for (int i = 1; i &lt; n; i++) {
			dp[i][0] = dp[i - 1][0] + grid[i][0];
		}
		for (int j = 1; j &lt; m; j++) {
			dp[0][j] = dp[0][j - 1] + grid[0][j];
		}
		for (int i = 1; i &lt; n; i++) {
			for (int j = 1; j &lt; m; j++) {
				dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
			}
		}
		return dp[n - 1][m - 1];
	}

	// 4. iterative solution with space optimization
	public static int minPathSum4(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		// compressed reusable DP table, equivalent to one row of the 2D DP table
		int[] dp = new int[m];
		dp[0] = grid[0][0];
		for (int j = 1; j &lt; m; j++) {
			dp[j] = dp[j - 1] + grid[0][j];
		}
		for (int i = 1; i &lt; n; i++) {
			dp[0] += grid[i][0];
			for (int j = 1; j &lt; m; j++) { // refresh the DP table from left to right
				dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
			}
		}
		return dp[m - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=172">
    </iframe>
</details>
<h2 id="word-search"><a class="header" href="#word-search">Word Search</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/word-search">LeetCode 79. Word Search</a></p>
<p>Given an m x n grid of characters board and a string word, return true if word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<pre><code>Example 1:

Input: 
  board = [
    [A,B,C,E],
    [S,F,C,S],
    [A,D,E,E]
  ], 
  word = ABCCED
Output: true

Example 2:

Input:
  board = [
    [A,B,C,E],
    [S,F,C,S],
    [A,D,E,E]
  ], 
  word = SEE
Output: true

Example 3:

Input:
  board = [
    [A,B,C,E],
    [S,F,C,S],
    [A,D,E,E]
  ], 
  word = ABCB
Output: false

Example 4:

Input:
  board = [
    [A,T],
    [T,A],
    [S,S]
  ],
  word = ATASST
Output: true
</code></pre>
<p>Constraints:</p>
<ul>
<li>m = board.length</li>
<li>n = board[i].length</li>
<li>1 &lt;= m, n &lt;= 6</li>
<li>1 &lt;= word.length &lt;= 15</li>
<li>board and word consists of only lowercase and uppercase English letters.</li>
</ul>
<p>Follow up: Could you use search pruning to make your solution faster with a larger board?</p>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class WordSearch {

	// Note: This problem does not have iterative solution 
	// because the subproblem not only depend on i and j
	// but also depend on the visited state of the board.
	// For the same i and j, there are probably different
	// solutions for different board state.

	public static boolean exist(char[][] board, String word) {
		char[] w = word.toCharArray();
		for (int i = 0; i &lt; board.length; i++) {
			for (int j = 0; j &lt; board[0].length; j++) {
				if (f(board, i, j, w, 0)) {
					return true;
				}
			}
		}
		return false;
	}

	// starting from b[i][j], is there a match with w[k..]
	// recursive solution with backtracking
	public static boolean f(char[][] b, int i, int j, char[] w, int k) {
		if (k == w.length) {
			return true;
		}
		// check the boundaries and character match
		if (i &lt; 0 || i == b.length || j &lt; 0 || j == b[0].length || b[i][j] != w[k]) {
			return false;
		}
		// within the boundary of b and b[i][j] == w[k]
		char tmp = b[i][j]; // needed for backtracking
		b[i][j] = 0; // mark b[i][j] as visited
		boolean ans = f(b, i - 1, j, w, k + 1)  // search up
			    || f(b, i + 1, j, w, k + 1)     // search down 
				|| f(b, i, j - 1, w, k + 1)     // search left
				|| f(b, i, j + 1, w, k + 1);    // search right
		b[i][j] = tmp; // backtracking - restore the value of b[i][j]
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=2825">
    </iframe>
</details>
<h2 id="longest-common-subsequence"><a class="header" href="#longest-common-subsequence">Longest Common Subsequence</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/longest-common-subsequence">LeetCode 1143. Longest Common Subsequence</a></p>
<p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.</p>
<p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>
<pre><code>For example, ace is a subsequence of abcde.
</code></pre>
<p>A common subsequence of two strings is a subsequence that is common to both strings.</p>
<pre><code>Example 1:

Input: text1 = abcde, text2 = ace 
Output: 3  
Explanation: The longest common subsequence is ace and its length is 3.

Example 2:

Input: text1 = abc, text2 = abc
Output: 3
Explanation: The longest common subsequence is abc and its length is 3.

Example 3:

Input: text1 = abc, text2 = def
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= text1.length, text2.length &lt;= 1000</li>
<li>text1 and text2 consist of only lowercase English characters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/longest-common-subsequence/
public class LongestCommonSubsequence {

	// 0. brute-force recursive solution (naive version)
	public static int longestCommonSubsequence1(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		return f1(s1, s2, n - 1, m - 1);
	}

	// compute the LCS for substrings s1[0..i1] and s2[0..i2]
	public static int f1(char[] s1, char[] s2, int i1, int i2) {
		if (i1 &lt; 0 || i2 &lt; 0) {
			return 0;
		}
		int p1 = f1(s1, s2, i1 - 1, i2 - 1);		// case 1: drop both s1[i1] and s2[i2], ONLY used in case 4
		int p2 = f1(s1, s2, i1 - 1, i2);			// case 2: drop s1[i1] but keep s2[i2]			
		int p3 = f1(s1, s2, i1, i2 - 1);			// case 3: keep s1[i1] but drop s2[i2]
		int p4 = s1[i1] == s2[i2] ? (p1 + 1) : 0;	// case 4: keep both s1[i1] and s2[i2] if the two characters match
		return Math.max(Math.max(p1, p2), Math.max(p3, p4));
	}

	// 1. brute-force recursive solution (improved version)
	// notice in solution 0, p1 &lt;= p2 and p1 &lt;= p3
	public static int longestCommonSubsequence2(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		return f2(s1, s2, n, m);
	}

	// compute the LCS length for s1's len1-character prefix and s2's len2 prefix
	// using length intead of array index to avoid handling negative indices
	public static int f2(char[] s1, char[] s2, int len1, int len2) {
		if (len1 == 0 || len2 == 0) {
			return 0;
		}
		int ans;
		if (s1[len1 - 1] == s2[len2 - 1]) {	// the last characters of two strings match
			ans = f2(s1, s2, len1 - 1, len2 - 1) + 1;
		} else {
			ans = Math.max(f2(s1, s2, len1 - 1, len2), f2(s1, s2, len1, len2 - 1));
		}
		return ans;
	}

	// 2. recursive solution with memoization
	public static int longestCommonSubsequence3(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 0; i &lt;= n; i++) {
			for (int j = 0; j &lt;= m; j++) {
				dp[i][j] = -1;
			}
		}
		return f3(s1, s2, n, m, dp);
	}

	public static int f3(char[] s1, char[] s2, int len1, int len2, int[][] dp) {
		if (len1 == 0 || len2 == 0) {
			return 0;
		}
		if (dp[len1][len2] != -1) {
			return dp[len1][len2];
		}
		int ans;
		if (s1[len1 - 1] == s2[len2 - 1]) {
			ans = f3(s1, s2, len1 - 1, len2 - 1, dp) + 1;
		} else {
			ans = Math.max(f3(s1, s2, len1 - 1, len2, dp), f3(s1, s2, len1, len2 - 1, dp));
		}
		dp[len1][len2] = ans;
		return ans;
	}

	// 3. iterative bottom-up solution
	public static int longestCommonSubsequence4(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		int[][] dp = new int[n + 1][m + 1];
		for (int len1 = 1; len1 &lt;= n; len1++) {
			for (int len2 = 1; len2 &lt;= m; len2++) {
				if (s1[len1 - 1] == s2[len2 - 1]) {
					dp[len1][len2] = 1 + dp[len1 - 1][len2 - 1];
				} else {
					dp[len1][len2] = Math.max(dp[len1 - 1][len2], dp[len1][len2 - 1]);
				}
			}
		}
		return dp[n][m];
	}

	// 4. iterative solution + space optimization
	public static int longestCommonSubsequence5(String str1, String str2) {
		char[] s1, s2;
		if (str1.length() &gt;= str2.length()) {
			s1 = str1.toCharArray();
			s2 = str2.toCharArray();
		} else {
			s1 = str2.toCharArray();
			s2 = str1.toCharArray();
		}
		int n = s1.length;
		int m = s2.length;
		int[] dp = new int[m + 1];
		for (int len1 = 1; len1 &lt;= n; len1++) {
			int leftUp = 0, backup;
			for (int len2 = 1; len2 &lt;= m; len2++) {
				backup = dp[len2];
				if (s1[len1 - 1] == s2[len2 - 1]) {
					dp[len2] = 1 + leftUp;
				} else {
					dp[len2] = Math.max(dp[len2], dp[len2 - 1]);
				}
				leftUp = backup;
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=3756">
    </iframe>
</details>
<h2 id="longest-palindromic-subsequence"><a class="header" href="#longest-palindromic-subsequence">Longest Palindromic Subsequence</a></h2>
<details><summary>Description:</summary>
<hr />
<h2>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0500-0599/0516.Longest%20Palindromic%20Subsequence/README_EN.md
tags:
- String
- Dynamic Programming</h2>
<h1 id="516-longest-palindromic-subsequence"><a class="header" href="#516-longest-palindromic-subsequence"><a href="https://leetcode.com/problems/longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a></a></h1>
<p><a href="dynamic-programming//solution/0500-0599/0516.Longest%20Palindromic%20Subsequence/README.html">中文文档</a></p>
<h2 id="description-23"><a class="header" href="#description-23">Description</a></h2>
<p>Given a string s, find the longest palindromic subsequences length in s.</p>
<p>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<p>Example 1:</p>
<p>Input: s = bbbab
Output: 4
Explanation: One possible longest palindromic subsequence is bbbb.</p>
<p>Example 2:</p>
<p>Input: s = cbbd
Output: 2
Explanation: One possible longest palindromic subsequence is bb.</p>
<p>Constraints:</p>
<pre><code>1 = s.length = 1000
s consists only of lowercase English letters.
</code></pre>
<h2 id="solutions-23"><a class="header" href="#solutions-23">Solutions</a></h2>
<h3 id="solution-1-dynamic-programming-3"><a class="header" href="#solution-1-dynamic-programming-3">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i][j]$ as the length of the longest palindromic subsequence from the $i$-th character to the $j$-th character in string $s$. Initially, $f[i][i] = 1$, and the values of other positions are all $0$.</p>
<p>If $s[i] = s[j]$, then $f[i][j] = f[i + 1][j - 1] + 2$; otherwise, $f[i][j] = \max(f[i + 1][j], f[i][j - 1])$.</p>
<p>Since the value of $f[i][j]$ is related to $f[i + 1][j - 1]$, $f[i + 1][j]$, and $f[i][j - 1]$, we should enumerate $i$ from large to small, and enumerate $j$ from small to large.</p>
<p>The answer is $f[0][n - 1]$.</p>
<p>The time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Where $n$ is the length of the string $s$.</p>
<h4 id="python3-35"><a class="header" href="#python3-35">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        n = len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = 1
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1] + 2
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return f[0][-1]
</code></pre>
<h4 id="java-33"><a class="header" href="#java-33">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] f = new int[n][n];
        for (int i = 0; i &lt; n; ++i) {
            f[i][i] = 1;
        }
        for (int i = n - 1; i &gt;= 0; --i) {
            for (int j = i + 1; j &lt; n; ++j) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
}
</code></pre>
<h4 id="c-43"><a class="header" href="#c-43">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        int f[n][n];
        memset(f, 0, sizeof(f));
        for (int i = 0; i &lt; n; ++i) {
            f[i][i] = 1;
        }
        for (int i = n - 1; ~i; --i) {
            for (int j = i + 1; j &lt; n; ++j) {
                if (s[i] == s[j]) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
};
</code></pre>
<h4 id="go-34"><a class="header" href="#go-34">Go</a></h4>
<pre><code class="language-go">func longestPalindromeSubseq(s string) int {
	n := len(s)
	f := make([][]int, n)
	for i := range f {
		f[i] = make([]int, n)
		f[i][i] = 1
	}
	for i := n - 2; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			if s[i] == s[j] {
				f[i][j] = f[i+1][j-1] + 2
			} else {
				f[i][j] = max(f[i+1][j], f[i][j-1])
			}
		}
	}
	return f[0][n-1]
}
</code></pre>
<h4 id="typescript-36"><a class="header" href="#typescript-36">TypeScript</a></h4>
<pre><code class="language-ts">function longestPalindromeSubseq(s: string): number {
    const n = s.length;
    const f: number[][] = Array.from({ length: n }, () =&gt; Array(n).fill(0));
    for (let i = 0; i &lt; n; ++i) {
        f[i][i] = 1;
    }
    for (let i = n - 2; ~i; --i) {
        for (let j = i + 1; j &lt; n; ++j) {
            if (s[i] === s[j]) {
                f[i][j] = f[i + 1][j - 1] + 2;
            } else {
                f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
            }
        }
    }
    return f[0][n - 1];
}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/longest-palindromic-subsequence/
public class LongestPalindromicSubsequence {

	// Note: this problem can be converted to LCS problem by comparing the orignal string with the reversed one.
	// Here we only discuss the DP solutions

	// 1. brute-force recursive solution
	public static int longestPalindromeSubseq1(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		return f1(s, 0, n - 1);
	}

	// compute the length of LPS for substring s[l..r]
	public static int f1(char[] s, int l, int r) {
		if (l == r) {
			return 1;
		}
		if (l + 1 == r) {
			return s[l] == s[r] ? 2 : 1;
		}
		if (s[l] == s[r]) {
			return 2 + f1(s, l + 1, r - 1);
		} else {
			return Math.max(f1(s, l + 1, r), f1(s, l, r - 1));
		}
	}

	// 2. recursive solution with memoization
	public static int longestPalindromeSubseq2(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		return f2(s, 0, n - 1, dp);
	}

	public static int f2(char[] s, int l, int r, int[][] dp) {
		if (l == r) {
			return 1;
		}
		if (l + 1 == r) {
			return s[l] == s[r] ? 2 : 1;
		}
		if (dp[l][r] != 0) {
			return dp[l][r];
		}
		int ans;
		if (s[l] == s[r]) {
			ans = 2 + f2(s, l + 1, r - 1, dp);
		} else {
			ans = Math.max(f2(s, l + 1, r, dp), f2(s, l, r - 1, dp));
		}
		dp[l][r] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int longestPalindromeSubseq3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int l = n - 1; l &gt;= 0; l--) {
			dp[l][l] = 1;
			if (l + 1 &lt; n) {
				dp[l][l + 1] = s[l] == s[l + 1] ? 2 : 1;
			}
			for (int r = l + 2; r &lt; n; r++) {
				if (s[l] == s[r]) {
					dp[l][r] = 2 + dp[l + 1][r - 1];
				} else {
					dp[l][r] = Math.max(dp[l + 1][r], dp[l][r - 1]);
				}
			}
		}
		return dp[0][n - 1];
	}

	// 4. iterative solution with space optimization
	public static int longestPalindromeSubseq4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[] dp = new int[n];
		for (int l = n - 1, leftDown = 0, backup; l &gt;= 0; l--) {
			dp[l] = 1;
			if (l + 1 &lt; n) {
				leftDown = dp[l + 1];
				dp[l + 1] = s[l] == s[l + 1] ? 2 : 1;
			}
			for (int r = l + 2; r &lt; n; r++) {
				backup = dp[r];
				if (s[l] == s[r]) {
					dp[r] = 2 + leftDown;
				} else {
					dp[r] = Math.max(dp[r], dp[r - 1]);
				}
				leftDown = backup;
			}
		}
		return dp[n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=6378">
    </iframe>
</details>
<h2 id="longest-increasing-path-in-a-matrix"><a class="header" href="#longest-increasing-path-in-a-matrix">Longest Increasing Path in a Matrix</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix">LeetCode 329. Longest Increasing Path in a Matrix</a></p>
<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.</p>
<p>From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p>
<pre><code>Example 1:

Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].

Example 2:

Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

Example 3:

Input: matrix = [[1]]
Output: 1
</code></pre>
<p>Constraints:</p>
<ul>
<li>m = matrix.length</li>
<li>n = matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>0 &lt;= matrix[i][j] &lt;= 2^31 - 1</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
public class LongestIncreasingPathInMatrix {

	// 1. brute-force recursive solution
	public static int longestIncreasingPath1(int[][] grid) {
		int ans = 0;
		for (int i = 0; i &lt; grid.length; i++) {
			for (int j = 0; j &lt; grid[0].length; j++) {
				ans = Math.max(ans, f1(grid, i, j));
			}
		}
		return ans;
	}

	// compute longest increasing path from grid[i][j]
	public static int f1(int[][] grid, int i, int j) {
		int next = 0;
		if (i &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i - 1][j]) {
			next = Math.max(next, f1(grid, i - 1, j));
		}
		if (i + 1 &lt; grid.length &amp;&amp; grid[i][j] &lt; grid[i + 1][j]) {
			next = Math.max(next, f1(grid, i + 1, j));
		}
		if (j &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i][j - 1]) {
			next = Math.max(next, f1(grid, i, j - 1));
		}
		if (j + 1 &lt; grid[0].length &amp;&amp; grid[i][j] &lt; grid[i][j + 1]) {
			next = Math.max(next, f1(grid, i, j + 1));
		}
		return next + 1;
	}

	// recursive solution with memoization
	public static int longestIncreasingPath2(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int[][] dp = new int[n][m];
		int ans = 0;
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; m; j++) {
				ans = Math.max(ans, f2(grid, i, j, dp));
			}
		}
		return ans;
	}

	public static int f2(int[][] grid, int i, int j, int[][] dp) {
		if (dp[i][j] != 0) {
			return dp[i][j];
		}
		int next = 0;
		if (i &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i - 1][j]) {
			next = Math.max(next, f2(grid, i - 1, j, dp));
		}
		if (i + 1 &lt; grid.length &amp;&amp; grid[i][j] &lt; grid[i + 1][j]) {
			next = Math.max(next, f2(grid, i + 1, j, dp));
		}
		if (j &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i][j - 1]) {
			next = Math.max(next, f2(grid, i, j - 1, dp));
		}
		if (j + 1 &lt; grid[0].length &amp;&amp; grid[i][j] &lt; grid[i][j + 1]) {
			next = Math.max(next, f2(grid, i, j + 1, dp));
		}
		dp[i][j] = next + 1;
		return next + 1;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=10078">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-dimensional-dp-problems-part-2"><a class="header" href="#two-dimensional-dp-problems-part-2">Two-Dimensional DP Problems (part 2)</a></h1>
<h2 id="distinct-subsequences"><a class="header" href="#distinct-subsequences">Distinct Subsequences</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/distinct-subsequences">LeetCode 115. Distinct Subsequences</a></p>
<p>Given two strings s and t, return the number of distinct subsequences of s which equals t.</p>
<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>
<pre><code>Example 1:

Input: s = rabbbit, t = rabbit
Output: 3
Explanation:
As shown below, there are 3 ways you can generate rabbit from s.
rabbbit
rabbbit
rabbbit

Example 2:

Input: s = babgbag, t = bag
Output: 5
Explanation:
As shown below, there are 5 ways you can generate bag from s.
babgbag
babgbag
babgbag
babgbag
babgbag
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length, t.length &lt;= 1000</li>
<li>s and t consist of English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/distinct-subsequences/
public class DistinctSubsequences {

	// 1. iterative solution using a 2D DP table
	public static int numDistinct1(String str, String target) {
		char[] s = str.toCharArray();
		char[] t = target.toCharArray();
		int n = s.length;
		int m = t.length;
		// dp[i][j] : number of subsequences in s[0..i] that match substring t[0..j]
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 0; i &lt;= n; i++) {
			dp[i][0] = 1;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				dp[i][j] = dp[i - 1][j];
				if (s[i - 1] == t[j - 1]) {
					dp[i][j] += dp[i - 1][j - 1];
				}
			}
		}
		return dp[n][m];
	}

	// 2. iterative solution + space optimization
	public static int numDistinct2(String str, String target) {
		char[] s = str.toCharArray();
		char[] t = target.toCharArray();
		int n = s.length;
		int m = t.length;
		int[] dp = new int[m + 1];
		dp[0] = 1;
		for (int i = 1; i &lt;= n; i++) {
			for (int j = m; j &gt;= 1; j--) {
				if (s[i - 1] == t[j - 1]) {
					dp[j] += dp[j - 1];
				}
			}
		}
		return dp[m];
	}

	// 3. fix overflow error: answer % (10^9 + 7)
	public static int numDistinct3(String str, String target) {
		int mod = 1000000007;
		char[] s = str.toCharArray();
		char[] t = target.toCharArray();
		int n = s.length;
		int m = t.length;
		int[] dp = new int[m + 1];
		dp[0] = 1;
		for (int i = 1; i &lt;= n; i++) {
			for (int j = m; j &gt;= 1; j--) {
				if (s[i - 1] == t[j - 1]) {
					dp[j] = (dp[j] + dp[j - 1]) % mod;
				}
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=85">
    </iframe>
</details>
<h2 id="edit-distance"><a class="header" href="#edit-distance">Edit Distance</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/edit-distance">LeetCode 72. Edit Distance</a></p>
<p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following three operations permitted on a word:</p>
<pre><code>Insert a character
Delete a character
Replace a character
</code></pre>
<pre><code>Example 1:

Input: word1 = horse, word2 = ros
Output: 3
Explanation: 
horse - rorse (replace h with r)
rorse - rose (remove r)
rose - ros (remove e)

Example 2:

Input: word1 = intention, word2 = execution
Output: 5
Explanation: 
intention - inention (remove t)
inention - enention (replace i with e)
enention - exention (replace n with x)
exention - exection (replace n with c)
exection - execution (insert u)
</code></pre>
<p>Constraints:</p>
<ul>
<li>0 &lt;= word1.length, word2.length &lt;= 500</li>
<li>word1 and word2 consist of lowercase English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/edit-distance/
public class EditDistance {

	public int minDistance(String word1, String word2) {
		return editDistance2(word1, word2, 1, 1, 1);
	}

	// 0. first trial version	
	// a : cost of insersion
	// b : cost of deletion
	// c : cost of substitution
	public static int editDistance1(String str1, String str2, int a, int b, int c) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[i][j] : cost of converting s1[0..i] to s2[0..j]
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][0] = i * b;
		}
		for (int j = 1; j &lt;= m; j++) {
			dp[0][j] = j * a;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				int p1 = Integer.MAX_VALUE;
				if (s1[i - 1] == s2[j - 1]) {
					p1 = dp[i - 1][j - 1];
				}
				int p2 = Integer.MAX_VALUE;
				if (s1[i - 1] != s2[j - 1]) {
					p2 = dp[i - 1][j - 1] + c;
				}
				int p3 = dp[i][j - 1] + a;
				int p4 = dp[i - 1][j] + b;
				dp[i][j] = Math.min(Math.min(p1, p2), Math.min(p3, p4));
			}
		}
		return dp[n][m];
	}

	// 1. optimized version - fast enumeration
	// a : cost of insersion
	// b : cost of deletion
	// c : cost of substitution
	public static int editDistance2(String str1, String str2, int a, int b, int c) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[i][j] : cost of converting s1[0..i] to s2[0..j]
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][0] = i * b;
		}
		for (int j = 1; j &lt;= m; j++) {
			dp[0][j] = j * a;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				if (s1[i - 1] == s2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(Math.min(dp[i - 1][j] + b, dp[i][j - 1] + a), dp[i - 1][j - 1] + c);
				}
			}
		}
		return dp[n][m];
	}

	// 2. solution with space optimization
	public static int editDistance3(String str1, String str2, int a, int b, int c) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		int[] dp = new int[m + 1];
		for (int j = 1; j &lt;= m; j++) {
			dp[j] = j * a;
		}
		for (int i = 1, leftUp, backUp; i &lt;= n; i++) {
			leftUp = (i - 1) * b;
			dp[0] = i * b;
			for (int j = 1; j &lt;= m; j++) {
				backUp = dp[j];
				if (s1[i - 1] == s2[j - 1]) {
					dp[j] = leftUp;
				} else {
					dp[j] = Math.min(Math.min(dp[j] + b, dp[j - 1] + a), leftUp + c);
				}
				leftUp = backUp;
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=1333">
    </iframe>
</details>
<h2 id="interleaving-string"><a class="header" href="#interleaving-string">Interleaving String</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/interleaving-string">LeetCode 97. Interleaving String</a></p>
<p>Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.</p>
<p>An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:</p>
<pre><code>s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| = 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
</code></pre>
<p>Note: a + b is the concatenation of strings a and b.</p>
<pre><code>Example 1:

Input: s1 = aabcc, s2 = dbbca, s3 = aadbbcbcac
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = aa + bc + c, and s2 into s2 = dbbc + a.
Interleaving the two splits, we get aa + dbbc + bc + a + c = aadbbcbcac.
Since s3 can be obtained by interleaving s1 and s2, we return true.

Example 2:

Input: s1 = aabcc, s2 = dbbca, s3 = aadbbbaccc
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.

Example 3:

Input: s1 = , s2 = , s3 = 
Output: true
</code></pre>
<p>Constraints:</p>
<ul>
<li>0 &lt;= s1.length, s2.length &lt;= 100</li>
<li>0 &lt;= s3.length &lt;= 200</li>
<li>s1, s2, and s3 consist of lowercase English letters.</li>
</ul>
<p>Follow up: Could you solve it using only O(s2.length) additional memory space?</p>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/interleaving-string/
public class InterleavingString {

	// 1. iterative bottom up solution
	public static boolean isInterleave1(String str1, String str2, String str3) {
		if (str1.length() + str2.length() != str3.length()) {
			return false;
		}
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		char[] s3 = str3.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[i][j]: can substrings s1[0..i] and s2[0..j] interleave into s3[0..i+j]
		boolean[][] dp = new boolean[n + 1][m + 1];
		dp[0][0] = true;
		for (int i = 1; i &lt;= n; i++) {
			if (s1[i - 1] != s3[i - 1]) {
				break;
			}
			dp[i][0] = true;
		}
		for (int j = 1; j &lt;= m; j++) {
			if (s2[j - 1] != s3[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				dp[i][j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1]);
			}
		}
		return dp[n][m];
	}

	// 2. iterative solution with space optimization 
	public static boolean isInterleave2(String str1, String str2, String str3) {
		if (str1.length() + str2.length() != str3.length()) {
			return false;
		}
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		char[] s3 = str3.toCharArray();
		int n = s1.length;
		int m = s2.length;
		boolean[] dp = new boolean[m + 1];
		dp[0] = true;
		for (int j = 1; j &lt;= m; j++) {
			if (s2[j - 1] != s3[j - 1]) {
				break;
			}
			dp[j] = true;
		}
		for (int i = 1; i &lt;= n; i++) {
			dp[0] = s1[i - 1] == s3[i - 1] &amp;&amp; dp[0];
			for (int j = 1; j &lt;= m; j++) {
				dp[j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[j - 1]);
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=2921">
    </iframe>
</details>
<h2 id="fill-cells-use-all-colors-ways"><a class="header" href="#fill-cells-use-all-colors-ways">Fill Cells Use All Colors Ways</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class068;

import java.util.Arrays;

// 有效涂色问题
// 给定n、m两个参数
// 一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
// 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
// 求一共有多少种有效的涂色方法
// 1 &lt;= n, m &lt;= 5000
// 结果比较大请 % 1000000007 之后返回
// 对数器验证
public class Code04_FillCellsUseAllColorsWays {

	// 暴力方法
	// 为了验证
	public static int ways1(int n, int m) {
		return f(new int[n], new boolean[m + 1], 0, n, m);
	}

	// 把所有填色的方法暴力枚举
	// 然后一个一个验证是否有效
	// 这是一个带路径的递归
	// 无法改成动态规划
	public static int f(int[] path, boolean[] set, int i, int n, int m) {
		if (i == n) {
			Arrays.fill(set, false);
			int colors = 0;
			for (int c : path) {
				if (!set[c]) {
					set[c] = true;
					colors++;
				}
			}
			return colors == m ? 1 : 0;
		} else {
			int ans = 0;
			for (int j = 1; j &lt;= m; j++) {
				path[i] = j;
				ans += f(path, set, i + 1, n, m);
			}
			return ans;
		}
	}

	// 正式方法
	// 时间复杂度O(n * m)
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	// 也不做空间压缩了，因为千篇一律
	// 有兴趣的同学自己试试
	public static int MAXN = 5001;

	public static int[][] dp = new int[MAXN][MAXN];

	public static int mod = 1000000007;

	public static int ways2(int n, int m) {
		// dp[i][j]:
		// 一共有m种颜色
		// 前i个格子涂满j种颜色的方法数
		for (int i = 1; i &lt;= n; i++) {
			dp[i][1] = m;
		}
		for (int i = 2; i &lt;= n; i++) {
			for (int j = 2; j &lt;= m; j++) {
				dp[i][j] = (int) (((long) dp[i - 1][j] * j) % mod);
				dp[i][j] = (int) ((((long) dp[i - 1][j - 1] * (m - j + 1)) + dp[i][j]) % mod);
			}
		}
		return dp[n][m];
	}

	public static void main(String[] args) {
		// 测试的数据量比较小
		// 那是因为数据量大了，暴力方法过不了
		// 但是这个数据量足够说明正式方法是正确的
		int N = 9;
		int M = 9;
		System.out.println("功能测试开始");
		for (int n = 1; n &lt;= N; n++) {
			for (int m = 1; m &lt;= M; m++) {
				int ans1 = ways1(n, m);
				int ans2 = ways2(n, m);
				if (ans1 != ans2) {
					System.out.println("出错了!");
				}
			}
		}
		System.out.println("功能测试结束");

		System.out.println("性能测试开始");
		int n = 5000;
		int m = 4877;
		System.out.println("n : " + n);
		System.out.println("m : " + m);
		long start = System.currentTimeMillis();
		int ans = ways2(n, m);
		long end = System.currentTimeMillis();
		System.out.println("取模之后的结果 : " + ans);
		System.out.println("运行时间 : " + (end - start) + " 毫秒");
		System.out.println("性能测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class068;

import java.util.Arrays;

// 有效涂色问题
// 给定n、m两个参数
// 一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
// 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
// 求一共有多少种有效的涂色方法
// 1 &lt;= n, m &lt;= 5000
// 结果比较大请 % 1000000007 之后返回
// 对数器验证
public class Code04_FillCellsUseAllColorsWays {

	// 暴力方法
	// 为了验证
	public static int ways1(int n, int m) {
		return f(new int[n], new boolean[m + 1], 0, n, m);
	}

	// 把所有填色的方法暴力枚举
	// 然后一个一个验证是否有效
	// 这是一个带路径的递归
	// 无法改成动态规划
	public static int f(int[] path, boolean[] set, int i, int n, int m) {
		if (i == n) {
			Arrays.fill(set, false);
			int colors = 0;
			for (int c : path) {
				if (!set[c]) {
					set[c] = true;
					colors++;
				}
			}
			return colors == m ? 1 : 0;
		} else {
			int ans = 0;
			for (int j = 1; j &lt;= m; j++) {
				path[i] = j;
				ans += f(path, set, i + 1, n, m);
			}
			return ans;
		}
	}

	// 正式方法
	// 时间复杂度O(n * m)
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	// 也不做空间压缩了，因为千篇一律
	// 有兴趣的同学自己试试
	public static int MAXN = 5001;

	public static int[][] dp = new int[MAXN][MAXN];

	public static int mod = 1000000007;

	public static int ways2(int n, int m) {
		// dp[i][j]:
		// 一共有m种颜色
		// 前i个格子涂满j种颜色的方法数
		for (int i = 1; i &lt;= n; i++) {
			dp[i][1] = m;
		}
		for (int i = 2; i &lt;= n; i++) {
			for (int j = 2; j &lt;= m; j++) {
				dp[i][j] = (int) (((long) dp[i - 1][j] * j) % mod);
				dp[i][j] = (int) ((((long) dp[i - 1][j - 1] * (m - j + 1)) + dp[i][j]) % mod);
			}
		}
		return dp[n][m];
	}

	public static void main(String[] args) {
		// 测试的数据量比较小
		// 那是因为数据量大了，暴力方法过不了
		// 但是这个数据量足够说明正式方法是正确的
		int N = 9;
		int M = 9;
		System.out.println("功能测试开始");
		for (int n = 1; n &lt;= N; n++) {
			for (int m = 1; m &lt;= M; m++) {
				int ans1 = ways1(n, m);
				int ans2 = ways2(n, m);
				if (ans1 != ans2) {
					System.out.println("出错了!");
				}
			}
		}
		System.out.println("功能测试结束");

		System.out.println("性能测试开始");
		int n = 5000;
		int m = 4877;
		System.out.println("n : " + n);
		System.out.println("m : " + m);
		long start = System.currentTimeMillis();
		int ans = ways2(n, m);
		long end = System.currentTimeMillis();
		System.out.println("取模之后的结果 : " + ans);
		System.out.println("运行时间 : " + (end - start) + " 毫秒");
		System.out.println("性能测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=0">
    </iframe>
</details>
<h2 id="minimum-delete-become-substring"><a class="header" href="#minimum-delete-become-substring">Minimum Delete Become Substring</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class068;

import java.util.ArrayList;
import java.util.List;

// 删除至少几个字符可以变成另一个字符串的子串
// 给定两个字符串s1和s2
// 返回s1至少删除多少字符可以成为s2的子串
// 对数器验证
public class Code05_MinimumDeleteBecomeSubstring {

	// 暴力方法
	// 为了验证
	public static int minDelete1(String s1, String s2) {
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		f(s1.toCharArray(), 0, "", list);
		// 排序 : 长度大的子序列先考虑
		// 因为如果长度大的子序列是s2的子串
		// 那么需要删掉的字符数量 = s1的长度 - s1子序列长度
		// 子序列长度越大，需要删掉的字符数量就越少
		// 所以长度大的子序列先考虑
		list.sort((a, b) -&gt; b.length() - a.length());
		for (String str : list) {
			if (s2.indexOf(str) != -1) {
				// 检查s2中，是否包含当前的s1子序列str
				return s1.length() - str.length();
			}
		}
		return s1.length();
	}

	// 生成s1字符串的所有子序列串
	public static void f(char[] s1, int i, String path, List&lt;String&gt; list) {
		if (i == s1.length) {
			list.add(path);
		} else {
			f(s1, i + 1, path, list);
			f(s1, i + 1, path + s1[i], list);
		}
	}

	// 正式方法，动态规划
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	// 也不做空间压缩了，因为千篇一律
	// 有兴趣的同学自己试试
	public static int minDelete2(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[len1][len2] :
		// s1[前缀长度为i]至少删除多少字符，可以变成s2[前缀长度为j]的任意后缀串
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][0] = i;
			for (int j = 1; j &lt;= m; j++) {
				if (s1[i - 1] == s2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = dp[i - 1][j] + 1;
				}
			}
		}
		int ans = Integer.MAX_VALUE;
		for (int j = 0; j &lt;= m; j++) {
			ans = Math.min(ans, dp[n][j]);
		}
		return ans;
	}

	// 为了验证
	// 生成长度为n，有v种字符的随机字符串
	public static String randomString(int n, int v) {
		char[] ans = new char[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (char) ('a' + (int) (Math.random() * v));
		}
		return String.valueOf(ans);
	}

	// 为了验证
	// 对数器
	public static void main(String[] args) {
		// 测试的数据量比较小
		// 那是因为数据量大了，暴力方法过不了
		// 但是这个数据量足够说明正式方法是正确的
		int n = 12;
		int v = 3;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len1 = (int) (Math.random() * n) + 1;
			int len2 = (int) (Math.random() * n) + 1;
			String s1 = randomString(len1, v);
			String s2 = randomString(len2, v);
			int ans1 = minDelete1(s1, s2);
			int ans2 = minDelete2(s1, s2);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class068;

import java.util.ArrayList;
import java.util.List;

// 删除至少几个字符可以变成另一个字符串的子串
// 给定两个字符串s1和s2
// 返回s1至少删除多少字符可以成为s2的子串
// 对数器验证
public class Code05_MinimumDeleteBecomeSubstring {

	// 暴力方法
	// 为了验证
	public static int minDelete1(String s1, String s2) {
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		f(s1.toCharArray(), 0, "", list);
		// 排序 : 长度大的子序列先考虑
		// 因为如果长度大的子序列是s2的子串
		// 那么需要删掉的字符数量 = s1的长度 - s1子序列长度
		// 子序列长度越大，需要删掉的字符数量就越少
		// 所以长度大的子序列先考虑
		list.sort((a, b) -&gt; b.length() - a.length());
		for (String str : list) {
			if (s2.indexOf(str) != -1) {
				// 检查s2中，是否包含当前的s1子序列str
				return s1.length() - str.length();
			}
		}
		return s1.length();
	}

	// 生成s1字符串的所有子序列串
	public static void f(char[] s1, int i, String path, List&lt;String&gt; list) {
		if (i == s1.length) {
			list.add(path);
		} else {
			f(s1, i + 1, path, list);
			f(s1, i + 1, path + s1[i], list);
		}
	}

	// 正式方法，动态规划
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	// 也不做空间压缩了，因为千篇一律
	// 有兴趣的同学自己试试
	public static int minDelete2(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[len1][len2] :
		// s1[前缀长度为i]至少删除多少字符，可以变成s2[前缀长度为j]的任意后缀串
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][0] = i;
			for (int j = 1; j &lt;= m; j++) {
				if (s1[i - 1] == s2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = dp[i - 1][j] + 1;
				}
			}
		}
		int ans = Integer.MAX_VALUE;
		for (int j = 0; j &lt;= m; j++) {
			ans = Math.min(ans, dp[n][j]);
		}
		return ans;
	}

	// 为了验证
	// 生成长度为n，有v种字符的随机字符串
	public static String randomString(int n, int v) {
		char[] ans = new char[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (char) ('a' + (int) (Math.random() * v));
		}
		return String.valueOf(ans);
	}

	// 为了验证
	// 对数器
	public static void main(String[] args) {
		// 测试的数据量比较小
		// 那是因为数据量大了，暴力方法过不了
		// 但是这个数据量足够说明正式方法是正确的
		int n = 12;
		int v = 3;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len1 = (int) (Math.random() * n) + 1;
			int len2 = (int) (Math.random() * n) + 1;
			String s1 = randomString(len1, v);
			String s2 = randomString(len2, v);
			int ans1 = minDelete1(s1, s2);
			int ans2 = minDelete2(s1, s2);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-subarray-sum-and-the-related-problems-part-1"><a class="header" href="#largest-subarray-sum-and-the-related-problems-part-1">Largest Subarray Sum and the Related Problems (part 1)</a></h1>
<h2 id="maximumsubarray"><a class="header" href="#maximumsubarray">MaximumSubarray</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0000-0099/0053.Maximum%20Subarray/README_EN.md
tags:
    - Array
    - Divide and Conquer
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="53-maximum-subarray"><a class="header" href="#53-maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray">53. Maximum Subarray</a></a></h1>
<p><a href="dynamic-programming//solution/0000-0099/0053.Maximum%20Subarray/README.html">中文文档</a></p>
<h2 id="description-24"><a class="header" href="#description-24">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code>, find the <span data-keyword="subarray-nonempty">subarray</span> with the largest sum, and return <em>its sum</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The subarray [1] has the largest sum 1.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [5,4,-1,7,8]
<strong>Output:</strong> 23
<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
<p>&nbsp;</p>
<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>
<!-- description:end -->
<h2 id="solutions-24"><a class="header" href="#solutions-24">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-4"><a class="header" href="#solution-1-dynamic-programming-4">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i]$ to represent the maximum sum of a contiguous subarray ending at element $\textit{nums}[i]$. Initially, $f[0] = \textit{nums}[0]$. The final answer we seek is $\max_{0 \leq i &lt; n} f[i]$.</p>
<p>Consider $f[i]$ for $i \geq 1$. Its state transition equation is:</p>
<p>$$
f[i] = \max(f[i - 1] + \textit{nums}[i], \textit{nums}[i])
$$</p>
<p>That is:</p>
<p>$$
f[i] = \max(f[i - 1], 0) + \textit{nums}[i]
$$</p>
<p>Since $f[i]$ is only related to $f[i - 1]$, we can use a single variable $f$ to maintain the current value of $f[i]$ and perform the state transition. The answer is $\max_{0 \leq i &lt; n} f$.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array $\textit{nums}$. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-36"><a class="header" href="#python3-36">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        ans = f = nums[0]
        for x in nums[1:]:
            f = max(f, 0) + x
            ans = max(ans, f)
        return ans
</code></pre>
<h4 id="java-34"><a class="header" href="#java-34">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        for (int i = 1, f = nums[0]; i &lt; nums.length; ++i) {
            f = Math.max(f, 0) + nums[i];
            ans = Math.max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-44"><a class="header" href="#c-44">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = nums[0], f = nums[0];
        for (int i = 1; i &lt; nums.size(); ++i) {
            f = max(f, 0) + nums[i];
            ans = max(ans, f);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-35"><a class="header" href="#go-35">Go</a></h4>
<pre><code class="language-go">func maxSubArray(nums []int) int {
	ans, f := nums[0], nums[0]
	for _, x := range nums[1:] {
		f = max(f, 0) + x
		ans = max(ans, f)
	}
	return ans
}
</code></pre>
<h4 id="typescript-37"><a class="header" href="#typescript-37">TypeScript</a></h4>
<pre><code class="language-ts">function maxSubArray(nums: number[]): number {
    let [ans, f] = [nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        f = Math.max(f, 0) + nums[i];
        ans = Math.max(ans, f);
    }
    return ans;
}
</code></pre>
<h4 id="rust-19"><a class="header" href="#rust-19">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut ans = nums[0];
        let mut f = nums[0];
        for i in 1..n {
            f = f.max(0) + nums[i];
            ans = ans.max(f);
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-22"><a class="header" href="#javascript-22">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    let [ans, f] = [nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        f = Math.max(f, 0) + nums[i];
        ans = Math.max(ans, f);
    }
    return ans;
};
</code></pre>
<h4 id="c-45"><a class="header" href="#c-45">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int MaxSubArray(int[] nums) {
        int ans = nums[0], f = nums[0];
        for (int i = 1; i &lt; nums.Length; ++i) {
            f = Math.Max(f, 0) + nums[i];
            ans = Math.Max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-3"><a class="header" href="#solution-2-3">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-37"><a class="header" href="#python3-37">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        def crossMaxSub(nums, left, mid, right):
            lsum = rsum = 0
            lmx = rmx = -inf
            for i in range(mid, left - 1, -1):
                lsum += nums[i]
                lmx = max(lmx, lsum)
            for i in range(mid + 1, right + 1):
                rsum += nums[i]
                rmx = max(rmx, rsum)
            return lmx + rmx

        def maxSub(nums, left, right):
            if left == right:
                return nums[left]
            mid = (left + right) &gt;&gt; 1
            lsum = maxSub(nums, left, mid)
            rsum = maxSub(nums, mid + 1, right)
            csum = crossMaxSub(nums, left, mid, right)
            return max(lsum, rsum, csum)

        left, right = 0, len(nums) - 1
        return maxSub(nums, left, right)
</code></pre>
<h4 id="java-35"><a class="header" href="#java-35">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        return maxSub(nums, 0, nums.length - 1);
    }

    private int maxSub(int[] nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        int mid = (left + right) &gt;&gt;&gt; 1;
        int lsum = maxSub(nums, left, mid);
        int rsum = maxSub(nums, mid + 1, right);
        return Math.max(Math.max(lsum, rsum), crossMaxSub(nums, left, mid, right));
    }

    private int crossMaxSub(int[] nums, int left, int mid, int right) {
        int lsum = 0, rsum = 0;
        int lmx = Integer.MIN_VALUE, rmx = Integer.MIN_VALUE;
        for (int i = mid; i &gt;= left; --i) {
            lsum += nums[i];
            lmx = Math.max(lmx, lsum);
        }
        for (int i = mid + 1; i &lt;= right; ++i) {
            rsum += nums[i];
            rmx = Math.max(rmx, rsum);
        }
        return lmx + rmx;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 子数组最大累加和
// 给你一个整数数组 nums
// 返回非空子数组的最大累加和
// 测试链接 : https://leetcode.com/problems/maximum-subarray/
public class Code01_MaximumSubarray {

	// 动态规划
	public static int maxSubArray1(int[] nums) {
		int n = nums.length;
		// dp[i] : 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和
		int[] dp = new int[n];
		dp[0] = nums[0];
		int ans = nums[0];
		for (int i = 1; i &lt; n; i++) {
			dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}

	// 空间压缩
	public static int maxSubArray2(int[] nums) {
		int n = nums.length;
		int ans = nums[0];
		for (int i = 1, pre = nums[0]; i &lt; n; i++) {
			pre = Math.max(nums[i], pre + nums[i]);
			ans = Math.max(ans, pre);
		}
		return ans;
	}

	// 如下代码为附加问题的实现
	// 子数组中找到拥有最大累加和的子数组
	// 并返回如下三个信息:
	// 1) 最大累加和子数组的开头left
	// 2) 最大累加和子数组的结尾right
	// 3) 最大累加和子数组的累加和sum
	// 如果不止一个子数组拥有最大累加和，那么找到哪一个都可以
	public static int left;

	public static int right;

	public static int sum;

	// 找到拥有最大累加和的子数组
	// 更新好全局变量left、right、sum
	// 上游调用函数可以直接使用这三个变量
	// 相当于返回了三个值
	public static void extra(int[] nums) {
		sum = Integer.MIN_VALUE;
		for (int l = 0, r = 0, pre = Integer.MIN_VALUE; r &lt; nums.length; r++) {
			if (pre &gt;= 0) {
				// 吸收前面的累加和有利可图
				// 那就不换开头
				pre += nums[r];
			} else {
				// 吸收前面的累加和已经无利可图
				// 那就换开头
				pre = nums[r];
				l = r;
			}
			if (pre &gt; sum) {
				sum = pre;
				left = l;
				right = r;
			}
		}
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=75">
    </iframe>
</details>
<h2 id="houserobber"><a class="header" href="#houserobber">HouseRobber</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0100-0199/0198.House%20Robber/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="198-house-robber"><a class="header" href="#198-house-robber"><a href="https://leetcode.com/problems/house-robber">198. House Robber</a></a></h1>
<p><a href="dynamic-programming//solution/0100-0199/0198.House%20Robber/README.html">中文文档</a></p>
<h2 id="description-25"><a class="header" href="#description-25">Description</a></h2>
<!-- description:start -->
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,7,9,3,1]
<strong>Output:</strong> 12
<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-25"><a class="header" href="#solutions-25">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-memoization-search"><a class="header" href="#solution-1-memoization-search">Solution 1: Memoization Search</a></h3>
<p>We design a function $\textit{dfs}(i)$, which represents the maximum amount of money that can be stolen starting from the $i$-th house. Thus, the answer is $\textit{dfs}(0)$.</p>
<p>The execution process of the function $\textit{dfs}(i)$ is as follows:</p>
<ul>
<li>If $i \ge \textit{len}(\textit{nums})$, it means all houses have been considered, and we directly return $0$;</li>
<li>Otherwise, consider stealing from the $i$-th house, then $\textit{dfs}(i) = \textit{nums}[i] + \textit{dfs}(i+2)$; if not stealing from the $i$-th house, then $\textit{dfs}(i) = \textit{dfs}(i+1)$.</li>
<li>Return $\max(\textit{nums}[i] + \textit{dfs}(i+2), \textit{dfs}(i+1))$.</li>
</ul>
<p>To avoid repeated calculations, we use memoization search. The result of $\textit{dfs}(i)$ is saved in an array or hash table. Before each calculation, we first check if it has been calculated. If so, we directly return the result.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array.</p>
<!-- tabs:start -->
<h4 id="python3-38"><a class="header" href="#python3-38">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        @cache
        def dfs(i: int) -&gt; int:
            if i &gt;= len(nums):
                return 0
            return max(nums[i] + dfs(i + 2), dfs(i + 1))

        return dfs(0)
</code></pre>
<h4 id="java-36"><a class="header" href="#java-36">Java</a></h4>
<pre><code class="language-java">class Solution {
    private Integer[] f;
    private int[] nums;

    public int rob(int[] nums) {
        this.nums = nums;
        f = new Integer[nums.length];
        return dfs(0);
    }

    private int dfs(int i) {
        if (i &gt;= nums.length) {
            return 0;
        }
        if (f[i] == null) {
            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));
        }
        return f[i];
    }
}
</code></pre>
<h4 id="c-46"><a class="header" href="#c-46">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int f[n];
        memset(f, -1, sizeof(f));
        auto dfs = [&amp;](auto&amp;&amp; dfs, int i) -&gt; int {
            if (i &gt;= n) {
                return 0;
            }
            if (f[i] &lt; 0) {
                f[i] = max(nums[i] + dfs(dfs, i + 2), dfs(dfs, i + 1));
            }
            return f[i];
        };
        return dfs(dfs, 0);
    }
};
</code></pre>
<h4 id="go-36"><a class="header" href="#go-36">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	n := len(nums)
	f := make([]int, n)
	for i := range f {
		f[i] = -1
	}
	var dfs func(int) int
	dfs = func(i int) int {
		if i &gt;= n {
			return 0
		}
		if f[i] &lt; 0 {
			f[i] = max(nums[i]+dfs(i+2), dfs(i+1))
		}
		return f[i]
	}
	return dfs(0)
}
</code></pre>
<h4 id="typescript-38"><a class="header" href="#typescript-38">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    const n = nums.length;
    const f: number[] = Array(n).fill(-1);
    const dfs = (i: number): number =&gt; {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i] &lt; 0) {
            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));
        }
        return f[i];
    };
    return dfs(0);
}
</code></pre>
<h4 id="rust-20"><a class="header" href="#rust-20">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        fn dfs(i: usize, nums: &amp;Vec&lt;i32&gt;, f: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {
            if i &gt;= nums.len() {
                return 0;
            }
            if f[i] &lt; 0 {
                f[i] = (nums[i] + dfs(i + 2, nums, f)).max(dfs(i + 1, nums, f));
            }
            f[i]
        }

        let n = nums.len();
        let mut f = vec![-1; n];
        dfs(0, &amp;nums, &amp;mut f)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-23"><a class="header" href="#javascript-23">JavaScript</a></h4>
<pre><code class="language-js">function rob(nums) {
    const n = nums.length;
    const f = Array(n).fill(-1);
    const dfs = i =&gt; {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i] &lt; 0) {
            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));
        }
        return f[i];
    };
    return dfs(0);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-dynamic-programming-1"><a class="header" href="#solution-2-dynamic-programming-1">Solution 2: Dynamic Programming</a></h3>
<p>We define $f[i]$ as the maximum total amount that can be robbed from the first $i$ houses, initially $f[0]=0$, $f[1]=nums[0]$.</p>
<p>Consider the case where $i \gt 1$, the $i$th house has two options:</p>
<ul>
<li>Do not rob the $i$th house, the total amount of robbery is $f[i-1]$;</li>
<li>Rob the $i$th house, the total amount of robbery is $f[i-2]+nums[i-1]$;</li>
</ul>
<p>Therefore, we can get the state transition equation:</p>
<p>$$
f[i]=
\begin{cases}
0, &amp; i=0 \
nums[0], &amp; i=1 \
\max(f[i-1],f[i-2]+nums[i-1]), &amp; i \gt 1
\end{cases}
$$</p>
<p>The final answer is $f[n]$, where $n$ is the length of the array.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array.</p>
<!-- tabs:start -->
<h4 id="python3-39"><a class="header" href="#python3-39">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [0] * (n + 1)
        f[1] = nums[0]
        for i in range(2, n + 1):
            f[i] = max(f[i - 1], f[i - 2] + nums[i - 1])
        return f[n]
</code></pre>
<h4 id="java-37"><a class="header" href="#java-37">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] f = new int[n + 1];
        f[1] = nums[0];
        for (int i = 2; i &lt;= n; ++i) {
            f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
        }
        return f[n];
    }
}
</code></pre>
<h4 id="c-47"><a class="header" href="#c-47">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int f[n + 1];
        memset(f, 0, sizeof(f));
        f[1] = nums[0];
        for (int i = 2; i &lt;= n; ++i) {
            f[i] = max(f[i - 1], f[i - 2] + nums[i - 1]);
        }
        return f[n];
    }
};
</code></pre>
<h4 id="go-37"><a class="header" href="#go-37">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	n := len(nums)
	f := make([]int, n+1)
	f[1] = nums[0]
	for i := 2; i &lt;= n; i++ {
		f[i] = max(f[i-1], f[i-2]+nums[i-1])
	}
	return f[n]
}
</code></pre>
<h4 id="typescript-39"><a class="header" href="#typescript-39">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    const n = nums.length;
    const f: number[] = Array(n + 1).fill(0);
    f[1] = nums[0];
    for (let i = 2; i &lt;= n; ++i) {
        f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
    }
    return f[n];
}
</code></pre>
<h4 id="rust-21"><a class="header" href="#rust-21">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut f = vec![0; n + 1];
        f[1] = nums[0];
        for i in 2..=n {
            f[i] = f[i - 1].max(f[i - 2] + nums[i - 1]);
        }
        f[n]
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-24"><a class="header" href="#javascript-24">JavaScript</a></h4>
<pre><code class="language-js">function rob(nums) {
    const n = nums.length;
    const f = Array(n + 1).fill(0);
    f[1] = nums[0];
    for (let i = 2; i &lt;= n; ++i) {
        f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
    }
    return f[n];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-dynamic-programming-space-optimization"><a class="header" href="#solution-3-dynamic-programming-space-optimization">Solution 3: Dynamic Programming (Space Optimization)</a></h3>
<p>We notice that when $i \gt 2$, $f[i]$ is only related to $f[i-1]$ and $f[i-2]$. Therefore, we can use two variables instead of an array to reduce the space complexity to $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-40"><a class="header" href="#python3-40">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        f = g = 0
        for x in nums:
            f, g = max(f, g), f + x
        return max(f, g)
</code></pre>
<h4 id="java-38"><a class="header" href="#java-38">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int rob(int[] nums) {
        int f = 0, g = 0;
        for (int x : nums) {
            int ff = Math.max(f, g);
            g = f + x;
            f = ff;
        }
        return Math.max(f, g);
    }
}
</code></pre>
<h4 id="c-48"><a class="header" href="#c-48">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int f = 0, g = 0;
        for (int&amp; x : nums) {
            int ff = max(f, g);
            g = f + x;
            f = ff;
        }
        return max(f, g);
    }
};
</code></pre>
<h4 id="go-38"><a class="header" href="#go-38">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	f, g := 0, 0
	for _, x := range nums {
		f, g = max(f, g), f+x
	}
	return max(f, g)
}
</code></pre>
<h4 id="typescript-40"><a class="header" href="#typescript-40">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    let [f, g] = [0, 0];
    for (const x of nums) {
        [f, g] = [Math.max(f, g), f + x];
    }
    return Math.max(f, g);
}
</code></pre>
<h4 id="rust-22"><a class="header" href="#rust-22">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut f = [0, 0];
        for x in nums {
            f = [f[0].max(f[1]), f[0] + x];
        }
        f[0].max(f[1])
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-25"><a class="header" href="#javascript-25">JavaScript</a></h4>
<pre><code class="language-js">function rob(nums) {
    let [f, g] = [0, 0];
    for (const x of nums) {
        [f, g] = [Math.max(f, g), f + x];
    }
    return Math.max(f, g);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 数组中不能选相邻元素的最大累加和
// 给定一个数组，可以随意选择数字
// 但是不能选择相邻的数字，返回能得到的最大累加和
// 测试链接 : https://leetcode.com/problems/house-robber/
public class Code02_HouseRobber {

	// 动态规划
	public static int rob1(int[] nums) {
		int n = nums.length;
		if (n == 1) {
			return nums[0];
		}
		if (n == 2) {
			return Math.max(nums[0], nums[1]);
		}
		// dp[i] : nums[0...i]范围上可以随意选择数字，但是不能选相邻数，能得到的最大累加和
		int[] dp = new int[n];
		dp[0] = nums[0];
		dp[1] = Math.max(nums[0], nums[1]);
		for (int i = 2; i &lt; n; i++) {
			dp[i] = Math.max(dp[i - 1], Math.max(nums[i], dp[i - 2] + nums[i]));
		}
		return dp[n - 1];
	}

	// 空间压缩
	public static int rob2(int[] nums) {
		int n = nums.length;
		if (n == 1) {
			return nums[0];
		}
		if (n == 2) {
			return Math.max(nums[0], nums[1]);
		}
		int prepre = nums[0];
		int pre = Math.max(nums[0], nums[1]);
		for (int i = 2, cur; i &lt; n; i++) {
			cur = Math.max(pre, Math.max(nums[i], prepre + nums[i]));
			prepre = pre;
			pre = cur;
		}
		return pre;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=1685">
    </iframe>
</details>
<h2 id="maximumsumcircularsubarray"><a class="header" href="#maximumsumcircularsubarray">MaximumSumCircularSubarray</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0918.Maximum%20Sum%20Circular%20Subarray/README_EN.md
tags:
    - Queue
    - Array
    - Divide and Conquer
    - Dynamic Programming
    - Monotonic Queue
</code></pre>
<!-- problem:start -->
<h1 id="918-maximum-sum-circular-subarray"><a class="header" href="#918-maximum-sum-circular-subarray"><a href="https://leetcode.com/problems/maximum-sum-circular-subarray">918. Maximum Sum Circular Subarray</a></a></h1>
<p><a href="dynamic-programming//solution/0900-0999/0918.Maximum%20Sum%20Circular%20Subarray/README.html">中文文档</a></p>
<h2 id="description-26"><a class="header" href="#description-26">Description</a></h2>
<!-- description:start -->
<p>Given a <strong>circular integer array</strong> <code>nums</code> of length <code>n</code>, return <em>the maximum possible sum of a non-empty <strong>subarray</strong> of </em><code>nums</code>.</p>
<p>A <strong>circular array</strong> means the end of the array connects to the beginning of the array. Formally, the next element of <code>nums[i]</code> is <code>nums[(i + 1) % n]</code> and the previous element of <code>nums[i]</code> is <code>nums[(i - 1 + n) % n]</code>.</p>
<p>A <strong>subarray</strong> may only include each element of the fixed buffer <code>nums</code> at most once. Formally, for a subarray <code>nums[i], nums[i + 1], ..., nums[j]</code>, there does not exist <code>i &lt;= k1</code>, <code>k2 &lt;= j</code> with <code>k1 % n == k2 % n</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,-2,3,-2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Subarray [3] has maximum sum 3.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [5,-3,5]
<strong>Output:</strong> 10
<strong>Explanation:</strong> Subarray [5,5] has maximum sum 5 + 5 = 10.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [-3,-2,-3]
<strong>Output:</strong> -2
<strong>Explanation:</strong> Subarray [-2] has maximum sum -2.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-26"><a class="header" href="#solutions-26">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-maintain-prefix-maximum"><a class="header" href="#solution-1-maintain-prefix-maximum">Solution 1: Maintain Prefix Maximum</a></h3>
<p>The maximum sum of a circular subarray can be divided into two cases:</p>
<ul>
<li>Case 1: The subarray with the maximum sum does not include the circular part, which is the ordinary maximum subarray sum;</li>
<li>Case 2: The subarray with the maximum sum includes the circular part, which can be transformed into: the total sum of the array minus the minimum subarray sum.</li>
</ul>
<p>Therefore, we maintain the following variables:</p>
<ul>
<li>The minimum prefix sum $pmi$, initially $0$;</li>
<li>The maximum prefix sum $pmx$, initially $-\infty$;</li>
<li>The prefix sum $s$, initially $0$;</li>
<li>The minimum subarray sum $smi$, initially $\infty$;</li>
<li>The answer $ans$, initially $-\infty$.</li>
</ul>
<p>Next, we only need to traverse the array $nums$. For the current element $x$ we are traversing, we perform the following update operations:</p>
<ul>
<li>Update the prefix sum $s = s + x$;</li>
<li>Update the answer $ans = \max(ans, s - pmi)$, which is the answer for Case 1 (the prefix sum $s$ minus the minimum prefix sum $pmi$ can give the maximum subarray sum);</li>
<li>Update $smi = \min(smi, s - pmx)$, which is the minimum subarray sum for Case 2;</li>
<li>Update $pmi = \min(pmi, s)$, which is the minimum prefix sum;</li>
<li>Update $pmx = \max(pmx, s)$, which is the maximum prefix sum.</li>
</ul>
<p>After the traversal, we return the maximum value of $ans$ and $s - smi$ as the answer.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-41"><a class="header" href="#python3-41">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -&gt; int:
        pmi, pmx = 0, -inf
        ans, s, smi = -inf, 0, inf
        for x in nums:
            s += x
            ans = max(ans, s - pmi)
            smi = min(smi, s - pmx)
            pmi = min(pmi, s)
            pmx = max(pmx, s)
        return max(ans, s - smi)
</code></pre>
<h4 id="java-39"><a class="header" href="#java-39">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        final int inf = 1 &lt;&lt; 30;
        int pmi = 0, pmx = -inf;
        int ans = -inf, s = 0, smi = inf;
        for (int x : nums) {
            s += x;
            ans = Math.max(ans, s - pmi);
            smi = Math.min(smi, s - pmx);
            pmi = Math.min(pmi, s);
            pmx = Math.max(pmx, s);
        }
        return Math.max(ans, s - smi);
    }
}
</code></pre>
<h4 id="c-49"><a class="header" href="#c-49">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) {
        const int inf = 1 &lt;&lt; 30;
        int pmi = 0, pmx = -inf;
        int ans = -inf, s = 0, smi = inf;
        for (int x : nums) {
            s += x;
            ans = max(ans, s - pmi);
            smi = min(smi, s - pmx);
            pmi = min(pmi, s);
            pmx = max(pmx, s);
        }
        return max(ans, s - smi);
    }
};
</code></pre>
<h4 id="go-39"><a class="header" href="#go-39">Go</a></h4>
<pre><code class="language-go">func maxSubarraySumCircular(nums []int) int {
	const inf = 1 &lt;&lt; 30
	pmi, pmx := 0, -inf
	ans, s, smi := -inf, 0, inf
	for _, x := range nums {
		s += x
		ans = max(ans, s-pmi)
		smi = min(smi, s-pmx)
		pmi = min(pmi, s)
		pmx = max(pmx, s)
	}
	return max(ans, s-smi)
}
</code></pre>
<h4 id="typescript-41"><a class="header" href="#typescript-41">TypeScript</a></h4>
<pre><code class="language-ts">function maxSubarraySumCircular(nums: number[]): number {
    let [pmi, pmx] = [0, -Infinity];
    let [ans, s, smi] = [-Infinity, 0, Infinity];
    for (const x of nums) {
        s += x;
        ans = Math.max(ans, s - pmi);
        smi = Math.min(smi, s - pmx);
        pmi = Math.min(pmi, s);
        pmx = Math.max(pmx, s);
    }
    return Math.max(ans, s - smi);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 环形数组的子数组最大累加和
// 给定一个数组nums，长度为n
// nums是一个环形数组，下标0和下标n-1是连在一起的
// 返回环形数组中，子数组最大累加和
// 测试链接 : https://leetcode.com/problems/maximum-sum-circular-subarray/
public class Code03_MaximumSumCircularSubarray {

	public static int maxSubarraySumCircular(int[] nums) {
		int n = nums.length, all = nums[0], maxsum = nums[0], minsum = nums[0];
		for (int i = 1, maxpre = nums[0], minpre = nums[0]; i &lt; n; i++) {
			all += nums[i];
			maxpre = Math.max(nums[i], nums[i] + maxpre);
			maxsum = Math.max(maxsum, maxpre);
			minpre = Math.min(nums[i], nums[i] + minpre);
			minsum = Math.min(minsum, minpre);
		}
		// 1) maxsum
		// 2) all - minsum
		return all == minsum ? maxsum : Math.max(maxsum, all - minsum);
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=2320">
    </iframe>
</details>
<h2 id="houserobberii"><a class="header" href="#houserobberii">HouseRobberII</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0213.House%20Robber%20II/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="213-house-robber-ii"><a class="header" href="#213-house-robber-ii"><a href="https://leetcode.com/problems/house-robber-ii">213. House Robber II</a></a></h1>
<p><a href="dynamic-programming//solution/0200-0299/0213.House%20Robber%20II/README.html">中文文档</a></p>
<h2 id="description-27"><a class="header" href="#description-27">Description</a></h2>
<!-- description:start -->
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,3,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 3
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-27"><a class="header" href="#solutions-27">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-5"><a class="header" href="#solution-1-dynamic-programming-5">Solution 1: Dynamic Programming</a></h3>
<p>The circular arrangement means that at most one of the first and last houses can be chosen for theft, so this circular arrangement problem can be reduced to two single-row house problems.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-42"><a class="header" href="#python3-42">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        def _rob(nums):
            f = g = 0
            for x in nums:
                f, g = max(f, g), f + x
            return max(f, g)

        if len(nums) == 1:
            return nums[0]
        return max(_rob(nums[1:]), _rob(nums[:-1]))
</code></pre>
<h4 id="java-40"><a class="header" href="#java-40">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
    }

    private int rob(int[] nums, int l, int r) {
        int f = 0, g = 0;
        for (; l &lt;= r; ++l) {
            int ff = Math.max(f, g);
            g = f + nums[l];
            f = ff;
        }
        return Math.max(f, g);
    }
}
</code></pre>
<h4 id="c-50"><a class="header" href="#c-50">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        return max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }

    int robRange(vector&lt;int&gt;&amp; nums, int l, int r) {
        int f = 0, g = 0;
        for (; l &lt;= r; ++l) {
            int ff = max(f, g);
            g = f + nums[l];
            f = ff;
        }
        return max(f, g);
    }
};
</code></pre>
<h4 id="go-40"><a class="header" href="#go-40">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	n := len(nums)
	if n == 1 {
		return nums[0]
	}
	return max(robRange(nums, 0, n-2), robRange(nums, 1, n-1))
}

func robRange(nums []int, l, r int) int {
	f, g := 0, 0
	for _, x := range nums[l : r+1] {
		f, g = max(f, g), f+x
	}
	return max(f, g)
}
</code></pre>
<h4 id="typescript-42"><a class="header" href="#typescript-42">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    const n = nums.length;
    if (n === 1) {
        return nums[0];
    }
    const robRange = (l: number, r: number): number =&gt; {
        let [f, g] = [0, 0];
        for (; l &lt;= r; ++l) {
            [f, g] = [Math.max(f, g), f + nums[l]];
        }
        return Math.max(f, g);
    };
    return Math.max(robRange(0, n - 2), robRange(1, n - 1));
}
</code></pre>
<h4 id="rust-23"><a class="header" href="#rust-23">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        if n == 1 {
            return nums[0];
        }
        let rob_range = |l, r| {
            let mut f = [0, 0];
            for i in l..r {
                f = [f[0].max(f[1]), f[0] + nums[i]];
            }
            f[0].max(f[1])
        };
        rob_range(0, n - 1).max(rob_range(1, n))
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 环形数组中不能选相邻元素的最大累加和
// 给定一个数组nums，长度为n
// nums是一个环形数组，下标0和下标n-1是连在一起的
// 可以随意选择数字，但是不能选择相邻的数字
// 返回能得到的最大累加和
// 测试链接 : https://leetcode.com/problems/house-robber-ii/
public class Code04_HouseRobberII {

	public static int rob(int[] nums) {
		int n = nums.length;
		if (n == 1) {
			return nums[0];
		}
		return Math.max(best(nums, 1, n - 1), nums[0] + best(nums, 2, n - 2));
	}

	// nums[l....r]范围上，没有环形的概念
	// 返回 : 可以随意选择数字，但不能选择相邻数字的情况下，最大累加和
	public static int best(int[] nums, int l, int r) {
		if (l &gt; r) {
			return 0;
		}
		if (l == r) {
			return nums[l];
		}
		if (l + 1 == r) {
			return Math.max(nums[l], nums[r]);
		}
		int prepre = nums[l];
		int pre = Math.max(nums[l], nums[l + 1]);
		for (int i = l + 2, cur; i &lt;= r; i++) {
			cur = Math.max(pre, nums[i] + Math.max(0, prepre));
			prepre = pre;
			pre = cur;
		}
		return pre;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=2960">
    </iframe>
</details>
<h2 id="houserobberiv"><a class="header" href="#houserobberiv">HouseRobberIV</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/2500-2599/2560.House%20Robber%20IV/README_EN.md
rating: 2081
source: Weekly Contest 331 Q3
tags:
    - Array
    - Binary Search
</code></pre>
<!-- problem:start -->
<h1 id="2560-house-robber-iv"><a class="header" href="#2560-house-robber-iv"><a href="https://leetcode.com/problems/house-robber-iv">2560. House Robber IV</a></a></h1>
<p><a href="dynamic-programming//solution/2500-2599/2560.House%20Robber%20IV/README.html">中文文档</a></p>
<h2 id="description-28"><a class="header" href="#description-28">Description</a></h2>
<!-- description:start -->
<p>There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he <strong>refuses to steal from adjacent homes</strong>.</p>
<p>The <strong>capability</strong> of the robber is the maximum amount of money he steals from one house of all the houses he robbed.</p>
<p>You are given an integer array <code>nums</code> representing how much money is stashed in each house. More formally, the <code>i<sup>th</sup></code> house from the left has <code>nums[i]</code> dollars.</p>
<p>You are also given an integer <code>k</code>, representing the <strong>minimum</strong> number of houses the robber will steal from. It is always possible to steal at least <code>k</code> houses.</p>
<p>Return <em>the <strong>minimum</strong> capability of the robber out of all the possible ways to steal at least </em><code>k</code><em> houses</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,3,5,9], k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,7,9,3,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-28"><a class="header" href="#solutions-28">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-binary-search--greedy"><a class="header" href="#solution-1-binary-search--greedy">Solution 1: Binary Search + Greedy</a></h3>
<p>The problem is asking for the minimum stealing ability of the thief. We can use binary search to enumerate the stealing ability of the thief. For the enumerated ability $x$, we can use a greedy approach to determine whether the thief can steal at least $k$ houses. Specifically, we traverse the array from left to right. For the current house $i$ we are traversing, if $nums[i] \leq x$ and the difference between the index of $i$ and the last stolen house is greater than $1$, then the thief can steal house $i$. Otherwise, the thief cannot steal house $i$. We accumulate the number of stolen houses. If the number of stolen houses is greater than or equal to $k$, it means that the thief can steal at least $k$ houses, and at this time, the stealing ability $x$ of the thief might be the minimum. Otherwise, the stealing ability $x$ of the thief is not the minimum.</p>
<p>The time complexity is $O(n \times \log m)$, and the space complexity is $O(1)$. Where $n$ and $m$ are the length of the array $nums$ and the maximum value in the array $nums$, respectively.</p>
<!-- tabs:start -->
<h4 id="python3-43"><a class="header" href="#python3-43">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def minCapability(self, nums: List[int], k: int) -&gt; int:
        def f(x):
            cnt, j = 0, -2
            for i, v in enumerate(nums):
                if v &gt; x or i == j + 1:
                    continue
                cnt += 1
                j = i
            return cnt &gt;= k

        return bisect_left(range(max(nums) + 1), True, key=f)
</code></pre>
<h4 id="java-41"><a class="header" href="#java-41">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int minCapability(int[] nums, int k) {
        int left = 0, right = (int) 1e9;
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            if (f(nums, mid) &gt;= k) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int f(int[] nums, int x) {
        int cnt = 0, j = -2;
        for (int i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &gt; x || i == j + 1) {
                continue;
            }
            ++cnt;
            j = i;
        }
        return cnt;
    }
}
</code></pre>
<h4 id="c-51"><a class="header" href="#c-51">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int minCapability(vector&lt;int&gt;&amp; nums, int k) {
        auto f = [&amp;](int x) {
            int cnt = 0, j = -2;
            for (int i = 0; i &lt; nums.size(); ++i) {
                if (nums[i] &gt; x || i == j + 1) {
                    continue;
                }
                ++cnt;
                j = i;
            }
            return cnt &gt;= k;
        };
        int left = 0, right = *max_element(nums.begin(), nums.end());
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            if (f(mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
</code></pre>
<h4 id="go-41"><a class="header" href="#go-41">Go</a></h4>
<pre><code class="language-go">func minCapability(nums []int, k int) int {
	return sort.Search(1e9+1, func(x int) bool {
		cnt, j := 0, -2
		for i, v := range nums {
			if v &gt; x || i == j+1 {
				continue
			}
			cnt++
			j = i
		}
		return cnt &gt;= k
	})
}
</code></pre>
<h4 id="typescript-43"><a class="header" href="#typescript-43">TypeScript</a></h4>
<pre><code class="language-ts">function minCapability(nums: number[], k: number): number {
    const f = (mx: number): boolean =&gt; {
        let cnt = 0;
        let j = -2;
        for (let i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &lt;= mx &amp;&amp; i - j &gt; 1) {
                ++cnt;
                j = i;
            }
        }
        return cnt &gt;= k;
    };

    let left = 1;
    let right = Math.max(...nums);
    while (left &lt; right) {
        const mid = (left + right) &gt;&gt; 1;
        if (f(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 打家劫舍 IV
// 沿街有一排连续的房屋。每间房屋内都藏有一定的现金
// 现在有一位小偷计划从这些房屋中窃取现金
// 由于相邻的房屋装有相互连通的防盗系统，所以小偷不会窃取相邻的房屋
// 小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额
// 给你一个整数数组 nums 表示每间房屋存放的现金金额
// 第i间房屋中放有nums[i]的钱数
// 另给你一个整数k，表示小偷需要窃取至少 k 间房屋
// 返回小偷需要的最小窃取能力值
// 测试链接 : https://leetcode.com/problems/house-robber-iv/
public class Code05_HouseRobberIV {

	public static int minCapability(int[] nums, int k) {
		int n = nums.length, l = nums[0], r = nums[0];
		for (int i = 1; i &lt; n; i++) {
			l = Math.min(l, nums[i]);
			r = Math.max(r, nums[i]);
		}
		// l....r
		int m, ans = 0;
		while (l &lt;= r) {
			m = (l + r) / 2;
			if (mostRob1(nums, n, m) &gt;= k) {
				ans = m;
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		return ans;
	}

	// 盗贼能力为ability时
	// 返回盗贼最多能窃取多少间房屋
	// 注意限制 : 不能窃取相邻房屋
	public static int mostRob1(int[] nums, int n, int ability) {
		if (n == 1) {
			return nums[0] &lt;= ability ? 1 : 0;
		}
		if (n == 2) {
			return (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		}
		int[] dp = new int[n];
		dp[0] = nums[0] &lt;= ability ? 1 : 0;
		dp[1] = (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		for (int i = 2; i &lt; n; i++) {
			dp[i] = Math.max(dp[i - 1], (nums[i] &lt;= ability ? 1 : 0) + dp[i - 2]);
		}
		return dp[n - 1];
	}

	// 继续空间压缩优化
	public static int mostRob2(int[] nums, int n, int ability) {
		if (n == 1) {
			return nums[0] &lt;= ability ? 1 : 0;
		}
		if (n == 2) {
			return (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		}
		int prepre = nums[0] &lt;= ability ? 1 : 0;
		int pre = (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		for (int i = 2, cur; i &lt; n; i++) {
			cur = Math.max(pre, (nums[i] &lt;= ability ? 1 : 0) + prepre);
			prepre = pre;
			pre = cur;
		}
		return pre;
	}

	// 继续贪心优化
	public static int mostRob3(int[] nums, int n, int ability) {
		int ans = 0;
		for (int i = 0; i &lt; n; i++) {
			if (nums[i] &lt;= ability) {
				ans++;
				i++;
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=3264">
    </iframe>
</details>
<h2 id="maximumsubmatrix"><a class="header" href="#maximumsubmatrix">MaximumSubmatrix</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">// 子矩阵最大累加和问题
// 给定一个二维数组grid，找到其中子矩阵的最大累加和
// 返回拥有最大累加和的子矩阵左上角和右下角坐标
// 如果有多个子矩阵都有最大累加和，返回哪一个都可以
// 测试链接 : https://leetcode.com/problems/max-submatrix-lcci/
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

import java.util.Arrays;

// 子矩阵最大累加和问题
// 给定一个二维数组grid，找到其中子矩阵的最大累加和
// 返回拥有最大累加和的子矩阵左上角和右下角坐标
// 如果有多个子矩阵都有最大累加和，返回哪一个都可以
// 测试链接 : https://leetcode.com/problems/max-submatrix-lcci/
public class Code06_MaximumSubmatrix {

	// 如果行和列的规模都是n，时间复杂度O(n^3)，最优解了
	public static int[] getMaxMatrix(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int max = Integer.MIN_VALUE;
		int a = 0, b = 0, c = 0, d = 0;
		int[] nums = new int[m];
		for (int up = 0; up &lt; n; up++) {
			Arrays.fill(nums, 0);
			for (int down = up; down &lt; n; down++) {
				// 如下代码就是题目1的附加问题 :
				// 子数组中找到拥有最大累加和的子数组
				for (int l = 0, r = 0, pre = Integer.MIN_VALUE; r &lt; m; r++) {
					nums[r] += grid[down][r];
					if (pre &gt;= 0) {
						pre += nums[r];
					} else {
						pre = nums[r];
						l = r;
					}
					if (pre &gt; max) {
						max = pre;
						a = up;
						b = l;
						c = down;
						d = r;
					}
				}
			}
		}
		return new int[] { a, b, c, d };
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=4417">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-subarray-sum-part-2"><a class="header" href="#largest-subarray-sum-part-2">Largest Subarray Sum (part 2)</a></h1>
<h2 id="maximum-product-subarray"><a class="header" href="#maximum-product-subarray">Maximum Product Subarray</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0100-0199/0152.Maximum%20Product%20Subarray/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="152-maximum-product-subarray"><a class="header" href="#152-maximum-product-subarray"><a href="https://leetcode.com/problems/maximum-product-subarray">152. Maximum Product Subarray</a></a></h1>
<p><a href="dynamic-programming//solution/0100-0199/0152.Maximum%20Product%20Subarray/README.html">中文文档</a></p>
<h2 id="description-29"><a class="header" href="#description-29">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code>, find a <span data-keyword="subarray-nonempty">subarray</span> that has the largest product, and return <em>the product</em>.</p>
<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,3,-2,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> [2,3] has the largest product 6.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [-2,0,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li>The product of any subarray of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-29"><a class="header" href="#solutions-29">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-6"><a class="header" href="#solution-1-6">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-44"><a class="header" href="#python3-44">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        ans = f = g = nums[0]
        for x in nums[1:]:
            ff, gg = f, g
            f = max(x, ff * x, gg * x)
            g = min(x, ff * x, gg * x)
            ans = max(ans, f)
        return ans
</code></pre>
<h4 id="java-42"><a class="header" href="#java-42">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxProduct(int[] nums) {
        int f = nums[0], g = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.length; ++i) {
            int ff = f, gg = g;
            f = Math.max(nums[i], Math.max(ff * nums[i], gg * nums[i]));
            g = Math.min(nums[i], Math.min(ff * nums[i], gg * nums[i]));
            ans = Math.max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-52"><a class="header" href="#c-52">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int f = nums[0], g = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.size(); ++i) {
            int ff = f, gg = g;
            f = max({nums[i], ff * nums[i], gg * nums[i]});
            g = min({nums[i], ff * nums[i], gg * nums[i]});
            ans = max(ans, f);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-42"><a class="header" href="#go-42">Go</a></h4>
<pre><code class="language-go">func maxProduct(nums []int) int {
	f, g, ans := nums[0], nums[0], nums[0]
	for _, x := range nums[1:] {
		ff, gg := f, g
		f = max(x, max(ff*x, gg*x))
		g = min(x, min(ff*x, gg*x))
		ans = max(ans, f)
	}
	return ans
}
</code></pre>
<h4 id="typescript-44"><a class="header" href="#typescript-44">TypeScript</a></h4>
<pre><code class="language-ts">function maxProduct(nums: number[]): number {
    let [f, g, ans] = [nums[0], nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        const [ff, gg] = [f, g];
        f = Math.max(nums[i], ff * nums[i], gg * nums[i]);
        g = Math.min(nums[i], ff * nums[i], gg * nums[i]);
        ans = Math.max(ans, f);
    }
    return ans;
}
</code></pre>
<h4 id="rust-24"><a class="header" href="#rust-24">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn max_product(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut f = nums[0];
        let mut g = nums[0];
        let mut ans = nums[0];
        for &amp;x in nums.iter().skip(1) {
            let (ff, gg) = (f, g);
            f = x.max(x * ff).max(x * gg);
            g = x.min(x * ff).min(x * gg);
            ans = ans.max(f);
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-26"><a class="header" href="#javascript-26">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {
    let [f, g, ans] = [nums[0], nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        const [ff, gg] = [f, g];
        f = Math.max(nums[i], ff * nums[i], gg * nums[i]);
        g = Math.min(nums[i], ff * nums[i], gg * nums[i]);
        ans = Math.max(ans, f);
    }
    return ans;
};
</code></pre>
<h4 id="c-53"><a class="header" href="#c-53">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int MaxProduct(int[] nums) {
        int f = nums[0], g = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.Length; ++i) {
            int ff = f, gg = g;
            f = Math.Max(nums[i], Math.Max(ff * nums[i], gg * nums[i]));
            g = Math.Min(nums[i], Math.Min(ff * nums[i], gg * nums[i]));
            ans = Math.Max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 乘积最大子数组
// 给你一个整数数组 nums
// 请你找出数组中乘积最大的非空连续子数组
// 并返回该子数组所对应的乘积
// 测试链接 : https://leetcode.com/problems/maximum-product-subarray/
public class Code01_MaximumProductSubarray {

	// 这节课讲完之后，测试数据又增加了
	// 用int类型的变量会让中间结果溢出
	// 所以改成用double类型的变量
	// 思路是不变的
	public static int maxProduct(int[] nums) {
		double ans = nums[0], min = nums[0], max = nums[0], curmin, curmax;
		for (int i = 1; i &lt; nums.length; i++) {
			curmin = Math.min(nums[i], Math.min(min * nums[i], max * nums[i]));
			curmax = Math.max(nums[i], Math.max(min * nums[i], max * nums[i]));
			min = curmin;
			max = curmax;
			ans = Math.max(ans, max);
		}
		return (int) ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="max-sum-divided-by-7"><a class="header" href="#max-sum-divided-by-7">Max Sum Divided By 7</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 子序列累加和必须被7整除的最大累加和
// 给定一个非负数组nums，
// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除
// 返回最大累加和
// 对数器验证
public class Code02_MaxSumDividedBy7 {

	// 暴力方法
	// 为了验证
	public static int maxSum1(int[] nums) {
		// nums形成的所有子序列的累加和都求出来
		// 其中%7==0的那些累加和中，返回最大的
		// 就是如下f函数的功能
		return f(nums, 0, 0);
	}

	public static int f(int[] nums, int i, int s) {
		if (i == nums.length) {
			return s % 7 == 0 ? s : 0;
		}
		return Math.max(f(nums, i + 1, s), f(nums, i + 1, s + nums[i]));
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		// dp[i][j] : nums[0...i-1]
		// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j
		// 这样的子序列最大累加和是多少
		// 注意 : dp[i][j] == -1代表不存在这样的子序列
		int[][] dp = new int[n + 1][7];
		dp[0][0] = 0;
		for (int j = 1; j &lt; 7; j++) {
			dp[0][j] = -1;
		}
		for (int i = 1, x, cur, need; i &lt;= n; i++) {
			x = nums[i - 1];
			cur = nums[i - 1] % 7;
			for (int j = 0; j &lt; 7; j++) {
				dp[i][j] = dp[i - 1][j];
				// 这里求need是核心
				need = cur &lt;= j ? (j - cur) : (j - cur + 7);
				// 或者如下这种写法也对
				// need = (7 + j - cur) % 7;
				if (dp[i - 1][need] != -1) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][need] + x);
				}
			}
		}
		return dp[n][0];
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * v);
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 15;
		int v = 30;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 子序列累加和必须被7整除的最大累加和
// 给定一个非负数组nums，
// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除
// 返回最大累加和
// 对数器验证
public class Code02_MaxSumDividedBy7 {

	// 暴力方法
	// 为了验证
	public static int maxSum1(int[] nums) {
		// nums形成的所有子序列的累加和都求出来
		// 其中%7==0的那些累加和中，返回最大的
		// 就是如下f函数的功能
		return f(nums, 0, 0);
	}

	public static int f(int[] nums, int i, int s) {
		if (i == nums.length) {
			return s % 7 == 0 ? s : 0;
		}
		return Math.max(f(nums, i + 1, s), f(nums, i + 1, s + nums[i]));
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		// dp[i][j] : nums[0...i-1]
		// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j
		// 这样的子序列最大累加和是多少
		// 注意 : dp[i][j] == -1代表不存在这样的子序列
		int[][] dp = new int[n + 1][7];
		dp[0][0] = 0;
		for (int j = 1; j &lt; 7; j++) {
			dp[0][j] = -1;
		}
		for (int i = 1, x, cur, need; i &lt;= n; i++) {
			x = nums[i - 1];
			cur = nums[i - 1] % 7;
			for (int j = 0; j &lt; 7; j++) {
				dp[i][j] = dp[i - 1][j];
				// 这里求need是核心
				need = cur &lt;= j ? (j - cur) : (j - cur + 7);
				// 或者如下这种写法也对
				// need = (7 + j - cur) % 7;
				if (dp[i - 1][need] != -1) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][need] + x);
				}
			}
		}
		return dp[n][0];
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * v);
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 15;
		int v = 30;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="magic-scroll-probelm"><a class="header" href="#magic-scroll-probelm">Magic Scroll Probelm</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 魔法卷轴
// 给定一个数组nums，其中可能有正、负、0
// 每个魔法卷轴可以把nums中连续的一段全变成0
// 你希望数组整体的累加和尽可能大
// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴
// 请返回数组尽可能大的累加和
// 对数器验证
public class Code03_MagicScrollProbelm {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums) {
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		int n = nums.length;
		int p2 = mustOneScroll(nums, 0, n - 1);
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			p3 = Math.max(p3, mustOneScroll(nums, 0, i - 1) + mustOneScroll(nums, i, n - 1));
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 暴力方法
	// 为了测试
	// nums[l...r]范围上一定要用一次卷轴情况下的最大累加和
	public static int mustOneScroll(int[] nums, int l, int r) {
		int ans = Integer.MIN_VALUE;
		// l...r范围上包含a...b范围
		// 如果a...b范围上的数字都变成0
		// 返回剩下数字的累加和
		// 所以枚举所有可能的a...b范围
		// 相当暴力，但是正确
		for (int a = l; a &lt;= r; a++) {
			for (int b = a; b &lt;= r; b++) {
				// l...a...b...r
				int curAns = 0;
				for (int i = l; i &lt; a; i++) {
					curAns += nums[i];
				}
				for (int i = b + 1; i &lt;= r; i++) {
					curAns += nums[i];
				}
				ans = Math.max(ans, curAns);
			}
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		if (n == 0) {
			return 0;
		}
		// 情况1 : 完全不使用卷轴
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		// prefix[i] : 0~i范围上一定要用1次卷轴的情况下，0~i范围上整体最大累加和多少
		int[] prefix = new int[n];
		// 每一步的前缀和
		int sum = nums[0];
		// maxPresum : 之前所有前缀和的最大值
		int maxPresum = Math.max(0, nums[0]);
		for (int i = 1; i &lt; n; i++) {
			prefix[i] = Math.max(prefix[i - 1] + nums[i], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用1次卷轴
		int p2 = prefix[n - 1];
		// suffix[i] : i~n-1范围上一定要用1次卷轴的情况下，i~n-1范围上整体最大累加和多少
		int[] suffix = new int[n];
		sum = nums[n - 1];
		maxPresum = Math.max(0, sum);
		for (int i = n - 2; i &gt;= 0; i--) {
			suffix[i] = Math.max(nums[i] + suffix[i + 1], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用2次卷轴
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			// 枚举所有的划分点i
			// 0~i-1 左
			// i~n-1 右
			p3 = Math.max(p3, prefix[i - 1] + suffix[i]);
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 为了测试
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	public static void main(String[] args) {
		int n = 50;
		int v = 100;
		int testTime = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n);
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 魔法卷轴
// 给定一个数组nums，其中可能有正、负、0
// 每个魔法卷轴可以把nums中连续的一段全变成0
// 你希望数组整体的累加和尽可能大
// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴
// 请返回数组尽可能大的累加和
// 对数器验证
public class Code03_MagicScrollProbelm {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums) {
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		int n = nums.length;
		int p2 = mustOneScroll(nums, 0, n - 1);
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			p3 = Math.max(p3, mustOneScroll(nums, 0, i - 1) + mustOneScroll(nums, i, n - 1));
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 暴力方法
	// 为了测试
	// nums[l...r]范围上一定要用一次卷轴情况下的最大累加和
	public static int mustOneScroll(int[] nums, int l, int r) {
		int ans = Integer.MIN_VALUE;
		// l...r范围上包含a...b范围
		// 如果a...b范围上的数字都变成0
		// 返回剩下数字的累加和
		// 所以枚举所有可能的a...b范围
		// 相当暴力，但是正确
		for (int a = l; a &lt;= r; a++) {
			for (int b = a; b &lt;= r; b++) {
				// l...a...b...r
				int curAns = 0;
				for (int i = l; i &lt; a; i++) {
					curAns += nums[i];
				}
				for (int i = b + 1; i &lt;= r; i++) {
					curAns += nums[i];
				}
				ans = Math.max(ans, curAns);
			}
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSum2(int[] nums) {
		int n = nums.length;
		if (n == 0) {
			return 0;
		}
		// 情况1 : 完全不使用卷轴
		int p1 = 0;
		for (int num : nums) {
			p1 += num;
		}
		// prefix[i] : 0~i范围上一定要用1次卷轴的情况下，0~i范围上整体最大累加和多少
		int[] prefix = new int[n];
		// 每一步的前缀和
		int sum = nums[0];
		// maxPresum : 之前所有前缀和的最大值
		int maxPresum = Math.max(0, nums[0]);
		for (int i = 1; i &lt; n; i++) {
			prefix[i] = Math.max(prefix[i - 1] + nums[i], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用1次卷轴
		int p2 = prefix[n - 1];
		// suffix[i] : i~n-1范围上一定要用1次卷轴的情况下，i~n-1范围上整体最大累加和多少
		int[] suffix = new int[n];
		sum = nums[n - 1];
		maxPresum = Math.max(0, sum);
		for (int i = n - 2; i &gt;= 0; i--) {
			suffix[i] = Math.max(nums[i] + suffix[i + 1], maxPresum);
			sum += nums[i];
			maxPresum = Math.max(maxPresum, sum);
		}
		// 情况二 : 必须用2次卷轴
		int p3 = Integer.MIN_VALUE;
		for (int i = 1; i &lt; n; i++) {
			// 枚举所有的划分点i
			// 0~i-1 左
			// i~n-1 右
			p3 = Math.max(p3, prefix[i - 1] + suffix[i]);
		}
		return Math.max(p1, Math.max(p2, p3));
	}

	// 为了测试
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	public static void main(String[] args) {
		int n = 50;
		int v = 100;
		int testTime = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n);
			int[] nums = randomArray(len, v);
			int ans1 = maxSum1(nums);
			int ans2 = maxSum2(nums);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="maximum-sum-of-3-non-overlapping-subarrays"><a class="header" href="#maximum-sum-of-3-non-overlapping-subarrays">Maximum Sum of 3 Non-Overlapping Subarrays</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0689.Maximum%20Sum%20of%203%20Non-Overlapping%20Subarrays/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="689-maximum-sum-of-3-non-overlapping-subarrays"><a class="header" href="#689-maximum-sum-of-3-non-overlapping-subarrays"><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays">689. Maximum Sum of 3 Non-Overlapping Subarrays</a></a></h1>
<p><a href="dynamic-programming//solution/0600-0699/0689.Maximum%20Sum%20of%203%20Non-Overlapping%20Subarrays/README.html">中文文档</a></p>
<h2 id="description-30"><a class="header" href="#description-30">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, find three non-overlapping subarrays of length <code>k</code> with maximum sum and return them.</p>
<p>Return the result as a list of indices representing the starting position of each interval (<strong>0-indexed</strong>). If there are multiple answers, return the lexicographically smallest one.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,1,2,6,7,5,1], k = 2
<strong>Output:</strong> [0,3,5]
<strong>Explanation:</strong> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,1,2,1,2,1,2,1], k = 2
<strong>Output:</strong> [0,2,4]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>
	<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-30"><a class="header" href="#solutions-30">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-sliding-window"><a class="header" href="#solution-1-sliding-window">Solution 1: Sliding Window</a></h3>
<p>We use a sliding window to enumerate the position of the third subarray, while maintaining the maximum sum and its position of the first two non-overlapping subarrays.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-45"><a class="header" href="#python3-45">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -&gt; List[int]:
        s = s1 = s2 = s3 = 0
        mx1 = mx12 = 0
        idx1, idx12 = 0, ()
        ans = []
        for i in range(k * 2, len(nums)):
            s1 += nums[i - k * 2]
            s2 += nums[i - k]
            s3 += nums[i]
            if i &gt;= k * 3 - 1:
                if s1 &gt; mx1:
                    mx1 = s1
                    idx1 = i - k * 3 + 1
                if mx1 + s2 &gt; mx12:
                    mx12 = mx1 + s2
                    idx12 = (idx1, i - k * 2 + 1)
                if mx12 + s3 &gt; s:
                    s = mx12 + s3
                    ans = [*idx12, i - k + 1]
                s1 -= nums[i - k * 3 + 1]
                s2 -= nums[i - k * 2 + 1]
                s3 -= nums[i - k + 1]
        return ans
</code></pre>
<h4 id="java-43"><a class="header" href="#java-43">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int[] ans = new int[3];
        int s = 0, s1 = 0, s2 = 0, s3 = 0;
        int mx1 = 0, mx12 = 0;
        int idx1 = 0, idx121 = 0, idx122 = 0;
        for (int i = k * 2; i &lt; nums.length; ++i) {
            s1 += nums[i - k * 2];
            s2 += nums[i - k];
            s3 += nums[i];
            if (i &gt;= k * 3 - 1) {
                if (s1 &gt; mx1) {
                    mx1 = s1;
                    idx1 = i - k * 3 + 1;
                }
                if (mx1 + s2 &gt; mx12) {
                    mx12 = mx1 + s2;
                    idx121 = idx1;
                    idx122 = i - k * 2 + 1;
                }
                if (mx12 + s3 &gt; s) {
                    s = mx12 + s3;
                    ans = new int[] {idx121, idx122, i - k + 1};
                }
                s1 -= nums[i - k * 3 + 1];
                s2 -= nums[i - k * 2 + 1];
                s3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-54"><a class="header" href="#c-54">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; ans(3);
        int s = 0, s1 = 0, s2 = 0, s3 = 0;
        int mx1 = 0, mx12 = 0;
        int idx1 = 0, idx121 = 0, idx122 = 0;
        for (int i = k * 2; i &lt; nums.size(); ++i) {
            s1 += nums[i - k * 2];
            s2 += nums[i - k];
            s3 += nums[i];
            if (i &gt;= k * 3 - 1) {
                if (s1 &gt; mx1) {
                    mx1 = s1;
                    idx1 = i - k * 3 + 1;
                }
                if (mx1 + s2 &gt; mx12) {
                    mx12 = mx1 + s2;
                    idx121 = idx1;
                    idx122 = i - k * 2 + 1;
                }
                if (mx12 + s3 &gt; s) {
                    s = mx12 + s3;
                    ans = {idx121, idx122, i - k + 1};
                }
                s1 -= nums[i - k * 3 + 1];
                s2 -= nums[i - k * 2 + 1];
                s3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-43"><a class="header" href="#go-43">Go</a></h4>
<pre><code class="language-go">func maxSumOfThreeSubarrays(nums []int, k int) []int {
	ans := make([]int, 3)
	s, s1, s2, s3 := 0, 0, 0, 0
	mx1, mx12 := 0, 0
	idx1, idx121, idx122 := 0, 0, 0
	for i := k * 2; i &lt; len(nums); i++ {
		s1 += nums[i-k*2]
		s2 += nums[i-k]
		s3 += nums[i]
		if i &gt;= k*3-1 {
			if s1 &gt; mx1 {
				mx1 = s1
				idx1 = i - k*3 + 1
			}
			if mx1+s2 &gt; mx12 {
				mx12 = mx1 + s2
				idx121 = idx1
				idx122 = i - k*2 + 1
			}
			if mx12+s3 &gt; s {
				s = mx12 + s3
				ans = []int{idx121, idx122, i - k + 1}
			}
			s1 -= nums[i-k*3+1]
			s2 -= nums[i-k*2+1]
			s3 -= nums[i-k+1]
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-45"><a class="header" href="#typescript-45">TypeScript</a></h4>
<pre><code class="language-ts">function maxSumOfThreeSubarrays(nums: number[], k: number): number[] {
    const n: number = nums.length;
    const s: number[] = Array(n + 1).fill(0);

    for (let i = 0; i &lt; n; ++i) {
        s[i + 1] = s[i] + nums[i];
    }

    const pre: number[][] = Array(n)
        .fill([])
        .map(() =&gt; new Array(2).fill(0));
    const suf: number[][] = Array(n)
        .fill([])
        .map(() =&gt; new Array(2).fill(0));

    for (let i = 0, t = 0, idx = 0; i &lt; n - k + 1; ++i) {
        const cur: number = s[i + k] - s[i];
        if (cur &gt; t) {
            pre[i + k - 1] = [cur, i];
            t = cur;
            idx = i;
        } else {
            pre[i + k - 1] = [t, idx];
        }
    }

    for (let i = n - k, t = 0, idx = 0; i &gt;= 0; --i) {
        const cur: number = s[i + k] - s[i];
        if (cur &gt;= t) {
            suf[i] = [cur, i];
            t = cur;
            idx = i;
        } else {
            suf[i] = [t, idx];
        }
    }

    let ans: number[] = [];
    for (let i = k, t = 0; i &lt; n - 2 * k + 1; ++i) {
        const cur: number = s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0];
        if (cur &gt; t) {
            ans = [pre[i - 1][1], i, suf[i + k][1]];
            t = cur;
        }
    }

    return ans;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-preprocessing-prefix-and-suffix--enumerating-middle-subarray"><a class="header" href="#solution-2-preprocessing-prefix-and-suffix--enumerating-middle-subarray">Solution 2: Preprocessing Prefix and Suffix + Enumerating Middle Subarray</a></h3>
<p>We can preprocess to get the prefix sum array $s$ of the array $nums$, where $s[i] = \sum_{j=0}^{i-1} nums[j]$. Then for any $i$, $j$, $s[j] - s[i]$ is the sum of the subarray $[i, j)$.</p>
<p>Next, we use dynamic programming to maintain two arrays $pre$ and $suf$ of length $n$, where $pre[i]$ represents the maximum sum and its starting position of the subarray of length $k$ within the range $[0, i]$, and $suf[i]$ represents the maximum sum and its starting position of the subarray of length $k$ within the range $[i, n)$.</p>
<p>Then, we enumerate the starting position $i$ of the middle subarray. The sum of the three subarrays is $pre[i-1][0] + suf[i+k][0] + (s[i+k] - s[i])$, where $pre[i-1][0]$ represents the maximum sum of the subarray of length $k$ within the range $[0, i-1]$, $suf[i+k][0]$ represents the maximum sum of the subarray of length $k$ within the range $[i+k, n)$, and $(s[i+k] - s[i])$ represents the sum of the subarray of length $k$ within the range $[i, i+k)$. We find the starting positions of the three subarrays corresponding to the maximum sum.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$.</p>
<!-- tabs:start -->
<h4 id="python3-46"><a class="header" href="#python3-46">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -&gt; List[int]:
        n = len(nums)
        s = list(accumulate(nums, initial=0))
        pre = [[] for _ in range(n)]
        suf = [[] for _ in range(n)]
        t = idx = 0
        for i in range(n - k + 1):
            if (cur := s[i + k] - s[i]) &gt; t:
                pre[i + k - 1] = [cur, i]
                t, idx = pre[i + k - 1]
            else:
                pre[i + k - 1] = [t, idx]
        t = idx = 0
        for i in range(n - k, -1, -1):
            if (cur := s[i + k] - s[i]) &gt;= t:
                suf[i] = [cur, i]
                t, idx = suf[i]
            else:
                suf[i] = [t, idx]
        t = 0
        ans = []
        for i in range(k, n - 2 * k + 1):
            if (cur := s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0]) &gt; t:
                ans = [pre[i - 1][1], i, suf[i + k][1]]
                t = cur
        return ans
</code></pre>
<h4 id="java-44"><a class="header" href="#java-44">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int n = nums.length;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; ++i) {
            s[i + 1] = s[i] + nums[i];
        }
        int[][] pre = new int[n][0];
        int[][] suf = new int[n][0];
        for (int i = 0, t = 0, idx = 0; i &lt; n - k + 1; ++i) {
            int cur = s[i + k] - s[i];
            if (cur &gt; t) {
                pre[i + k - 1] = new int[] {cur, i};
                t = cur;
                idx = i;
            } else {
                pre[i + k - 1] = new int[] {t, idx};
            }
        }
        for (int i = n - k, t = 0, idx = 0; i &gt;= 0; --i) {
            int cur = s[i + k] - s[i];
            if (cur &gt;= t) {
                suf[i] = new int[] {cur, i};
                t = cur;
                idx = i;
            } else {
                suf[i] = new int[] {t, idx};
            }
        }
        int[] ans = new int[0];
        for (int i = k, t = 0; i &lt; n - 2 * k + 1; ++i) {
            int cur = s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0];
            if (cur &gt; t) {
                ans = new int[] {pre[i - 1][1], i, suf[i + k][1]};
                t = cur;
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-55"><a class="header" href="#c-55">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;int&gt; s(n + 1, 0);
        for (int i = 0; i &lt; n; ++i) {
            s[i + 1] = s[i] + nums[i];
        }

        vector&lt;vector&lt;int&gt;&gt; pre(n, vector&lt;int&gt;(2, 0));
        vector&lt;vector&lt;int&gt;&gt; suf(n, vector&lt;int&gt;(2, 0));

        for (int i = 0, t = 0, idx = 0; i &lt; n - k + 1; ++i) {
            int cur = s[i + k] - s[i];
            if (cur &gt; t) {
                pre[i + k - 1] = {cur, i};
                t = cur;
                idx = i;
            } else {
                pre[i + k - 1] = {t, idx};
            }
        }

        for (int i = n - k, t = 0, idx = 0; i &gt;= 0; --i) {
            int cur = s[i + k] - s[i];
            if (cur &gt;= t) {
                suf[i] = {cur, i};
                t = cur;
                idx = i;
            } else {
                suf[i] = {t, idx};
            }
        }

        vector&lt;int&gt; ans;
        for (int i = k, t = 0; i &lt; n - 2 * k + 1; ++i) {
            int cur = s[i + k] - s[i] + pre[i - 1][0] + suf[i + k][0];
            if (cur &gt; t) {
                ans = {pre[i - 1][1], i, suf[i + k][1]};
                t = cur;
            }
        }

        return ans;
    }
};
</code></pre>
<h4 id="go-44"><a class="header" href="#go-44">Go</a></h4>
<pre><code class="language-go">func maxSumOfThreeSubarrays(nums []int, k int) (ans []int) {
	n := len(nums)
	s := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		s[i+1] = s[i] + nums[i]
	}

	pre := make([][]int, n)
	suf := make([][]int, n)

	for i, t, idx := 0, 0, 0; i &lt; n-k+1; i++ {
		cur := s[i+k] - s[i]
		if cur &gt; t {
			pre[i+k-1] = []int{cur, i}
			t, idx = cur, i
		} else {
			pre[i+k-1] = []int{t, idx}
		}
	}

	for i, t, idx := n-k, 0, 0; i &gt;= 0; i-- {
		cur := s[i+k] - s[i]
		if cur &gt;= t {
			suf[i] = []int{cur, i}
			t, idx = cur, i
		} else {
			suf[i] = []int{t, idx}
		}
	}

	for i, t := k, 0; i &lt; n-2*k+1; i++ {
		cur := s[i+k] - s[i] + pre[i-1][0] + suf[i+k][0]
		if cur &gt; t {
			ans = []int{pre[i-1][1], i, suf[i+k][1]}
			t = cur
		}
	}

	return
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 三个无重叠子数组的最大和
// 给你一个整数数组 nums 和一个整数 k
// 找出三个长度为 k 、互不重叠、且全部数字和（3 * k 项）最大的子数组
// 并返回这三个子数组
// 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置
// 如果有多个结果，返回字典序最小的一个
// 测试链接 : https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/
public class Code04_MaximumSum3UnoverlappingSubarrays {

	public static int[] maxSumOfThreeSubarrays(int[] nums, int k) {
		int n = nums.length;
		// sums[i] : 以i开头并且长度为k的子数组的累加和
		int[] sums = new int[n];
		for (int l = 0, r = 0, sum = 0; r &lt; n; r++) {
			// l....r
			sum += nums[r];
			if (r - l + 1 == k) {
				sums[l] = sum;
				sum -= nums[l];
				l++;
			}
		}
		// prefix[i] :
		// 0~i范围上所有长度为k的子数组中，拥有最大累加和的子数组，是以什么位置开头的
		int[] prefix = new int[n];
		for (int l = 1, r = k; r &lt; n; l++, r++) {
			if (sums[l] &gt; sums[prefix[r - 1]]) {
				// 注意&gt;，为了同样最大累加和的情况下，最小的字典序
				prefix[r] = l;
			} else {
				prefix[r] = prefix[r - 1];
			}
		}
		// suffix[i] :
		// i~n-1范围上所有长度为k的子数组中，拥有最大累加和的子数组，是以什么位置开头的
		int[] suffix = new int[n];
		suffix[n - k] = n - k;
		for (int l = n - k - 1; l &gt;= 0; l--) {
			if (sums[l] &gt;= sums[suffix[l + 1]]) {
				// 注意&gt;=，为了同样最大累加和的情况下，最小的字典序
				suffix[l] = l;
			} else {
				suffix[l] = suffix[l + 1];
			}
		}
		int a = 0, b = 0, c = 0, max = 0;
		// 0...i-1    i...j    j+1...n-1
		//   左     中(长度为k)     右
		for (int p, s, i = k, j = 2 * k - 1, sum; j &lt; n - k; i++, j++) {
			// 0.....i-1   i.....j  j+1.....n-1
			// 最好开头p      i开头     最好开头s
			p = prefix[i - 1];
			s = suffix[j + 1];
			sum = sums[p] + sums[i] + sums[s];
			if (sum &gt; max) {
				// 注意&gt;，为了同样最大累加和的情况下，最小的字典序
				max = sum;
				a = p;
				b = i;
				c = s;
			}
		}
		return new int[] { a, b, c };
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="reverse-array-subarray-max-sum"><a class="header" href="#reverse-array-subarray-max-sum">Reverse Array Subarray Max Sum</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 可以翻转1次的情况下子数组最大累加和
// 给定一个数组nums，
// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整
// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]
// 返回必须随意翻转1次之后，子数组的最大累加和
// 对数器验证
public class Code05_ReverseArraySubarrayMaxSum {

	// 暴力方法
	// 为了验证
	public static int maxSumReverse1(int[] nums) {
		int ans = Integer.MIN_VALUE;
		for (int l = 0; l &lt; nums.length; l++) {
			for (int r = l; r &lt; nums.length; r++) {
				reverse(nums, l, r);
				ans = Math.max(ans, maxSum(nums));
				reverse(nums, l, r);
			}
		}
		return ans;
	}

	// nums[l...r]范围上的数字进行逆序调整
	public static void reverse(int[] nums, int l, int r) {
		while (l &lt; r) {
			int tmp = nums[l];
			nums[l++] = nums[r];
			nums[r--] = tmp;
		}
	}

	// 返回子数组最大累加和
	public static int maxSum(int[] nums) {
		int n = nums.length;
		int ans = nums[0];
		for (int i = 1, pre = nums[0]; i &lt; n; i++) {
			pre = Math.max(nums[i], pre + nums[i]);
			ans = Math.max(ans, pre);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSumReverse2(int[] nums) {
		int n = nums.length;
		// start[i] : 所有必须以i开头的子数组中，最大累加和是多少
		int[] start = new int[n];
		start[n - 1] = nums[n - 1];
		for (int i = n - 2; i &gt;= 0; i--) {
			// nums[i]
			// nums[i] + start[i+1]
			start[i] = Math.max(nums[i], nums[i] + start[i + 1]);
		}
		int ans = start[0];
		// end : 子数组必须以i-1结尾，其中的最大累加和
		int end = nums[0];
		// maxEnd :
		// 0~i-1范围上，
		// 子数组必须以0结尾，其中的最大累加和
		// 子数组必须以1结尾，其中的最大累加和
		// ...
		// 子数组必须以i-1结尾，其中的最大累加和
		// 所有情况中，最大的那个累加和就是maxEnd
		int maxEnd = nums[0];
		for (int i = 1; i &lt; n; i++) {
			// maxend   i....
			// 枚举划分点 i...
			ans = Math.max(ans, maxEnd + start[i]);
			// 子数组必须以i结尾，其中的最大累加和
			end = Math.max(nums[i], end + nums[i]);
			maxEnd = Math.max(maxEnd, end);
		}
		ans = Math.max(ans, maxEnd);
		return ans;
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 50;
		int v = 200;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] arr = randomArray(len, v);
			int ans1 = maxSumReverse1(arr);
			int ans2 = maxSumReverse2(arr);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 可以翻转1次的情况下子数组最大累加和
// 给定一个数组nums，
// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整
// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]
// 返回必须随意翻转1次之后，子数组的最大累加和
// 对数器验证
public class Code05_ReverseArraySubarrayMaxSum {

	// 暴力方法
	// 为了验证
	public static int maxSumReverse1(int[] nums) {
		int ans = Integer.MIN_VALUE;
		for (int l = 0; l &lt; nums.length; l++) {
			for (int r = l; r &lt; nums.length; r++) {
				reverse(nums, l, r);
				ans = Math.max(ans, maxSum(nums));
				reverse(nums, l, r);
			}
		}
		return ans;
	}

	// nums[l...r]范围上的数字进行逆序调整
	public static void reverse(int[] nums, int l, int r) {
		while (l &lt; r) {
			int tmp = nums[l];
			nums[l++] = nums[r];
			nums[r--] = tmp;
		}
	}

	// 返回子数组最大累加和
	public static int maxSum(int[] nums) {
		int n = nums.length;
		int ans = nums[0];
		for (int i = 1, pre = nums[0]; i &lt; n; i++) {
			pre = Math.max(nums[i], pre + nums[i]);
			ans = Math.max(ans, pre);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(n)
	public static int maxSumReverse2(int[] nums) {
		int n = nums.length;
		// start[i] : 所有必须以i开头的子数组中，最大累加和是多少
		int[] start = new int[n];
		start[n - 1] = nums[n - 1];
		for (int i = n - 2; i &gt;= 0; i--) {
			// nums[i]
			// nums[i] + start[i+1]
			start[i] = Math.max(nums[i], nums[i] + start[i + 1]);
		}
		int ans = start[0];
		// end : 子数组必须以i-1结尾，其中的最大累加和
		int end = nums[0];
		// maxEnd :
		// 0~i-1范围上，
		// 子数组必须以0结尾，其中的最大累加和
		// 子数组必须以1结尾，其中的最大累加和
		// ...
		// 子数组必须以i-1结尾，其中的最大累加和
		// 所有情况中，最大的那个累加和就是maxEnd
		int maxEnd = nums[0];
		for (int i = 1; i &lt; n; i++) {
			// maxend   i....
			// 枚举划分点 i...
			ans = Math.max(ans, maxEnd + start[i]);
			// 子数组必须以i结尾，其中的最大累加和
			end = Math.max(nums[i], end + nums[i]);
			maxEnd = Math.max(maxEnd, end);
		}
		ans = Math.max(ans, maxEnd);
		return ans;
	}

	// 为了测试
	// 生成随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (v * 2 + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 50;
		int v = 200;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTime; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] arr = randomArray(len, v);
			int ans1 = maxSumReverse1(arr);
			int ans2 = maxSumReverse2(arr);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<h2 id="delete-one-number-length-k-max-sum"><a class="header" href="#delete-one-number-length-k-max-sum">Delete One Number Length K Max Sum</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class071;

// 删掉1个数字后长度为k的子数组最大累加和
// 给定一个数组nums，求必须删除一个数字后的新数组中
// 长度为k的子数组最大累加和，删除哪个数字随意
// 对数器验证
public class Code06_DeleteOneNumberLengthKMaxSum {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			int[] rest = delete(nums, i);
			ans = Math.max(ans, lenKmaxSum(rest, k));
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 删掉index位置的元素，然后返回新数组
	public static int[] delete(int[] nums, int index) {
		int len = nums.length - 1;
		int[] ans = new int[len];
		int i = 0;
		for (int j = 0; j &lt; nums.length; j++) {
			if (j != index) {
				ans[i++] = nums[j];
			}
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 枚举每一个子数组找到最大累加和
	public static int lenKmaxSum(int[] nums, int k) {
		int n = nums.length;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt;= n - k; i++) {
			int cur = 0;
			for (int j = i, cnt = 0; cnt &lt; k; j++, cnt++) {
				cur += nums[j];
			}
			ans = Math.max(ans, cur);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(N)
	public static int maxSum2(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		// 单调队列 : 维持窗口内最小值的更新结构，讲解054的内容
		int[] window = new int[n];
		int l = 0;
		int r = 0;
		// 窗口累加和
		long sum = 0;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			// 单调队列 : i位置进入单调队列
			while (l &lt; r &amp;&amp; nums[window[r - 1]] &gt;= nums[i]) {
				r--;
			}
			window[r++] = i;
			sum += nums[i];
			if (i &gt;= k) {
				ans = Math.max(ans, (int) (sum - nums[window[l]]));
				if (window[l] == i - k) {
					// 单调队列 : 如果单调队列最左侧的位置过期了，从队列中弹出
					l++;
				}
				sum -= nums[i - k];
			}
		}
		return ans;
	}

	// 为了测试
	// 生成长度为n，值在[-v, +v]之间的随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (2 * v + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 200;
		int v = 1000;
		int testTimes = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTimes; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int k = (int) (Math.random() * n) + 1;
			int ans1 = maxSum1(nums, k);
			int ans2 = maxSum2(nums, k);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class071;

// 删掉1个数字后长度为k的子数组最大累加和
// 给定一个数组nums，求必须删除一个数字后的新数组中
// 长度为k的子数组最大累加和，删除哪个数字随意
// 对数器验证
public class Code06_DeleteOneNumberLengthKMaxSum {

	// 暴力方法
	// 为了测试
	public static int maxSum1(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			int[] rest = delete(nums, i);
			ans = Math.max(ans, lenKmaxSum(rest, k));
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 删掉index位置的元素，然后返回新数组
	public static int[] delete(int[] nums, int index) {
		int len = nums.length - 1;
		int[] ans = new int[len];
		int i = 0;
		for (int j = 0; j &lt; nums.length; j++) {
			if (j != index) {
				ans[i++] = nums[j];
			}
		}
		return ans;
	}

	// 暴力方法
	// 为了测试
	// 枚举每一个子数组找到最大累加和
	public static int lenKmaxSum(int[] nums, int k) {
		int n = nums.length;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt;= n - k; i++) {
			int cur = 0;
			for (int j = i, cnt = 0; cnt &lt; k; j++, cnt++) {
				cur += nums[j];
			}
			ans = Math.max(ans, cur);
		}
		return ans;
	}

	// 正式方法
	// 时间复杂度O(N)
	public static int maxSum2(int[] nums, int k) {
		int n = nums.length;
		if (n &lt;= k) {
			return 0;
		}
		// 单调队列 : 维持窗口内最小值的更新结构，讲解054的内容
		int[] window = new int[n];
		int l = 0;
		int r = 0;
		// 窗口累加和
		long sum = 0;
		int ans = Integer.MIN_VALUE;
		for (int i = 0; i &lt; n; i++) {
			// 单调队列 : i位置进入单调队列
			while (l &lt; r &amp;&amp; nums[window[r - 1]] &gt;= nums[i]) {
				r--;
			}
			window[r++] = i;
			sum += nums[i];
			if (i &gt;= k) {
				ans = Math.max(ans, (int) (sum - nums[window[l]]));
				if (window[l] == i - k) {
					// 单调队列 : 如果单调队列最左侧的位置过期了，从队列中弹出
					l++;
				}
				sum -= nums[i - k];
			}
		}
		return ans;
	}

	// 为了测试
	// 生成长度为n，值在[-v, +v]之间的随机数组
	public static int[] randomArray(int n, int v) {
		int[] ans = new int[n];
		for (int i = 0; i &lt; n; i++) {
			ans[i] = (int) (Math.random() * (2 * v + 1)) - v;
		}
		return ans;
	}

	// 为了测试
	// 对数器
	public static void main(String[] args) {
		int n = 200;
		int v = 1000;
		int testTimes = 10000;
		System.out.println("测试开始");
		for (int i = 0; i &lt; testTimes; i++) {
			int len = (int) (Math.random() * n) + 1;
			int[] nums = randomArray(len, v);
			int k = (int) (Math.random() * n) + 1;
			int ans1 = maxSum1(nums, k);
			int ans2 = maxSum2(nums, k);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/qwsNGHkI64A?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dp-on-intervals-part-1"><a class="header" href="#dp-on-intervals-part-1">DP on Intervals (part 1)</a></h1>
<h2 id="minimum-insertions-to-make-a-string-palindrome"><a class="header" href="#minimum-insertions-to-make-a-string-palindrome">Minimum Insertions to Make a String Palindrome</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome">LeetCode 1312. Minimum Insertion Steps to Make a String Palindrome</a></p>
<p>Given a string s. In one step you can insert any character at any index of the string.</p>
<p>Return the minimum number of steps to make spalindrome.</p>
<p>APalindrome Stringis one that reads the same backward as well as forward.</p>
<pre><code>Example 1:

Input: s = zzazz
Output: 0
Explanation: The string zzazz is already palindrome we do not need any insertions.

Example 2:

Input: s = mbadm
Output: 2
Explanation: String can be mbdadbm or mdbabdm.

Example 3:

Input: s = leetcode
Output: 5
Explanation: Inserting 5 characters the string becomes leetcodocteel.
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 500</li>
<li>s consists of lowercase English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/
public class MinimumInsertionToPalindrome {

	// 暴力尝试
	public static int minInsertions1(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		return f1(s, 0, n - 1);
	}

	// s[l....r]这个范围上的字符串，整体都变成回文串
	// 返回至少插入几个字符
	public static int f1(char[] s, int l, int r) {
		// l &lt;= r
		if (l == r) {
			return 0;
		}
		if (l + 1 == r) {
			return s[l] == s[r] ? 0 : 1;
		}
		// l...r不只两个字符
		if (s[l] == s[r]) {
			return f1(s, l + 1, r - 1);
		} else {
			return Math.min(f1(s, l, r - 1), f1(s, l + 1, r)) + 1;
		}
	}

	// 记忆化搜索
	public static int minInsertions2(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = i; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		return f2(s, 0, n - 1, dp);
	}

	public static int f2(char[] s, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans;
		if (l == r) {
			ans = 0;
		} else if (l + 1 == r) {
			ans = s[l] == s[l + 1] ? 0 : 1;
		} else {
			if (s[l] == s[r]) {
				ans = f2(s, l + 1, r - 1, dp);
			} else {
				ans = Math.min(f2(s, l, r - 1, dp), f2(s, l + 1, r, dp)) + 1;
			}
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int minInsertions3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int l = 0; l &lt; n - 1; l++) {
			dp[l][l + 1] = s[l] == s[l + 1] ? 0 : 1;
		}
		for (int l = n - 3; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				if (s[l] == s[r]) {
					dp[l][r] = dp[l + 1][r - 1];
				} else {
					dp[l][r] = Math.min(dp[l][r - 1], dp[l + 1][r]) + 1;
				}
			}
		}
		return dp[0][n - 1];
	}

	// 空间压缩
	// 本题有关空间压缩的实现，可以参考讲解067，题目4，最长回文子序列问题的讲解
	// 这两个题空间压缩写法高度相似
	// 因为之前的课多次讲过空间压缩的内容，所以这里不再赘述
	public static int minInsertions4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		if (n &lt; 2) {
			return 0;
		}
		int[] dp = new int[n];
		dp[n - 1] = s[n - 2] == s[n - 1] ? 0 : 1;
		for (int l = n - 3, leftDown, backUp; l &gt;= 0; l--) {
			leftDown = dp[l + 1];
			dp[l + 1] = s[l] == s[l + 1] ? 0 : 1;
			for (int r = l + 2; r &lt; n; r++) {
				backUp = dp[r];
				if (s[l] == s[r]) {
					dp[r] = leftDown;
				} else {
					dp[r] = Math.min(dp[r - 1], dp[r]) + 1;
				}
				leftDown = backUp;
			}
		}
		return dp[n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=151">
    </iframe>
</details>
<h2 id="predict-the-winner"><a class="header" href="#predict-the-winner">Predict the Winner</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/predict-the-winner">LeetCode 486. Predict the Winner</a></p>
<p>You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.</p>
<p>Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.</p>
<p>Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.</p>
<pre><code>Example 1:

Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.

Example 2:

Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= nums.length &lt;= 20</li>
<li>0 &lt;= nums[i] &lt;= 10^7</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/predict-the-winner/
public class PredictTheWinner {

	// 暴力尝试
	public static boolean predictTheWinner1(int[] nums) {
		int sum = 0;
		for (int num : nums) {
			sum += num;
		}
		int n = nums.length;
		int first = f1(nums, 0, n - 1);
		int second = sum - first;
		return first &gt;= second;
	}

	// nums[l...r]范围上的数字进行游戏，轮到玩家1
	// 返回玩家1最终能获得多少分数，玩家1和玩家2都绝顶聪明
	public static int f1(int[] nums, int l, int r) {
		if (l == r) {
			return nums[l];
		}
		if (l == r - 1) {
			return Math.max(nums[l], nums[r]);
		}
		// l....r 不只两个数
		// 可能性1 ：玩家1拿走nums[l] l+1...r
		int p1 = nums[l] + Math.min(f1(nums, l + 2, r), f1(nums, l + 1, r - 1));
		// 可能性2 ：玩家1拿走nums[r] l...r-1
		int p2 = nums[r] + Math.min(f1(nums, l + 1, r - 1), f1(nums, l, r - 2));
		return Math.max(p1, p2);
	}

	// 记忆化搜索
	public static boolean predictTheWinner2(int[] nums) {
		int sum = 0;
		for (int num : nums) {
			sum += num;
		}
		int n = nums.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = i; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		int first = f2(nums, 0, n - 1, dp);
		int second = sum - first;
		return first &gt;= second;
	}

	public static int f2(int[] nums, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans;
		if (l == r) {
			ans = nums[l];
		} else if (l == r - 1) {
			ans = Math.max(nums[l], nums[r]);
		} else {
			int p1 = nums[l] + Math.min(f2(nums, l + 2, r, dp), f2(nums, l + 1, r - 1, dp));
			int p2 = nums[r] + Math.min(f2(nums, l + 1, r - 1, dp), f2(nums, l, r - 2, dp));
			ans = Math.max(p1, p2);
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static boolean predictTheWinner3(int[] nums) {
		int sum = 0;
		for (int num : nums) {
			sum += num;
		}
		int n = nums.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n - 1; i++) {
			dp[i][i] = nums[i];
			dp[i][i + 1] = Math.max(nums[i], nums[i + 1]);
		}
		dp[n - 1][n - 1] = nums[n - 1];
		for (int l = n - 3; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				dp[l][r] = Math.max(
						nums[l] + Math.min(dp[l + 2][r], dp[l + 1][r - 1]),
						nums[r] + Math.min(dp[l + 1][r - 1], dp[l][r - 2]));
			}
		}
		int first = dp[0][n - 1];
		int second = sum - first;
		return first &gt;= second;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=1394">
    </iframe>
</details>
<h2 id="minimum-score-triangulation-of-polygon"><a class="header" href="#minimum-score-triangulation-of-polygon">Minimum Score Triangulation of Polygon</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon">LeetCode 1039. Minimum Score Triangulation of Polygon</a></p>
<p>You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex in clockwise order.</p>
<p>Polygon triangulation is a process where you divide a polygon into a set of triangles and the vertices of each triangle must also be vertices of the original polygon. Note that no other shapes other than triangles are allowed in the division. This process will result in n - 2 triangles.</p>
<p>You will triangulate the polygon. For each triangle, the weight of that triangle is the product of the values at its vertices. The total score of the triangulation is the sum of these weights over all n - 2 triangles.</p>
<p>Return the minimum possible score that you can achieve with some triangulation of the polygon.</p>
<pre><code>Example 1:

Input: values = [1,2,3]

Output: 6

Explanation: The polygon is already triangulated, and the score of the only triangle is 6.

Example 2:

Input: values = [3,7,4,5]

Output: 144

Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.
The minimum score is 144.

Example 3:

Input: values = [1,3,1,4,1,5]

Output: 13

Explanation: The minimum score triangulation is 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.
</code></pre>
<p>Constraints:</p>
<ul>
<li>n = values.length</li>
<li>3 &lt;= n &lt;= 50</li>
<li>1 &lt;= values[i] &lt;= 100</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/minimum-score-triangulation-of-polygon/
public class MinimumScoreTriangulationOfPolygon {

	// 记忆化搜索
	public static int minScoreTriangulation1(int[] arr) {
		int n = arr.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		return f(arr, 0, n - 1, dp);
	}

	public static int f(int[] arr, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans = Integer.MAX_VALUE;
		if (l == r || l == r - 1) {
			ans = 0;
		} else {
			// l....r &gt;=3
			// 0..1..2..3..4...5
			for (int m = l + 1; m &lt; r; m++) {
				// l m r
				ans = Math.min(ans, f(arr, l, m, dp) + f(arr, m, r, dp) + arr[l] * arr[m] * arr[r]);
			}
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int minScoreTriangulation2(int[] arr) {
		int n = arr.length;
		int[][] dp = new int[n][n];
		for (int l = n - 3; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				dp[l][r] = Integer.MAX_VALUE;
				for (int m = l + 1; m &lt; r; m++) {
					dp[l][r] = Math.min(dp[l][r], dp[l][m] + dp[m][r] + arr[l] * arr[m] * arr[r]);
				}
			}
		}
		return dp[0][n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=2526">
    </iframe>
</details>
<h2 id="minimum-cost-to-cut-a-stick"><a class="header" href="#minimum-cost-to-cut-a-stick">Minimum Cost to Cut a Stick</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-cost-to-cut-a-stick">LeetCode 1547. Minimum Cost to Cut a Stick</a></p>
<p>Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:</p>
<p>Given an integer array cuts where cuts[i] denotes a position you should perform a cut at.</p>
<p>You should perform the cuts in order, you can change the order of the cuts as you wish.</p>
<p>The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.</p>
<p>Return the minimum total cost of the cuts.</p>
<pre><code>Example 1:

Input: n = 7, cuts = [1,3,4,5]
Output: 16
Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:

The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).

Example 2:

Input: n = 9, cuts = [5,6,1,4,2]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost = 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.
</code></pre>
<p>Constraints:</p>
<ul>
<li>2 &lt;= n &lt;= 10^6</li>
<li>1 &lt;= cuts.length &lt;= min(n - 1, 100)</li>
<li>1 &lt;= cuts[i] &lt;= n - 1</li>
<li>All the integers in cuts array are distinct.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

// https://leetcode.com/problems/minimum-cost-to-cut-a-stick/
public class MinimumCostToCutAStick {

	// 记忆化搜索
	public static int minCost1(int n, int[] cuts) {
		int m = cuts.length;
		Arrays.sort(cuts);
		int[] arr = new int[m + 2];
		arr[0] = 0;
		for (int i = 1; i &lt;= m; ++i) {
			arr[i] = cuts[i - 1];
		}
		arr[m + 1] = n;
		int[][] dp = new int[m + 2][m + 2];
		for (int i = 1; i &lt;= m; i++) {
			for (int j = 1; j &lt;= m; j++) {
				dp[i][j] = -1;
			}
		}
		return f(arr, 1, m, dp);
	}
	
	// 切点[l....r]，决定一个顺序
	// 让切点都切完，总代价最小
	public static int f(int[] arr, int l, int r, int[][] dp) {
		if (l &gt; r) {
			return 0;
		}
		if (l == r) {
			return arr[r + 1] - arr[l - 1];
		}
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = l; k &lt;= r; k++) {
			ans = Math.min(ans, f(arr, l, k - 1, dp) + f(arr, k + 1, r, dp));
		}
		ans += arr[r + 1] - arr[l - 1];
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int minCost2(int n, int[] cuts) {
		int m = cuts.length;
		Arrays.sort(cuts);
		int[] arr = new int[m + 2];
		arr[0] = 0;
		for (int i = 1; i &lt;= m; ++i) {
			arr[i] = cuts[i - 1];
		}
		arr[m + 1] = n;
		int[][] dp = new int[m + 2][m + 2];
		for (int i = 1; i &lt;= m; i++) {
			dp[i][i] = arr[i + 1] - arr[i - 1];
		}
		for (int l = m - 1, next; l &gt;= 1; l--) {
			for (int r = l + 1; r &lt;= m; r++) {
				next = Integer.MAX_VALUE;
				for (int k = l; k &lt;= r; k++) {
					next = Math.min(next, dp[l][k - 1] + dp[k + 1][r]);
				}
				dp[l][r] = arr[r + 1] - arr[l - 1] + next;
			}
		}
		return dp[1][m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=3405">
    </iframe>
</details>
<h2 id="burst-balloons"><a class="header" href="#burst-balloons">Burst Balloons</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/burst-balloons">LeetCode 312. Burst Balloons</a></p>
<p>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.</p>
<p>If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.</p>
<p>Return the maximum coins you can collect by bursting the balloons wisely.</p>
<pre><code>Example 1:

Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] -- [3,5,8] -- [3,8] -- [8] -- []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

Example 2:

Input: nums = [1,5]
Output: 10
</code></pre>
<p>Constraints:</p>
<ul>
<li>n = nums.length</li>
<li>1 &lt;= n &lt;= 300</li>
<li>0 &lt;= nums[i] &lt;= 100</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/burst-balloons/
public class BurstBalloons {

	// 记忆化搜索
	public static int maxCoins1(int[] nums) {
		int n = nums.length;
		// a b c d e
		// 1 a b c d e 1
		int[] arr = new int[n + 2];
		arr[0] = 1;
		arr[n + 1] = 1;
		for (int i = 0; i &lt; n; i++) {
			arr[i + 1] = nums[i];
		}
		int[][] dp = new int[n + 2][n + 2];
		for (int i = 1; i &lt;= n; i++) {
			for (int j = i; j &lt;= n; j++) {
				dp[i][j] = -1;
			}
		}
		return f(arr, 1, n, dp);
	}

	// arr[l...r]这些气球决定一个顺序，获得最大得分返回！
	// 一定有 : arr[l-1]一定没爆！
	// 一定有 : arr[r+1]一定没爆！
	// 尝试每个气球最后打爆
	public static int f(int[] arr, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans;
		if (l == r) {
			ans = arr[l - 1] * arr[l] * arr[r + 1];
		} else {
			// l   ....r
			// l +1 +2 .. r
			ans = Math.max(
					arr[l - 1] * arr[l] * arr[r + 1] + f(arr, l + 1, r, dp), // l位置的气球最后打爆
					arr[l - 1] * arr[r] * arr[r + 1] + f(arr, l, r - 1, dp));// r位置的气球最后打爆
			for (int k = l + 1; k &lt; r; k++) {
				// k位置的气球最后打爆
				// l...k-1  k  k+1...r
				ans = Math.max(ans, arr[l - 1] * arr[k] * arr[r + 1] + f(arr, l, k - 1, dp) + f(arr, k + 1, r, dp));
			}
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int maxCoins2(int[] nums) {
		int n = nums.length;
		int[] arr = new int[n + 2];
		arr[0] = 1;
		arr[n + 1] = 1;
		for (int i = 0; i &lt; n; i++) {
			arr[i + 1] = nums[i];
		}
		int[][] dp = new int[n + 2][n + 2];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][i] = arr[i - 1] * arr[i] * arr[i + 1];
		}
		for (int l = n, ans; l &gt;= 1; l--) {
			for (int r = l + 1; r &lt;= n; r++) {
				ans = Math.max(arr[l - 1] * arr[l] * arr[r + 1] + dp[l + 1][r],
						arr[l - 1] * arr[r] * arr[r + 1] + dp[l][r - 1]);
				for (int k = l + 1; k &lt; r; k++) {
					ans = Math.max(ans, arr[l - 1] * arr[k] * arr[r + 1] + dp[l][k - 1] + dp[k + 1][r]);
				}
				dp[l][r] = ans;
			}
		}
		return dp[1][n];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=4709">
    </iframe>
</details>
<h2 id="boolean-evaluation"><a class="header" href="#boolean-evaluation">Boolean Evaluation</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class076;

// 布尔运算
// 给定一个布尔表达式和一个期望的布尔结果 result
// 布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成
// 布尔表达式一定是正确的，不需要检查有效性
// 但是其中没有任何括号来表示优先级
// 你可以随意添加括号来改变逻辑优先级
// 目的是让表达式能够最终得出result的结果
// 返回最终得出result有多少种不同的逻辑计算顺序
// 测试链接 : https://leetcode.com/problems/boolean-evaluation-lcci/
public class Code06_BooleanEvaluation {

	// 记忆化搜索
	public static int countEval(String str, int result) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][][] dp = new int[n][n][];
		int[] ft = f(s, 0, n - 1, dp);
		return ft[result];
	}

	// s[l...r]是表达式的一部分，且一定符合范式
	// 0/1  逻  0/1   逻       0/1
	//  l  l+1  l+2  l+3........r
	// s[l...r]  0 : ?
	//           1 : ?
	// ans : int[2] ans[0] = false方法数 ans[0] = true方法数
	public static int[] f(char[] s, int l, int r, int[][][] dp) {
		if (dp[l][r] != null) {
			return dp[l][r];
		}
		int f = 0;
		int t = 0;
		if (l == r) {
			// 只剩一个字符，0/1
			f = s[l] == '0' ? 1 : 0;
			t = s[l] == '1' ? 1 : 0;
		} else {
			int[] tmp;
			for (int k = l + 1, a, b, c, d; k &lt; r; k += 2) {
				// l ... r
				// 枚举每一个逻辑符号最后执行 k = l+1 ... r-1  k+=2
				tmp = f(s, l, k - 1, dp);
				a = tmp[0];
				b = tmp[1];
				tmp = f(s, k + 1, r, dp);
				c = tmp[0];
				d = tmp[1];
				if (s[k] == '&amp;') {
					f += a * c + a * d + b * c;
					t += b * d;
				} else if (s[k] == '|') {
					f += a * c;
					t += a * d + b * c + b * d;
				} else {
					f += a * c + b * d;
					t += a * d + b * c;
				}
			}
		}
		int[] ft = new int[] { f, t };
		dp[l][r] = ft;
		return ft;
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class076;

// 布尔运算
// 给定一个布尔表达式和一个期望的布尔结果 result
// 布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成
// 布尔表达式一定是正确的，不需要检查有效性
// 但是其中没有任何括号来表示优先级
// 你可以随意添加括号来改变逻辑优先级
// 目的是让表达式能够最终得出result的结果
// 返回最终得出result有多少种不同的逻辑计算顺序
// 测试链接 : https://leetcode.com/problems/boolean-evaluation-lcci/
public class Code06_BooleanEvaluation {

	// 记忆化搜索
	public static int countEval(String str, int result) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][][] dp = new int[n][n][];
		int[] ft = f(s, 0, n - 1, dp);
		return ft[result];
	}

	// s[l...r]是表达式的一部分，且一定符合范式
	// 0/1  逻  0/1   逻       0/1
	//  l  l+1  l+2  l+3........r
	// s[l...r]  0 : ?
	//           1 : ?
	// ans : int[2] ans[0] = false方法数 ans[0] = true方法数
	public static int[] f(char[] s, int l, int r, int[][][] dp) {
		if (dp[l][r] != null) {
			return dp[l][r];
		}
		int f = 0;
		int t = 0;
		if (l == r) {
			// 只剩一个字符，0/1
			f = s[l] == '0' ? 1 : 0;
			t = s[l] == '1' ? 1 : 0;
		} else {
			int[] tmp;
			for (int k = l + 1, a, b, c, d; k &lt; r; k += 2) {
				// l ... r
				// 枚举每一个逻辑符号最后执行 k = l+1 ... r-1  k+=2
				tmp = f(s, l, k - 1, dp);
				a = tmp[0];
				b = tmp[1];
				tmp = f(s, k + 1, r, dp);
				c = tmp[0];
				d = tmp[1];
				if (s[k] == '&amp;') {
					f += a * c + a * d + b * c;
					t += b * d;
				} else if (s[k] == '|') {
					f += a * c;
					t += a * d + b * c + b * d;
				} else {
					f += a * c + b * d;
					t += a * d + b * c;
				}
			}
		}
		int[] ft = new int[] { f, t };
		dp[l][r] = ft;
		return ft;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=0">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dp-on-intervals-part-2"><a class="header" href="#dp-on-intervals-part-2">DP on Intervals (part 2)</a></h1>
<h2 id="minimum-insertions-to-match"><a class="header" href="#minimum-insertions-to-match">Minimum Insertions To Match</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class077;

// 完成配对需要的最少字符数量
// 给定一个由'['、']'、'('，')'组成的字符串
// 请问最少插入多少个括号就能使这个字符串的所有括号正确配对
// 例如当前串是 "([[])"，那么插入一个']'即可满足
// 输出最少需要插入多少个字符
// 测试链接 : https://www.nowcoder.com/practice/e391767d80d942d29e6095a935a5b96b
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code01_MinimumInsertionsToMatch {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		String str = br.readLine();
		out.println(compute(str));
		out.flush();
		out.close();
		br.close();
	}

	// 时间复杂度O(n^3)
	public static int compute(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		return f(s, 0, s.length - 1, dp);
	}

	// 让s[l...r]配对至少需要几个字符
	public static int f(char[] s, int l, int r, int[][] dp) {
		if (l == r) {
			return 1;
		}
		if (l == r - 1) {
			if ((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']')) {
				return 0;
			}
			return 2;
		}
		// l...r字符数量 &gt;= 3
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		// 可能性1 : [l]、[r]本来就是配对的
		int p1 = Integer.MAX_VALUE;
		if ((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']')) {
			p1 = f(s, l + 1, r - 1, dp);
		}
		// 可能性2 : 基于每个可能的划分点，做左右划分
		int p2 = Integer.MAX_VALUE;
		for (int m = l; m &lt; r; m++) {
			p2 = Math.min(p2, f(s, l, m, dp) + f(s, m + 1, r, dp));
		}
		int ans = Math.min(p1, p2);
		dp[l][r] = ans;
		return ans;
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class077;

// 完成配对需要的最少字符数量
// 给定一个由'['、']'、'('，')'组成的字符串
// 请问最少插入多少个括号就能使这个字符串的所有括号正确配对
// 例如当前串是 "([[])"，那么插入一个']'即可满足
// 输出最少需要插入多少个字符
// 测试链接 : https://www.nowcoder.com/practice/e391767d80d942d29e6095a935a5b96b
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code01_MinimumInsertionsToMatch {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		String str = br.readLine();
		out.println(compute(str));
		out.flush();
		out.close();
		br.close();
	}

	// 时间复杂度O(n^3)
	public static int compute(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		return f(s, 0, s.length - 1, dp);
	}

	// 让s[l...r]配对至少需要几个字符
	public static int f(char[] s, int l, int r, int[][] dp) {
		if (l == r) {
			return 1;
		}
		if (l == r - 1) {
			if ((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']')) {
				return 0;
			}
			return 2;
		}
		// l...r字符数量 &gt;= 3
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		// 可能性1 : [l]、[r]本来就是配对的
		int p1 = Integer.MAX_VALUE;
		if ((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']')) {
			p1 = f(s, l + 1, r - 1, dp);
		}
		// 可能性2 : 基于每个可能的划分点，做左右划分
		int p2 = Integer.MAX_VALUE;
		for (int m = l; m &lt; r; m++) {
			p2 = Math.min(p2, f(s, l, m, dp) + f(s, m + 1, r, dp));
		}
		int ans = Math.min(p1, p2);
		dp[l][r] = ans;
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/Xr1e0RzRUI4?start=0">
    </iframe>
</details>
<h2 id="strange-printer"><a class="header" href="#strange-printer">Strange Printer</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0664.Strange%20Printer/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="664-strange-printer"><a class="header" href="#664-strange-printer"><a href="https://leetcode.com/problems/strange-printer">664. Strange Printer</a></a></h1>
<p><a href="dynamic-programming//solution/0600-0699/0664.Strange%20Printer/README.html">中文文档</a></p>
<h2 id="description-31"><a class="header" href="#description-31">Description</a></h2>
<!-- description:start -->
<p>There is a strange printer with the following two special properties:</p>
<ul>
	<li>The printer can only print a sequence of <strong>the same character</strong> each time.</li>
	<li>At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.</li>
</ul>
<p>Given a string <code>s</code>, return <em>the minimum number of turns the printer needed to print it</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;aaabbb&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Print &quot;aaa&quot; first and then print &quot;bbb&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;aba&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Print &quot;aaa&quot; first and then print &quot;b&quot; from the second place of the string, which will cover the existing character &#39;a&#39;.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-31"><a class="header" href="#solutions-31">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-6"><a class="header" href="#solution-1-dynamic-programming-6">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i][j]$ as the minimum operations to print $s[i..j]$, with the initial value $f[i][j]=\infty$, and the answer is $f[0][n-1]$, where $n$ is the length of string $s$.</p>
<p>Consider $f[i][j]$, if $s[i] = s[j]$, we can print $s[j]$ when print $s[i]$, so we can ignore $s[j]$ and continue to print $s[i+1..j-1]$. If $s[i] \neq s[j]$, we need to print the substring separately, i.e. $s[i..k]$ and $s[k+1..j]$, where $k \in [i,j)$. So we can have the following transition equation:</p>
<p>$$
f[i][j]=
\begin{cases}
1, &amp; \textit{if } i=j \
f[i][j-1], &amp; \textit{if } s[i]=s[j] \
\min_{i \leq k &lt; j} {f[i][k]+f[k+1][j]}, &amp; \textit{otherwise}
\end{cases}
$$</p>
<p>We can enumerate $i$ from large to small and $j$ from small to large, so that we can ensure that $f[i][j-1]$, $f[i][k]$ and $f[k+1][j]$ have been calculated when we calculate $f[i][j]$.</p>
<p>The time complexity is $O(n^3)$ and the space complexity is $O(n^2)$. Where $n$ is the length of string $s$.</p>
<!-- tabs:start -->
<h4 id="python3-47"><a class="header" href="#python3-47">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def strangePrinter(self, s: str) -&gt; int:
        n = len(s)
        f = [[inf] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            f[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i][j - 1]
                else:
                    for k in range(i, j):
                        f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j])
        return f[0][-1]
</code></pre>
<h4 id="java-45"><a class="header" href="#java-45">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int strangePrinter(String s) {
        final int inf = 1 &lt;&lt; 30;
        int n = s.length();
        int[][] f = new int[n][n];
        for (var g : f) {
            Arrays.fill(g, inf);
        }
        for (int i = n - 1; i &gt;= 0; --i) {
            f[i][i] = 1;
            for (int j = i + 1; j &lt; n; ++j) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i][j - 1];
                } else {
                    for (int k = i; k &lt; j; ++k) {
                        f[i][j] = Math.min(f[i][j], f[i][k] + f[k + 1][j]);
                    }
                }
            }
        }
        return f[0][n - 1];
    }
}
</code></pre>
<h4 id="c-56"><a class="header" href="#c-56">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        int f[n][n];
        memset(f, 0x3f, sizeof(f));
        for (int i = n - 1; ~i; --i) {
            f[i][i] = 1;
            for (int j = i + 1; j &lt; n; ++j) {
                if (s[i] == s[j]) {
                    f[i][j] = f[i][j - 1];
                } else {
                    for (int k = i; k &lt; j; ++k) {
                        f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
                    }
                }
            }
        }
        return f[0][n - 1];
    }
};
</code></pre>
<h4 id="go-45"><a class="header" href="#go-45">Go</a></h4>
<pre><code class="language-go">func strangePrinter(s string) int {
	n := len(s)
	f := make([][]int, n)
	for i := range f {
		f[i] = make([]int, n)
		for j := range f[i] {
			f[i][j] = 1 &lt;&lt; 30
		}
	}
	for i := n - 1; i &gt;= 0; i-- {
		f[i][i] = 1
		for j := i + 1; j &lt; n; j++ {
			if s[i] == s[j] {
				f[i][j] = f[i][j-1]
			} else {
				for k := i; k &lt; j; k++ {
					f[i][j] = min(f[i][j], f[i][k]+f[k+1][j])
				}
			}
		}
	}
	return f[0][n-1]
}
</code></pre>
<h4 id="typescript-46"><a class="header" href="#typescript-46">TypeScript</a></h4>
<pre><code class="language-ts">function strangePrinter(s: string): number {
    const n = s.length;
    const f: number[][] = new Array(n).fill(0).map(() =&gt; new Array(n).fill(1 &lt;&lt; 30));
    for (let i = n - 1; i &gt;= 0; --i) {
        f[i][i] = 1;
        for (let j = i + 1; j &lt; n; ++j) {
            if (s[i] === s[j]) {
                f[i][j] = f[i][j - 1];
            } else {
                for (let k = i; k &lt; j; ++k) {
                    f[i][j] = Math.min(f[i][j], f[i][k] + f[k + 1][j]);
                }
            }
        }
    }
    return f[0][n - 1];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class077;

// 涂色 &amp; 奇怪打印机
// 假设你有一条长度为5的木板，初始时没有涂过任何颜色
// 你希望把它的5个单位长度分别涂上红、绿、蓝、绿、红
// 用一个长度为5的字符串表示这个目标：RGBGR
// 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色
// 例如第一次把木板涂成RRRRR
// 第二次涂成RGGGR
// 第三次涂成RGBGR，达到目标
// 返回尽量少的涂色次数
// 测试链接 : https://www.luogu.com.cn/problem/P4170
// 测试链接 : https://leetcode.com/problems/strange-printer/
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code02_Coloring {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		String str = br.readLine();
		out.println(strangePrinter(str));
		out.flush();
		out.close();
		br.close();
	}

	// 时间复杂度O(n^3)
	// 测试链接 : https://leetcode.com/problems/strange-printer/
	public static int strangePrinter(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		dp[n - 1][n - 1] = 1;
		for (int i = 0; i &lt; n - 1; i++) {
			dp[i][i] = 1;
			dp[i][i + 1] = s[i] == s[i + 1] ? 1 : 2;
		}
		for (int l = n - 3, ans; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				// dp[l][r]
				if (s[l] == s[r]) {
					dp[l][r] = dp[l][r - 1];
					// dp[l][r] = dp[l + 1][r];
				} else {
					ans = Integer.MAX_VALUE;
					for (int m = l; m &lt; r; m++) {
						ans = Math.min(ans, dp[l][m] + dp[m + 1][r]);
					}
					dp[l][r] = ans;
				}
			}
		}
		return dp[0][n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/Xr1e0RzRUI4?start=958">
    </iframe>
</details>
<h2 id="height-and-choir"><a class="header" href="#height-and-choir">Height And Choir</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">package class077;

// 合唱队
// 具体描述情打开链接查看
// 测试链接 : https://www.luogu.com.cn/problem/P3205
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code03_HeightAndChoir {

	public static int MAXN = 1001;

	public static int[] nums = new int[MAXN];

	public static int[][] dp = new int[MAXN][2];

	public static int n;

	public static int MOD = 19650827;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			for (int i = 1; i &lt;= n; i++) {
				in.nextToken();
				nums[i] = (int) in.nval;
			}
			if (n == 1) {
				out.println(1);
			} else {
				out.println(compute2());
			}
		}
		out.flush();
		out.close();
		br.close();
	}

	// 时间复杂度O(n^2)
	// 严格位置依赖的动态规划
	public static int compute1() {
		// 人的编号范围 : 1...n
		// dp[l][r][0] : 形成l...r的状况的方法数，同时要求l位置的数字是最后出现的
		// dp[l][r][1] : 形成l...r的状况的方法数，同时要求r位置的数字是最后出现的
		int[][][] dp = new int[n + 1][n + 1][2];
		for (int i = 1; i &lt; n; i++) {
			if (nums[i] &lt; nums[i + 1]) {
				dp[i][i + 1][0] = 1;
				dp[i][i + 1][1] = 1;
			}
		}
		for (int l = n - 2; l &gt;= 1; l--) {
			for (int r = l + 2; r &lt;= n; r++) {
				if (nums[l] &lt; nums[l + 1]) {
					dp[l][r][0] = (dp[l][r][0] + dp[l + 1][r][0]) % MOD;
				}
				if (nums[l] &lt; nums[r]) {
					dp[l][r][0] = (dp[l][r][0] + dp[l + 1][r][1]) % MOD;
				}
				if (nums[r] &gt; nums[l]) {
					dp[l][r][1] = (dp[l][r][1] + dp[l][r - 1][0]) % MOD;
				}
				if (nums[r] &gt; nums[r - 1]) {
					dp[l][r][1] = (dp[l][r][1] + dp[l][r - 1][1]) % MOD;
				}
			}
		}
		return (dp[1][n][0] + dp[1][n][1]) % MOD;
	}

	// 时间复杂度O(n^2)
	// 空间压缩
	public static int compute2() {
		if (nums[n - 1] &lt; nums[n]) {
			dp[n][0] = 1;
			dp[n][1] = 1;
		}
		for (int l = n - 2; l &gt;= 1; l--) {
			if (nums[l] &lt; nums[l + 1]) {
				dp[l + 1][0] = 1;
				dp[l + 1][1] = 1;
			} else {
				dp[l + 1][0] = 0;
				dp[l + 1][1] = 0;
			}
			for (int r = l + 2; r &lt;= n; r++) {
				int a = 0;
				int b = 0;
				if (nums[l] &lt; nums[l + 1]) {
					a = (a + dp[r][0]) % MOD;
				}
				if (nums[l] &lt; nums[r]) {
					a = (a + dp[r][1]) % MOD;
				}
				if (nums[r] &gt; nums[l]) {
					b = (b + dp[r - 1][0]) % MOD;
				}
				if (nums[r] &gt; nums[r - 1]) {
					b = (b + dp[r - 1][1]) % MOD;
				}
				dp[r][0] = a;
				dp[r][1] = b;
			}
		}
		return (dp[n][0] + dp[n][1]) % MOD;
	}

}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class077;

// 合唱队
// 具体描述情打开链接查看
// 测试链接 : https://www.luogu.com.cn/problem/P3205
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code03_HeightAndChoir {

	public static int MAXN = 1001;

	public static int[] nums = new int[MAXN];

	public static int[][] dp = new int[MAXN][2];

	public static int n;

	public static int MOD = 19650827;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			for (int i = 1; i &lt;= n; i++) {
				in.nextToken();
				nums[i] = (int) in.nval;
			}
			if (n == 1) {
				out.println(1);
			} else {
				out.println(compute2());
			}
		}
		out.flush();
		out.close();
		br.close();
	}

	// 时间复杂度O(n^2)
	// 严格位置依赖的动态规划
	public static int compute1() {
		// 人的编号范围 : 1...n
		// dp[l][r][0] : 形成l...r的状况的方法数，同时要求l位置的数字是最后出现的
		// dp[l][r][1] : 形成l...r的状况的方法数，同时要求r位置的数字是最后出现的
		int[][][] dp = new int[n + 1][n + 1][2];
		for (int i = 1; i &lt; n; i++) {
			if (nums[i] &lt; nums[i + 1]) {
				dp[i][i + 1][0] = 1;
				dp[i][i + 1][1] = 1;
			}
		}
		for (int l = n - 2; l &gt;= 1; l--) {
			for (int r = l + 2; r &lt;= n; r++) {
				if (nums[l] &lt; nums[l + 1]) {
					dp[l][r][0] = (dp[l][r][0] + dp[l + 1][r][0]) % MOD;
				}
				if (nums[l] &lt; nums[r]) {
					dp[l][r][0] = (dp[l][r][0] + dp[l + 1][r][1]) % MOD;
				}
				if (nums[r] &gt; nums[l]) {
					dp[l][r][1] = (dp[l][r][1] + dp[l][r - 1][0]) % MOD;
				}
				if (nums[r] &gt; nums[r - 1]) {
					dp[l][r][1] = (dp[l][r][1] + dp[l][r - 1][1]) % MOD;
				}
			}
		}
		return (dp[1][n][0] + dp[1][n][1]) % MOD;
	}

	// 时间复杂度O(n^2)
	// 空间压缩
	public static int compute2() {
		if (nums[n - 1] &lt; nums[n]) {
			dp[n][0] = 1;
			dp[n][1] = 1;
		}
		for (int l = n - 2; l &gt;= 1; l--) {
			if (nums[l] &lt; nums[l + 1]) {
				dp[l + 1][0] = 1;
				dp[l + 1][1] = 1;
			} else {
				dp[l + 1][0] = 0;
				dp[l + 1][1] = 0;
			}
			for (int r = l + 2; r &lt;= n; r++) {
				int a = 0;
				int b = 0;
				if (nums[l] &lt; nums[l + 1]) {
					a = (a + dp[r][0]) % MOD;
				}
				if (nums[l] &lt; nums[r]) {
					a = (a + dp[r][1]) % MOD;
				}
				if (nums[r] &gt; nums[l]) {
					b = (b + dp[r - 1][0]) % MOD;
				}
				if (nums[r] &gt; nums[r - 1]) {
					b = (b + dp[r - 1][1]) % MOD;
				}
				dp[r][0] = a;
				dp[r][1] = b;
			}
		}
		return (dp[n][0] + dp[n][1]) % MOD;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/Xr1e0RzRUI4?start=1890">
    </iframe>
</details>
<h2 id="remove-boxes"><a class="header" href="#remove-boxes">Remove Boxes</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0500-0599/0546.Remove%20Boxes/README_EN.md
tags:
    - Memoization
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="546-remove-boxes"><a class="header" href="#546-remove-boxes"><a href="https://leetcode.com/problems/remove-boxes">546. Remove Boxes</a></a></h1>
<p><a href="dynamic-programming//solution/0500-0599/0546.Remove%20Boxes/README.html">中文文档</a></p>
<h2 id="description-32"><a class="header" href="#description-32">Description</a></h2>
<!-- description:start -->
<p>You are given several <code>boxes</code> with different colors represented by different positive numbers.</p>
<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of <code>k</code> boxes, <code>k &gt;= 1</code>), remove them and get <code>k * k</code> points.</p>
<p>Return <em>the maximum points you can get</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> boxes = [1,3,2,2,2,3,4,3,1]
<strong>Output:</strong> 23
<strong>Explanation:</strong>
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
```-&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) 
```-&gt; [1, 3, 3, 3, 1] (1*1=1 points) 
```-&gt; [1, 1] (3*3=9 points) 
```-&gt; [] (2*2=4 points)
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> boxes = [1,1,1]
<strong>Output:</strong> 9
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> boxes = [1]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= boxes.length &lt;= 100</code></li>
	<li><code>1 &lt;= boxes[i]&nbsp;&lt;= 100</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-32"><a class="header" href="#solutions-32">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-7"><a class="header" href="#solution-1-7">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-48"><a class="header" href="#python3-48">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def removeBoxes(self, boxes: List[int]) -&gt; int:
        @cache
        def dfs(i, j, k):
            if i &gt; j:
                return 0
            while i &lt; j and boxes[j] == boxes[j - 1]:
                j, k = j - 1, k + 1
            ans = dfs(i, j - 1, 0) + (k + 1) * (k + 1)
            for h in range(i, j):
                if boxes[h] == boxes[j]:
                    ans = max(ans, dfs(h + 1, j - 1, 0) + dfs(i, h, k + 1))
            return ans

        n = len(boxes)
        ans = dfs(0, n - 1, 0)
        dfs.cache_clear()
        return ans
</code></pre>
<h4 id="java-46"><a class="header" href="#java-46">Java</a></h4>
<pre><code class="language-java">class Solution {
    private int[][][] f;
    private int[] b;

    public int removeBoxes(int[] boxes) {
        b = boxes;
        int n = b.length;
        f = new int[n][n][n];
        return dfs(0, n - 1, 0);
    }

    private int dfs(int i, int j, int k) {
        if (i &gt; j) {
            return 0;
        }
        while (i &lt; j &amp;&amp; b[j] == b[j - 1]) {
            --j;
            ++k;
        }
        if (f[i][j][k] &gt; 0) {
            return f[i][j][k];
        }
        int ans = dfs(i, j - 1, 0) + (k + 1) * (k + 1);
        for (int h = i; h &lt; j; ++h) {
            if (b[h] == b[j]) {
                ans = Math.max(ans, dfs(h + 1, j - 1, 0) + dfs(i, h, k + 1));
            }
        }
        f[i][j][k] = ans;
        return ans;
    }
}
</code></pre>
<h4 id="c-57"><a class="header" href="#c-57">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int removeBoxes(vector&lt;int&gt;&amp; boxes) {
        int n = boxes.size();
        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n)));
        function&lt;int(int, int, int)&gt; dfs;
        dfs = [&amp;](int i, int j, int k) {
            if (i &gt; j) return 0;
            while (i &lt; j &amp;&amp; boxes[j] == boxes[j - 1]) {
                --j;
                ++k;
            }
            if (f[i][j][k]) return f[i][j][k];
            int ans = dfs(i, j - 1, 0) + (k + 1) * (k + 1);
            for (int h = i; h &lt; j; ++h) {
                if (boxes[h] == boxes[j]) {
                    ans = max(ans, dfs(h + 1, j - 1, 0) + dfs(i, h, k + 1));
                }
            }
            f[i][j][k] = ans;
            return ans;
        };
        return dfs(0, n - 1, 0);
    }
};
</code></pre>
<h4 id="go-46"><a class="header" href="#go-46">Go</a></h4>
<pre><code class="language-go">func removeBoxes(boxes []int) int {
	n := len(boxes)
	f := make([][][]int, n)
	for i := range f {
		f[i] = make([][]int, n)
		for j := range f[i] {
			f[i][j] = make([]int, n)
		}
	}
	var dfs func(i, j, k int) int
	dfs = func(i, j, k int) int {
		if i &gt; j {
			return 0
		}
		for i &lt; j &amp;&amp; boxes[j] == boxes[j-1] {
			j, k = j-1, k+1
		}
		if f[i][j][k] &gt; 0 {
			return f[i][j][k]
		}
		ans := dfs(i, j-1, 0) + (k+1)*(k+1)
		for h := i; h &lt; j; h++ {
			if boxes[h] == boxes[j] {
				ans = max(ans, dfs(h+1, j-1, 0)+dfs(i, h, k+1))
			}
		}
		f[i][j][k] = ans
		return ans
	}
	return dfs(0, n-1, 0)
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class077;

// 移除盒子
// 给出一些不同颜色的盒子boxes，盒子的颜色由不同的正数表示
// 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止
// 每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1）
// 这样一轮之后你将得到 k * k 个积分
// 返回你能获得的最大积分总和
// 测试链接 : https://leetcode.com/problems/remove-boxes/
public class Code04_RemoveBoxes {

	// 时间复杂度O(n^4)
	public static int removeBoxes(int[] boxes) {
		int n = boxes.length;
		int[][][] dp = new int[n][n][n];
		return f(boxes, 0, n - 1, 0, dp);
	}

	// boxes[l....r]范围上要去消除，前面跟着k个连续的和boxes[l]颜色一样的盒子
	// 这种情况下，返回最大得分
	public static int f(int[] boxes, int l, int r, int k, int[][][] dp) {
		if (l &gt; r) {
			return 0;
		}
		// l &lt;= r
		if (dp[l][r][k] &gt; 0) {
			return dp[l][r][k];
		}
		int s = l;
		while (s + 1 &lt;= r &amp;&amp; boxes[l] == boxes[s + 1]) {
			s++;
		}
		// boxes[l...s]都是一种颜色，boxes[s+1]就不是同一种颜色了
		// cnt是总前缀数量 : 之前的相同前缀(k个) + l...s这个颜色相同的部分(s-l+1个)
		int cnt = k + s - l + 1;
		// 可能性1 : 前缀先消
		int ans = cnt * cnt + f(boxes, s + 1, r, 0, dp);
		// 可能性2 : 讨论前缀跟着哪个后，一起消掉
		for (int m = s + 2; m &lt;= r; m++) {
			if (boxes[l] == boxes[m] &amp;&amp; boxes[m - 1] != boxes[m]) {
				// boxes[l] == boxes[m]是必须条件
				// boxes[m - 1] != boxes[m]是剪枝条件，避免不必要的调用
				ans = Math.max(ans, f(boxes, s + 1, m - 1, 0, dp) + f(boxes, m, r, cnt, dp));
			}
		}
		dp[l][r][k] = ans;
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/Xr1e0RzRUI4?start=3374">
    </iframe>
</details>
<h2 id="minimum-cost-to-merge-stones"><a class="header" href="#minimum-cost-to-merge-stones">Minimum Cost to Merge Stones</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/1000-1099/1000.Minimum%20Cost%20to%20Merge%20Stones/README_EN.md
rating: 2422
source: Weekly Contest 126 Q4
tags:
    - Array
    - Dynamic Programming
    - Prefix Sum
</code></pre>
<!-- problem:start -->
<h1 id="1000-minimum-cost-to-merge-stones"><a class="header" href="#1000-minimum-cost-to-merge-stones"><a href="https://leetcode.com/problems/minimum-cost-to-merge-stones">1000. Minimum Cost to Merge Stones</a></a></h1>
<p><a href="dynamic-programming//solution/1000-1099/1000.Minimum%20Cost%20to%20Merge%20Stones/README.html">中文文档</a></p>
<h2 id="description-33"><a class="header" href="#description-33">Description</a></h2>
<!-- description:start -->
<p>There are <code>n</code> piles of <code>stones</code> arranged in a row. The <code>i<sup>th</sup></code> pile has <code>stones[i]</code> stones.</p>
<p>A move consists of merging exactly <code>k</code> <strong>consecutive</strong> piles into one pile, and the cost of this move is equal to the total number of stones in these <code>k</code> piles.</p>
<p>Return <em>the minimum cost to merge all piles of stones into one pile</em>. If it is impossible, return <code>-1</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> stones = [3,2,4,1], k = 2
<strong>Output:</strong> 20
<strong>Explanation:</strong> We start with [3, 2, 4, 1].
We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
We merge [4, 1] for a cost of 5, and we are left with [5, 5].
We merge [5, 5] for a cost of 10, and we are left with [10].
The total cost was 20, and this is the minimum possible.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> stones = [3,2,4,1], k = 3
<strong>Output:</strong> -1
<strong>Explanation:</strong> After any merge operation, there are 2 piles left, and we can&#39;t merge anymore.  So the task is impossible.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> stones = [3,5,1,2,6], k = 3
<strong>Output:</strong> 25
<strong>Explanation:</strong> We start with [3, 5, 1, 2, 6].
We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
We merge [3, 8, 6] for a cost of 17, and we are left with [17].
The total cost was 25, and this is the minimum possible.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == stones.length</code></li>
	<li><code>1 &lt;= n &lt;= 30</code></li>
	<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
	<li><code>2 &lt;= k &lt;= 30</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-33"><a class="header" href="#solutions-33">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-8"><a class="header" href="#solution-1-8">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-49"><a class="header" href="#python3-49">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def mergeStones(self, stones: List[int], K: int) -&gt; int:
        n = len(stones)
        if (n - 1) % (K - 1):
            return -1
        s = list(accumulate(stones, initial=0))
        f = [[[inf] * (K + 1) for _ in range(n + 1)] for _ in range(n + 1)]
        for i in range(1, n + 1):
            f[i][i][1] = 0
        for l in range(2, n + 1):
            for i in range(1, n - l + 2):
                j = i + l - 1
                for k in range(1, K + 1):
                    for h in range(i, j):
                        f[i][j][k] = min(f[i][j][k], f[i][h][1] + f[h + 1][j][k - 1])
                f[i][j][1] = f[i][j][K] + s[j] - s[i - 1]
        return f[1][n][1]
</code></pre>
<h4 id="java-47"><a class="header" href="#java-47">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int mergeStones(int[] stones, int K) {
        int n = stones.length;
        if ((n - 1) % (K - 1) != 0) {
            return -1;
        }
        int[] s = new int[n + 1];
        for (int i = 1; i &lt;= n; ++i) {
            s[i] = s[i - 1] + stones[i - 1];
        }
        int[][][] f = new int[n + 1][n + 1][K + 1];
        final int inf = 1 &lt;&lt; 20;
        for (int[][] g : f) {
            for (int[] e : g) {
                Arrays.fill(e, inf);
            }
        }
        for (int i = 1; i &lt;= n; ++i) {
            f[i][i][1] = 0;
        }
        for (int l = 2; l &lt;= n; ++l) {
            for (int i = 1; i + l - 1 &lt;= n; ++i) {
                int j = i + l - 1;
                for (int k = 1; k &lt;= K; ++k) {
                    for (int h = i; h &lt; j; ++h) {
                        f[i][j][k] = Math.min(f[i][j][k], f[i][h][1] + f[h + 1][j][k - 1]);
                    }
                }
                f[i][j][1] = f[i][j][K] + s[j] - s[i - 1];
            }
        }
        return f[1][n][1];
    }
}
</code></pre>
<h4 id="c-58"><a class="header" href="#c-58">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int mergeStones(vector&lt;int&gt;&amp; stones, int K) {
        int n = stones.size();
        if ((n - 1) % (K - 1)) {
            return -1;
        }
        int s[n + 1];
        s[0] = 0;
        for (int i = 1; i &lt;= n; ++i) {
            s[i] = s[i - 1] + stones[i - 1];
        }
        int f[n + 1][n + 1][K + 1];
        memset(f, 0x3f, sizeof(f));
        for (int i = 1; i &lt;= n; ++i) {
            f[i][i][1] = 0;
        }
        for (int l = 2; l &lt;= n; ++l) {
            for (int i = 1; i + l - 1 &lt;= n; ++i) {
                int j = i + l - 1;
                for (int k = 1; k &lt;= K; ++k) {
                    for (int h = i; h &lt; j; ++h) {
                        f[i][j][k] = min(f[i][j][k], f[i][h][1] + f[h + 1][j][k - 1]);
                    }
                }
                f[i][j][1] = f[i][j][K] + s[j] - s[i - 1];
            }
        }
        return f[1][n][1];
    }
};
</code></pre>
<h4 id="go-47"><a class="header" href="#go-47">Go</a></h4>
<pre><code class="language-go">func mergeStones(stones []int, K int) int {
	n := len(stones)
	if (n-1)%(K-1) != 0 {
		return -1
	}
	s := make([]int, n+1)
	for i, x := range stones {
		s[i+1] = s[i] + x
	}
	f := make([][][]int, n+1)
	for i := range f {
		f[i] = make([][]int, n+1)
		for j := range f[i] {
			f[i][j] = make([]int, K+1)
			for k := range f[i][j] {
				f[i][j][k] = 1 &lt;&lt; 20
			}
		}
	}
	for i := 1; i &lt;= n; i++ {
		f[i][i][1] = 0
	}
	for l := 2; l &lt;= n; l++ {
		for i := 1; i &lt;= n-l+1; i++ {
			j := i + l - 1
			for k := 2; k &lt;= K; k++ {
				for h := i; h &lt; j; h++ {
					f[i][j][k] = min(f[i][j][k], f[i][h][k-1]+f[h+1][j][1])
				}
			}
			f[i][j][1] = f[i][j][K] + s[j] - s[i-1]
		}
	}
	return f[1][n][1]
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class077;

// 合并石头的最低成本
// 有 n 堆石头排成一排，第 i 堆中有 stones[i] 块石头
// 每次 移动 需要将 连续的 k 堆石头合并为一堆，而这次移动的成本为这 k 堆中石头的总数
// 返回把所有石头合并成一堆的最低成本
// 如果无法合并成一堆返回-1
// 测试链接 : https://leetcode.com/problems/minimum-cost-to-merge-stones/
public class Code05_MinimumCostToMergeStones {

	// 时间复杂度O(n^3)
	// 优化策略来自于观察
	// l.....r最终会变成几份其实是注定的，根本就无法改变
	// 那么也就知道，满足(n - 1) % (k - 1) == 0的情况下，
	// 0....n-1最终一定是1份，也无法改变
	// 如果l.....r最终一定是1份
	// 那么要保证l.....m最终一定是1份，m+1...r最终一定是k-1份
	// 如果l.....r最终一定是p份（p&gt;1）
	// 那么要保证l.....m最终一定是1份，那么m+1...r最终一定是p-1份
	// 怎么保证的？枚举行为中，m += k-1很重要！
	// m每次跳k-1！
	// 如果l.....r最终一定是1份
	// 就一定能保证l.....m最终一定是1份
	// 也一定能保证m+1...r最终一定是k-1份
	// 不要忘了，加上最后合并成1份的代价
	// 如果l.....r最终一定是p份
	// 就一定能保证l.....m最终一定是1份
	// 也一定能保证m+1...r最终一定是p-1份
	// 不用加上最后合并成1份的代价
	public static int mergeStones(int[] stones, int k) {
		int n = stones.length;
		if ((n - 1) % (k - 1) != 0) {
			return -1;
		}
		int[] presum = new int[n + 1];
		// 多补了一个0位置，l...r累加和 : presum[r+1] - presum[l]
		for (int i = 0, j = 1, sum = 0; i &lt; n; i++, j++) {
			sum += stones[i];
			presum[j] = sum;
		}
		// dp[l][r] : l...r范围上的石头，合并到不能再合并（份数是确定的），最小代价是多少
		int[][] dp = new int[n][n];
		for (int l = n - 2, ans; l &gt;= 0; l--) {
			for (int r = l + 1; r &lt; n; r++) {
				ans = Integer.MAX_VALUE;
				for (int m = l; m &lt; r; m += k - 1) {
					ans = Math.min(ans, dp[l][m] + dp[m + 1][r]);
				}
				if ((r - l) % (k - 1) == 0) {
					// 最终一定能划分成一份，那么就再加合并代价
					ans += presum[r + 1] - presum[l];
				}
				dp[l][r] = ans;
			}
		}
		return dp[0][n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/Xr1e0RzRUI4?start=4820">
    </iframe>
</details>
<h2 id="count-different-palindromic-subsequences"><a class="header" href="#count-different-palindromic-subsequences">Count Different Palindromic Subsequences</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0700-0799/0730.Count%20Different%20Palindromic%20Subsequences/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="730-count-different-palindromic-subsequences"><a class="header" href="#730-count-different-palindromic-subsequences"><a href="https://leetcode.com/problems/count-different-palindromic-subsequences">730. Count Different Palindromic Subsequences</a></a></h1>
<p><a href="dynamic-programming//solution/0700-0799/0730.Count%20Different%20Palindromic%20Subsequences/README.html">中文文档</a></p>
<h2 id="description-34"><a class="header" href="#description-34">Description</a></h2>
<!-- description:start -->
<p>Given a string s, return <em>the number of different non-empty palindromic subsequences in</em> <code>s</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
<p>A subsequence of a string is obtained by deleting zero or more characters from the string.</p>
<p>A sequence is palindromic if it is equal to the sequence reversed.</p>
<p>Two sequences <code>a<sub>1</sub>, a<sub>2</sub>, ...</code> and <code>b<sub>1</sub>, b<sub>2</sub>, ...</code> are different if there is some <code>i</code> for which <code>a<sub>i</sub> != b<sub>i</sub></code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;bccb&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> The 6 different non-empty palindromic subsequences are &#39;b&#39;, &#39;c&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;bcb&#39;, &#39;bccb&#39;.
Note that &#39;bcb&#39; is counted only once, even though it occurs twice.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&quot;
<strong>Output:</strong> 104860361
<strong>Explanation:</strong> There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10<sup>9</sup> + 7.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s[i]</code> is either <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, or <code>&#39;d&#39;</code>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-34"><a class="header" href="#solutions-34">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-9"><a class="header" href="#solution-1-9">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-50"><a class="header" href="#python3-50">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def countPalindromicSubsequences(self, s: str) -&gt; int:
        mod = 10**9 + 7
        n = len(s)
        dp = [[[0] * 4 for _ in range(n)] for _ in range(n)]
        for i, c in enumerate(s):
            dp[i][i][ord(c) - ord('a')] = 1
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                for c in 'abcd':
                    k = ord(c) - ord('a')
                    if s[i] == s[j] == c:
                        dp[i][j][k] = 2 + sum(dp[i + 1][j - 1])
                    elif s[i] == c:
                        dp[i][j][k] = dp[i][j - 1][k]
                    elif s[j] == c:
                        dp[i][j][k] = dp[i + 1][j][k]
                    else:
                        dp[i][j][k] = dp[i + 1][j - 1][k]
        return sum(dp[0][-1]) % mod
</code></pre>
<h4 id="java-48"><a class="header" href="#java-48">Java</a></h4>
<pre><code class="language-java">class Solution {
    private final int MOD = (int) 1e9 + 7;

    public int countPalindromicSubsequences(String s) {
        int n = s.length();
        long[][][] dp = new long[n][n][4];
        for (int i = 0; i &lt; n; ++i) {
            dp[i][i][s.charAt(i) - 'a'] = 1;
        }
        for (int l = 2; l &lt;= n; ++l) {
            for (int i = 0; i + l &lt;= n; ++i) {
                int j = i + l - 1;
                for (char c = 'a'; c &lt;= 'd'; ++c) {
                    int k = c - 'a';
                    if (s.charAt(i) == c &amp;&amp; s.charAt(j) == c) {
                        dp[i][j][k] = 2 + dp[i + 1][j - 1][0] + dp[i + 1][j - 1][1]
                            + dp[i + 1][j - 1][2] + dp[i + 1][j - 1][3];
                        dp[i][j][k] %= MOD;
                    } else if (s.charAt(i) == c) {
                        dp[i][j][k] = dp[i][j - 1][k];
                    } else if (s.charAt(j) == c) {
                        dp[i][j][k] = dp[i + 1][j][k];
                    } else {
                        dp[i][j][k] = dp[i + 1][j - 1][k];
                    }
                }
            }
        }
        long ans = 0;
        for (int k = 0; k &lt; 4; ++k) {
            ans += dp[0][n - 1][k];
        }
        return (int) (ans % MOD);
    }
}
</code></pre>
<h4 id="c-59"><a class="header" href="#c-59">C++</a></h4>
<pre><code class="language-cpp">using ll = long long;

class Solution {
public:
    int countPalindromicSubsequences(string s) {
        int mod = 1e9 + 7;
        int n = s.size();
        vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; dp(n, vector&lt;vector&lt;ll&gt;&gt;(n, vector&lt;ll&gt;(4)));
        for (int i = 0; i &lt; n; ++i) dp[i][i][s[i] - 'a'] = 1;
        for (int l = 2; l &lt;= n; ++l) {
            for (int i = 0; i + l &lt;= n; ++i) {
                int j = i + l - 1;
                for (char c = 'a'; c &lt;= 'd'; ++c) {
                    int k = c - 'a';
                    if (s[i] == c &amp;&amp; s[j] == c)
                        dp[i][j][k] = 2 + accumulate(dp[i + 1][j - 1].begin(), dp[i + 1][j - 1].end(), 0ll) % mod;
                    else if (s[i] == c)
                        dp[i][j][k] = dp[i][j - 1][k];
                    else if (s[j] == c)
                        dp[i][j][k] = dp[i + 1][j][k];
                    else
                        dp[i][j][k] = dp[i + 1][j - 1][k];
                }
            }
        }
        ll ans = accumulate(dp[0][n - 1].begin(), dp[0][n - 1].end(), 0ll);
        return (int) (ans % mod);
    }
};
</code></pre>
<h4 id="go-48"><a class="header" href="#go-48">Go</a></h4>
<pre><code class="language-go">func countPalindromicSubsequences(s string) int {
	mod := int(1e9) + 7
	n := len(s)
	dp := make([][][]int, n)
	for i := range dp {
		dp[i] = make([][]int, n)
		for j := range dp[i] {
			dp[i][j] = make([]int, 4)
		}
	}
	for i, c := range s {
		dp[i][i][c-'a'] = 1
	}
	for l := 2; l &lt;= n; l++ {
		for i := 0; i+l &lt;= n; i++ {
			j := i + l - 1
			for _, c := range [4]byte{'a', 'b', 'c', 'd'} {
				k := int(c - 'a')
				if s[i] == c &amp;&amp; s[j] == c {
					dp[i][j][k] = 2 + (dp[i+1][j-1][0]+dp[i+1][j-1][1]+dp[i+1][j-1][2]+dp[i+1][j-1][3])%mod
				} else if s[i] == c {
					dp[i][j][k] = dp[i][j-1][k]
				} else if s[j] == c {
					dp[i][j][k] = dp[i+1][j][k]
				} else {
					dp[i][j][k] = dp[i+1][j-1][k]
				}
			}
		}
	}
	ans := 0
	for _, v := range dp[0][n-1] {
		ans += v
	}
	return ans % mod
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class077;

import java.util.Arrays;

// 统计不同回文子序列
// 给你一个字符串s，返回s中不同的非空回文子序列个数
// 由于答案可能很大，答案对 1000000007 取模
// 测试链接 : https://leetcode.com/problems/count-different-palindromic-subsequences/
public class Code06_CountDifferentPalindromicSubsequences {

	// 时间复杂度O(n^2)
	public static int countPalindromicSubsequences(String str) {
		int mod = 1000000007;
		char[] s = str.toCharArray();
		int n = s.length;
		int[] last = new int[256];
		// left[i] : i位置的左边和s[i]字符相等且最近的位置在哪，不存在就是-1
		int[] left = new int[n];
		Arrays.fill(last, -1);
		for (int i = 0; i &lt; n; i++) {
			left[i] = last[s[i]];
			last[s[i]] = i;
		}
		// right[i] : i位置的右边和s[i]字符相等且最近的位置在哪，不存在就是n
		int[] right = new int[n];
		Arrays.fill(last, n);
		for (int i = n - 1; i &gt;= 0; i--) {
			right[i] = last[s[i]];
			last[s[i]] = i;
		}
		// dp[i][j] : i...j范围上有多少不同的回文子序列
		// 如果i&gt;j，那么认为是无效范围dp[i][j] = 0
		long[][] dp = new long[n][n];
		for (int i = 0; i &lt; n; i++) {
			dp[i][i] = 1;
		}
		for (int i = n - 2, l, r; i &gt;= 0; i--) {
			for (int j = i + 1; j &lt; n; j++) {
				if (s[i] != s[j]) {
					// a ..... b
					// i       j
					// 因为要取模，所以只要发生减操作就+mod，讲解041同余原理
					dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1] + mod;
				} else {
					// s[i] == s[j]
					// a......a
					// i      j
					l = right[i];
					r = left[j];
					if (l &gt; r) {
						// i...j的内部没有s[i]字符
						// a....a
						// i    j
						// (i+1..j-1) + a(i+1..j-1)a + a + aa
						dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
					} else if (l == r) {
						// i...j的内部有一个s[i]字符
						// a.....a......a
						// i     lr     j
						// (i+1..j-1) + a(i+1..j-1)a + aa
						dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
					} else {
						// i...j的内部不只一个s[i]字符
						// a...a....这内部可能还有a但是不重要....a...a
						// i   l                             r   j
						// 因为要取模，所以只要发生减操作就+mod，讲解041同余原理
						dp[i][j] = dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1] + mod;
					}
				}
				dp[i][j] %= mod;
			}
		}
		return (int) dp[0][n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/Xr1e0RzRUI4?start=6548">
    </iframe>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
