<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Structures and Algorithms for Coding Interviews</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithms for Coding Interviews</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h1>
<h2 id="top-down-approach-recursive-solution"><a class="header" href="#top-down-approach-recursive-solution">Top-Down Approach (Recursive Solution)</a></h2>
<ul>
<li>Divide the original problem into smaller sub-problems</li>
<li>Recursively solve the sub-problems</li>
<li>Compute the final answer from the sub-problems solutions</li>
</ul>
<h2 id="bottom-up-approach-iterative-solution"><a class="header" href="#bottom-up-approach-iterative-solution">Bottom-Up Approach (Iterative Solution)</a></h2>
<ul>
<li>Construct the <code>State Table</code> (DP table)</li>
<li>Design the <code>State Transition Plan</code></li>
<li>Initialize <code>State Table</code> with the base-case solutions</li>
<li>Fill the rest of <code>State Table</code> using the <code>State Transition Plan</code></li>
<li>Return the final state</li>
</ul>
<h2 id="optimization"><a class="header" href="#optimization">Optimization</a></h2>
<ul>
<li>Using memoization (caching) with the recursive solution</li>
<li>Considering state compression (space optimization) for the iterative solution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-dimentional-dp-problems"><a class="header" href="#one-dimentional-dp-problems">One-Dimentional DP Problems</a></h1>
<h2 id="fibonacci-number"><a class="header" href="#fibonacci-number">Fibonacci Number</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Easy
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0500-0599/0509.Fibonacci%20Number/README_EN.md
tags:
    - Recursion
    - Memoization
    - Math
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="509-fibonacci-number"><a class="header" href="#509-fibonacci-number"><a href="https://leetcode.com/problems/fibonacci-number">509. Fibonacci Number</a></a></h1>
<p><a href="dynamic-programming//solution/0500-0599/0509.Fibonacci%20Number/README.html">中文文档</a></p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<!-- description:start -->
<p>The <b>Fibonacci numbers</b>, commonly denoted <code>F(n)</code> form a sequence, called the <b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<pre>
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n &gt; 1.
</pre>
<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-recurrence"><a class="header" href="#solution-1-recurrence">Solution 1: Recurrence</a></h3>
<p>We define two variables $a$ and $b$, initially $a = 0$ and $b = 1$.</p>
<p>Next, we perform $n$ iterations. In each iteration, we update the values of $a$ and $b$ to $b$ and $a + b$, respectively.</p>
<p>Finally, we return $a$.</p>
<p>The time complexity is $O(n)$, where $n$ is the given integer. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3"><a class="header" href="#python3">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def fib(self, n: int) -&gt; int:
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a
</code></pre>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int fib(int n) {
        int a = 0, b = 1;
        while (n-- &gt; 0) {
            int c = a + b;
            a = b;
            b = c;
        }
        return a;
    }
}
</code></pre>
<h4 id="c"><a class="header" href="#c">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int fib(int n) {
        int a = 0, b = 1;
        while (n--) {
            int c = a + b;
            a = b;
            b = c;
        }
        return a;
    }
};
</code></pre>
<h4 id="go"><a class="header" href="#go">Go</a></h4>
<pre><code class="language-go">func fib(n int) int {
	a, b := 0, 1
	for i := 0; i &lt; n; i++ {
		a, b = b, a+b
	}
	return a
}
</code></pre>
<h4 id="typescript"><a class="header" href="#typescript">TypeScript</a></h4>
<pre><code class="language-ts">function fib(n: number): number {
    let [a, b] = [0, 1];
    while (n--) {
        [a, b] = [b, a + b];
    }
    return a;
}
</code></pre>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn fib(n: i32) -&gt; i32 {
        let mut a = 0;
        let mut b = 1;
        for _ in 0..n {
            let t = b;
            b = a + b;
            a = t;
        }
        a
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript"><a class="header" href="#javascript">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number} n
 * @return {number}
 */
var fib = function (n) {
    let [a, b] = [0, 1];
    while (n--) {
        [a, b] = [b, a + b];
    }
    return a;
};
</code></pre>
<h4 id="php"><a class="header" href="#php">PHP</a></h4>
<pre><code class="language-php">class Solution {
    /**
     * @param Integer $n
     * @return Integer
     */
    function fib($n) {
        $a = 0;
        $b = 1;
        for ($i = 0; $i &lt; $n; $i++) {
            $temp = $a;
            $a = $b;
            $b = $temp + $b;
        }
        return $a;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-matrix-exponentiation"><a class="header" href="#solution-2-matrix-exponentiation">Solution 2: Matrix Exponentiation</a></h3>
<p>We define $\textit{Fib}(n)$ as a $1 \times 2$ matrix $\begin{bmatrix} F_n &amp; F_{n - 1} \end{bmatrix}$, where $F_n$ and $F_{n - 1}$ are the $n$-th and $(n - 1)$-th Fibonacci numbers, respectively.</p>
<p>We want to derive $\textit{Fib}(n)$ from $\textit{Fib}(n - 1) = \begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \end{bmatrix}$. In other words, we need a matrix $\textit{base}$ such that $\textit{Fib}(n - 1) \times \textit{base} = \textit{Fib}(n)$, i.e.:</p>
<p>$$
\begin{bmatrix}
F_{n - 1} &amp; F_{n - 2}
\end{bmatrix} \times \textit{base} = \begin{bmatrix} F_n &amp; F_{n - 1} \end{bmatrix}
$$</p>
<p>Since $F_n = F_{n - 1} + F_{n - 2}$, the first column of the matrix $\textit{base}$ is:</p>
<p>$$
\begin{bmatrix}
1 \
1
\end{bmatrix}
$$</p>
<p>The second column is:</p>
<p>$$
\begin{bmatrix}
1 \
0
\end{bmatrix}
$$</p>
<p>Thus, we have:</p>
<p>$$
\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \end{bmatrix} \times \begin{bmatrix}1 &amp; 1 \ 1 &amp; 0\end{bmatrix} = \begin{bmatrix} F_n &amp; F_{n - 1} \end{bmatrix}
$$</p>
<p>We define the initial matrix $res = \begin{bmatrix} 1 &amp; 0 \end{bmatrix}$, then $F_n$ is equal to the second element of the first row of the result matrix obtained by multiplying $res$ with $\textit{base}^{n}$. We can solve this using matrix exponentiation.</p>
<p>The time complexity is $O(\log n)$, and the space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-1"><a class="header" href="#python3-1">Python3</a></h4>
<pre><code class="language-python">import numpy as np


class Solution:
    def fib(self, n: int) -&gt; int:
        factor = np.asmatrix([(1, 1), (1, 0)], np.dtype("O"))
        res = np.asmatrix([(1, 0)], np.dtype("O"))
        while n:
            if n &amp; 1:
                res = res * factor
            factor = factor * factor
            n &gt;&gt;= 1
        return res[0, 1]
</code></pre>
<h4 id="java-1"><a class="header" href="#java-1">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int fib(int n) {
        int[][] a = {{1, 1}, {1, 0}};
        return pow(a, n)[0][1];
    }

    private int[][] mul(int[][] a, int[][] b) {
        int m = a.length, n = b[0].length;
        int[][] c = new int[m][n];
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                for (int k = 0; k &lt; b.length; ++k) {
                    c[i][j] = c[i][j] + a[i][k] * b[k][j];
                }
            }
        }
        return c;
    }

    private int[][] pow(int[][] a, int n) {
        int[][] res = {{1, 0}};
        while (n &gt; 0) {
            if ((n &amp; 1) == 1) {
                res = mul(res, a);
            }
            a = mul(a, a);
            n &gt;&gt;= 1;
        }
        return res;
    }
}
</code></pre>
<h4 id="c-1"><a class="header" href="#c-1">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int fib(int n) {
        vector&lt;vector&lt;int&gt;&gt; a = {{1, 1}, {1, 0}};
        return qpow(a, n)[0][1];
    }

    vector&lt;vector&lt;int&gt;&gt; mul(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;vector&lt;int&gt;&gt;&amp; b) {
        int m = a.size(), n = b[0].size();
        vector&lt;vector&lt;int&gt;&gt; c(m, vector&lt;int&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                for (int k = 0; k &lt; b.size(); ++k) {
                    c[i][j] = c[i][j] + a[i][k] * b[k][j];
                }
            }
        }
        return c;
    }

    vector&lt;vector&lt;int&gt;&gt; qpow(vector&lt;vector&lt;int&gt;&gt;&amp; a, int n) {
        vector&lt;vector&lt;int&gt;&gt; res = {{1, 0}};
        while (n) {
            if (n &amp; 1) {
                res = mul(res, a);
            }
            a = mul(a, a);
            n &gt;&gt;= 1;
        }
        return res;
    }
};
</code></pre>
<h4 id="go-1"><a class="header" href="#go-1">Go</a></h4>
<pre><code class="language-go">func fib(n int) int {
	a := [][]int{{1, 1}, {1, 0}}
	return pow(a, n)[0][1]
}

func mul(a, b [][]int) [][]int {
	m, n := len(a), len(b[0])
	c := make([][]int, m)
	for i := range c {
		c[i] = make([]int, n)
	}
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			for k := 0; k &lt; len(b); k++ {
				c[i][j] = c[i][j] + a[i][k]*b[k][j]
			}
		}
	}
	return c
}

func pow(a [][]int, n int) [][]int {
	res := [][]int{{1, 0}}
	for n &gt; 0 {
		if n&amp;1 == 1 {
			res = mul(res, a)
		}
		a = mul(a, a)
		n &gt;&gt;= 1
	}
	return res
}
</code></pre>
<h4 id="typescript-1"><a class="header" href="#typescript-1">TypeScript</a></h4>
<pre><code class="language-ts">function fib(n: number): number {
    const a: number[][] = [
        [1, 1],
        [1, 0],
    ];
    return pow(a, n)[0][1];
}

function mul(a: number[][], b: number[][]): number[][] {
    const [m, n] = [a.length, b[0].length];
    const c = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; 0));
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            for (let k = 0; k &lt; b.length; ++k) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return c;
}

function pow(a: number[][], n: number): number[][] {
    let res = [[1, 0]];
    while (n) {
        if (n &amp; 1) {
            res = mul(res, a);
        }
        a = mul(a, a);
        n &gt;&gt;= 1;
    }
    return res;
}
</code></pre>
<h4 id="rust-1"><a class="header" href="#rust-1">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn fib(n: i32) -&gt; i32 {
        let a = vec![vec![1, 1], vec![1, 0]];
        pow(a, n as usize)[0][1]
    }
}

fn mul(a: Vec&lt;Vec&lt;i32&gt;&gt;, b: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let m = a.len();
    let n = b[0].len();
    let mut c = vec![vec![0; n]; m];

    for i in 0..m {
        for j in 0..n {
            for k in 0..b.len() {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    c
}

fn pow(mut a: Vec&lt;Vec&lt;i32&gt;&gt;, mut n: usize) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut res = vec![vec![1, 0], vec![0, 1]];

    while n &gt; 0 {
        if n &amp; 1 == 1 {
            res = mul(res, a.clone());
        }
        a = mul(a.clone(), a);
        n &gt;&gt;= 1;
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number} n
 * @return {number}
 */
var fib = function (n) {
    const a = [
        [1, 1],
        [1, 0],
    ];
    return pow(a, n)[0][1];
};

function mul(a, b) {
    const m = a.length,
        n = b[0].length;
    const c = Array.from({ length: m }, () =&gt; Array(n).fill(0));
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            for (let k = 0; k &lt; b.length; ++k) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return c;
}

function pow(a, n) {
    let res = [
        [1, 0],
        [0, 1],
    ];
    while (n &gt; 0) {
        if (n &amp; 1) {
            res = mul(res, a);
        }
        a = mul(a, a);
        n &gt;&gt;= 1;
    }
    return res;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class FibonacciNumber {

    // 1. Recursive solution without memoization
	public static int fib1(int n) {
		return f1(n);
	}

	public static int f1(int i) {
		if (i == 0) {
			return 0;
		}
		if (i == 1) {
			return 1;
		}
		return f1(i - 1) + f1(i - 2);
	}

    // 2. Recursive solution with memoization
	public static int fib2(int n) {
		int[] dp = new int[n + 1];
		Arrays.fill(dp, -1);
		return f2(n, dp);
	}

	public static int f2(int i, int[] dp) {
		if (i == 0) {
			return 0;
		}
		if (i == 1) {
			return 1;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		int ans = f2(i - 1, dp) + f2(i - 2, dp);
		dp[i] = ans;
		return ans;
	}

    // Iterative solution (state transition)
	public static int fib3(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		int[] dp = new int[n + 1];
		dp[1] = 1;
		for (int i = 2; i &lt;= n; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[n];
	}

    // Interative solution with space optimization
	public static int fib4(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		int lastLast = 0, last = 1;
		for (int i = 2, cur; i &lt;= n; i++) {
			cur = lastLast + last;
			lastLast = last;
			last = cur;
		}
		return last;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=270">
    </iframe>
</details>
<h2 id="minimum-cost-for-tickets"><a class="header" href="#minimum-cost-for-tickets">Minimum Cost for Tickets</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0983.Minimum%20Cost%20For%20Tickets/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="983-minimum-cost-for-tickets"><a class="header" href="#983-minimum-cost-for-tickets"><a href="https://leetcode.com/problems/minimum-cost-for-tickets">983. Minimum Cost For Tickets</a></a></h1>
<p><a href="dynamic-programming//solution/0900-0999/0983.Minimum%20Cost%20For%20Tickets/README.html">中文文档</a></p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<!-- description:start -->
<p>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array <code>days</code>. Each day is an integer from <code>1</code> to <code>365</code>.</p>
<p>Train tickets are sold in <strong>three different ways</strong>:</p>
<ul>
	<li>a <strong>1-day</strong> pass is sold for <code>costs[0]</code> dollars,</li>
	<li>a <strong>7-day</strong> pass is sold for <code>costs[1]</code> dollars, and</li>
	<li>a <strong>30-day</strong> pass is sold for <code>costs[2]</code> dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.</p>
<ul>
	<li>For example, if we get a <strong>7-day</strong> pass on day <code>2</code>, then we can travel for <code>7</code> days: <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, and <code>8</code>.</li>
</ul>
<p>Return <em>the minimum number of dollars you need to travel every day in the given list of days</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> days = [1,4,6,7,8,20], costs = [2,7,15]
<strong>Output:</strong> 11
<strong>Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
<strong>Output:</strong> 17
<strong>Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= days.length &lt;= 365</code></li>
	<li><code>1 &lt;= days[i] &lt;= 365</code></li>
	<li><code>days</code> is in strictly increasing order.</li>
	<li><code>costs.length == 3</code></li>
	<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-1"><a class="header" href="#solutions-1">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-memoization-search--binary-search"><a class="header" href="#solution-1-memoization-search--binary-search">Solution 1: Memoization Search + Binary Search</a></h3>
<p>We define a function $\textit{dfs(i)}$, which represents the minimum cost required from the $i$-th trip to the last trip. Thus, the answer is $\textit{dfs(0)}$.</p>
<p>The execution process of the function $\textit{dfs(i)}$ is as follows:</p>
<ul>
<li>If $i \geq n$, it means all trips have ended, return $0$;</li>
<li>Otherwise, we need to consider three types of purchases: buying a 1-day pass, buying a 7-day pass, and buying a 30-day pass. We calculate the cost for these three purchasing methods separately and use binary search to find the index $j$ of the next trip, then recursively call $\textit{dfs(j)}$, and finally return the minimum cost among these three purchasing methods.</li>
</ul>
<p>To avoid repeated calculations, we use memoization search to save the results that have already been calculated.</p>
<p>The time complexity is $O(n \times \log n)$, and the space complexity is $O(n)$. Here, $n$ represents the number of trips.</p>
<!-- tabs:start -->
<h4 id="python3-2"><a class="header" href="#python3-2">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int:
        @cache
        def dfs(i: int) -&gt; int:
            if i &gt;= n:
                return 0
            ans = inf
            for c, v in zip(costs, valid):
                j = bisect_left(days, days[i] + v)
                ans = min(ans, c + dfs(j))
            return ans

        n = len(days)
        valid = [1, 7, 30]
        return dfs(0)
</code></pre>
<h4 id="java-2"><a class="header" href="#java-2">Java</a></h4>
<pre><code class="language-java">class Solution {
    private final int[] valid = {1, 7, 30};
    private int[] days;
    private int[] costs;
    private Integer[] f;
    private int n;

    public int mincostTickets(int[] days, int[] costs) {
        n = days.length;
        f = new Integer[n];
        this.days = days;
        this.costs = costs;
        return dfs(0);
    }

    private int dfs(int i) {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i] != null) {
            return f[i];
        }
        f[i] = Integer.MAX_VALUE;
        for (int k = 0; k &lt; 3; ++k) {
            int j = Arrays.binarySearch(days, days[i] + valid[k]);
            j = j &lt; 0 ? -j - 1 : j;
            f[i] = Math.min(f[i], dfs(j) + costs[k]);
        }
        return f[i];
    }
}
</code></pre>
<h4 id="c-2"><a class="header" href="#c-2">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) {
        int valid[3] = {1, 7, 30};
        int n = days.size();
        int f[n];
        memset(f, 0, sizeof(f));
        function&lt;int(int)&gt; dfs = [&amp;](int i) {
            if (i &gt;= n) {
                return 0;
            }
            if (f[i]) {
                return f[i];
            }
            f[i] = INT_MAX;
            for (int k = 0; k &lt; 3; ++k) {
                int j = lower_bound(days.begin(), days.end(), days[i] + valid[k]) - days.begin();
                f[i] = min(f[i], dfs(j) + costs[k]);
            }
            return f[i];
        };
        return dfs(0);
    }
};
</code></pre>
<h4 id="go-2"><a class="header" href="#go-2">Go</a></h4>
<pre><code class="language-go">func mincostTickets(days []int, costs []int) int {
	valid := [3]int{1, 7, 30}
	n := len(days)
	f := make([]int, n)
	var dfs func(int) int
	dfs = func(i int) int {
		if i &gt;= n {
			return 0
		}
		if f[i] &gt; 0 {
			return f[i]
		}
		f[i] = 1 &lt;&lt; 30
		for k := 0; k &lt; 3; k++ {
			j := sort.SearchInts(days, days[i]+valid[k])
			f[i] = min(f[i], dfs(j)+costs[k])
		}
		return f[i]
	}
	return dfs(0)
}
</code></pre>
<h4 id="typescript-2"><a class="header" href="#typescript-2">TypeScript</a></h4>
<pre><code class="language-ts">function mincostTickets(days: number[], costs: number[]): number {
    const n = days.length;
    const f: number[] = Array(n).fill(0);
    const valid: number[] = [1, 7, 30];
    const search = (x: number): number =&gt; {
        let [l, r] = [0, n];
        while (l &lt; r) {
            const mid = (l + r) &gt;&gt; 1;
            if (days[mid] &gt;= x) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    };
    const dfs = (i: number): number =&gt; {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i]) {
            return f[i];
        }
        f[i] = Infinity;
        for (let k = 0; k &lt; 3; ++k) {
            const j = search(days[i] + valid[k]);
            f[i] = Math.min(f[i], dfs(j) + costs[k]);
        }
        return f[i];
    };
    return dfs(0);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-dynamic-programming"><a class="header" href="#solution-2-dynamic-programming">Solution 2: Dynamic Programming</a></h3>
<p>Let's denote the last day in the $\textit{days}$ array as $m$. We can define an array $f$ of length $m + 1$, where $f[i]$ represents the minimum cost from day $1$ to day $i$.</p>
<p>We can calculate the value of $f[i]$ in increasing order of the dates in the $\textit{days}$ array, starting from day $1$. If day $i$ is a travel day, we can consider three purchasing options: buying a 1-day pass, buying a 7-day pass, and buying a 30-day pass. We calculate the cost for these three purchasing methods separately and take the minimum cost among these three as the value of $f[i]$. If day $i$ is not a travel day, then $f[i] = f[i - 1]$.</p>
<p>The final answer is $f[m]$.</p>
<p>The time complexity is $O(m)$, and the space complexity is $O(m)$. Here, $m$ represents the last day of travel.</p>
<!-- tabs:start -->
<h4 id="python3-3"><a class="header" href="#python3-3">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int:
        m = days[-1]
        f = [0] * (m + 1)
        valid = [1, 7, 30]
        j = 0
        for i in range(1, m + 1):
            if i == days[j]:
                f[i] = inf
                for c, v in zip(costs, valid):
                    f[i] = min(f[i], f[max(0, i - v)] + c)
                j += 1
            else:
                f[i] = f[i - 1]
        return f[m]
</code></pre>
<h4 id="java-3"><a class="header" href="#java-3">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        int m = days[days.length - 1];
        int[] f = new int[m + 1];
        final int[] valid = {1, 7, 30};
        for (int i = 1, j = 0; i &lt;= m; ++i) {
            if (i == days[j]) {
                f[i] = Integer.MAX_VALUE;
                for (int k = 0; k &lt; 3; ++k) {
                    int c = costs[k], v = valid[k];
                    f[i] = Math.min(f[i], f[Math.max(0, i - v)] + c);
                }
                ++j;
            } else {
                f[i] = f[i - 1];
            }
        }
        return f[m];
    }
}
</code></pre>
<h4 id="c-3"><a class="header" href="#c-3">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) {
        int m = days.back();
        int f[m + 1];
        f[0] = 0;
        int valid[3] = {1, 7, 30};
        for (int i = 1, j = 0; i &lt;= m; ++i) {
            if (i == days[j]) {
                f[i] = INT_MAX;
                for (int k = 0; k &lt; 3; ++k) {
                    int c = costs[k], v = valid[k];
                    f[i] = min(f[i], f[max(0, i - v)] + c);
                }
                ++j;
            } else {
                f[i] = f[i - 1];
            }
        }
        return f[m];
    }
};
</code></pre>
<h4 id="go-3"><a class="header" href="#go-3">Go</a></h4>
<pre><code class="language-go">func mincostTickets(days []int, costs []int) int {
	m := days[len(days)-1]
	f := make([]int, m+1)
	valid := [3]int{1, 7, 30}
	for i, j := 1, 0; i &lt;= m; i++ {
		if i == days[j] {
			f[i] = 1 &lt;&lt; 30
			for k, v := range valid {
				c := costs[k]
				f[i] = min(f[i], f[max(0, i-v)]+c)
			}
			j++
		} else {
			f[i] = f[i-1]
		}
	}
	return f[m]
}
</code></pre>
<h4 id="typescript-3"><a class="header" href="#typescript-3">TypeScript</a></h4>
<pre><code class="language-ts">function mincostTickets(days: number[], costs: number[]): number {
    const m = days.at(-1)!;
    const f: number[] = Array(m).fill(0);
    const valid: number[] = [1, 7, 30];
    for (let i = 1, j = 0; i &lt;= m; ++i) {
        if (i === days[j]) {
            f[i] = Infinity;
            for (let k = 0; k &lt; 3; ++k) {
                const [c, v] = [costs[k], valid[k]];
                f[i] = Math.min(f[i], f[Math.max(0, i - v)] + c);
            }
            ++j;
        } else {
            f[i] = f[i - 1];
        }
    }
    return f[m];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class MinimumCostForTickets {

	// global variable, accessible from all methods
	public static int[] durations = { 1, 7, 30 };

	// 1. brute-force solution
	public static int mincostTickets1(int[] days, int[] costs) {
		return f1(days, costs, 0);
	}

	// compute the minimum cost starting from day i
	public static int f1(int[] days, int[] costs, int i) {
		if (i == days.length) {
			// no more trips
			return 0;
		}
		int ans = Integer.MAX_VALUE;
		for (int k = 0, j = i; k &lt; 3; k++) {
			while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
				j++; // Is the days[j] covered by the durations[k] ticket purchased at days[i]?
			}
			ans = Math.min(ans, costs[k] + f1(days, costs, j));
		}
		return ans;
	}

	// 2. recursion with memoization
	public static int mincostTickets2(int[] days, int[] costs) {
		int[] dp = new int[days.length];
		for (int i = 0; i &lt; days.length; i++) {
			dp[i] = Integer.MAX_VALUE;
		}
		return f2(days, costs, 0, dp);
	}

	// int[] dp is the memo table
	public static int f2(int[] days, int[] costs, int i, int[] dp) {
		if (i == days.length) {
			return 0;
		}
		if (dp[i] != Integer.MAX_VALUE) {
			return dp[i];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = 0, j = i; k &lt; 3; k++) {
			while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
				j++;
			}
			ans = Math.min(ans, costs[k] + f2(days, costs, j, dp));
		}
		dp[i] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int MAXN = 366;

	public static int[] dp = new int[MAXN];

	public static int mincostTickets3(int[] days, int[] costs) {
		int n = days.length;
		Arrays.fill(dp, 0, n + 1, Integer.MAX_VALUE);
		dp[n] = 0;
		for (int i = n - 1; i &gt;= 0; i--) {
			for (int k = 0, j = i; k &lt; 3; k++) {
				while (j &lt; days.length &amp;&amp; days[i] + durations[k] &gt; days[j]) {
					j++;
				}
				dp[i] = Math.min(dp[i], costs[k] + dp[j]);
			}
		}
		return dp[0];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=2053">
    </iframe>
</details>
<h2 id="decode-ways"><a class="header" href="#decode-ways">Decode Ways</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0000-0099/0091.Decode%20Ways/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="91-decode-ways"><a class="header" href="#91-decode-ways"><a href="https://leetcode.com/problems/decode-ways">91. Decode Ways</a></a></h1>
<p><a href="dynamic-programming//solution/0000-0099/0091.Decode%20Ways/README.html">中文文档</a></p>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<!-- description:start -->
<p>You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:</p>
<p><code>&quot;1&quot; -&gt; &#39;A&#39;<br />
&quot;2&quot; -&gt; &#39;B&#39;<br />
...<br />
&quot;25&quot; -&gt; &#39;Y&#39;<br />
&quot;26&quot; -&gt; &#39;Z&#39;</code></p>
<p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code>&quot;2&quot;</code> and <code>&quot;5&quot;</code> vs <code>&quot;25&quot;</code>).</p>
<p>For example, <code>&quot;11106&quot;</code> can be decoded into:</p>
<ul>
	<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1, 1, 10, 6)</code></li>
	<li><code>&quot;KJF&quot;</code> with the grouping <code>(11, 10, 6)</code></li>
	<li>The grouping <code>(1, 11, 06)</code> is invalid because <code>&quot;06&quot;</code> is not a valid code (only <code>&quot;6&quot;</code> is valid).</li>
</ul>
<p>Note: there may be strings that are impossible to decode.<br />
<br />
Given a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code>0</code>.</p>
<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;12&quot;</span></p>
<p><strong>Output:</strong> <span class="example-io">2</span></p>
<p><strong>Explanation:</strong></p>
<p>&quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>
</div>
<p><strong class="example">Example 2:</strong></p>
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;226&quot;</span></p>
<p><strong>Output:</strong> <span class="example-io">3</span></p>
<p><strong>Explanation:</strong></p>
<p>&quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</p>
</div>
<p><strong class="example">Example 3:</strong></p>
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;06&quot;</span></p>
<p><strong>Output:</strong> <span class="example-io">0</span></p>
<p><strong>Explanation:</strong></p>
<p>&quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;). In this case, the string is not a valid encoding, so return 0.</p>
</div>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> contains only digits and may contain leading zero(s).</li>
</ul>
<!-- description:end -->
<h2 id="solutions-2"><a class="header" href="#solutions-2">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming"><a class="header" href="#solution-1-dynamic-programming">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i]$ to represent the number of decoding methods for the first $i$ characters of the string. Initially, $f[0]=1$, and the rest $f[i]=0$.</p>
<p>Consider how $f[i]$ transitions.</p>
<ul>
<li>If the $i$th character (i.e., $s[i-1]$) forms a code on its own, it corresponds to one decoding method, i.e., $f[i]=f[i-1]$. The premise is $s[i-1] \neq 0$.</li>
<li>If the string formed by the $i-1$th character and the $i$th character is within the range $[1,26]$, then they can be treated as a whole, corresponding to one decoding method, i.e., $f[i] = f[i] + f[i-2]$. The premise is $s[i-2] \neq 0$, and $s[i-2]s[i-1]$ is within the range $[1,26]$.</li>
</ul>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p>
<!-- tabs:start -->
<h4 id="python3-4"><a class="header" href="#python3-4">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        n = len(s)
        f = [1] + [0] * n
        for i, c in enumerate(s, 1):
            if c != "0":
                f[i] = f[i - 1]
            if i &gt; 1 and s[i - 2] != "0" and int(s[i - 2 : i]) &lt;= 26:
                f[i] += f[i - 2]
        return f[n]
</code></pre>
<h4 id="java-4"><a class="header" href="#java-4">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            if (s.charAt(i - 1) != '0') {
                f[i] = f[i - 1];
            }
            if (i &gt; 1 &amp;&amp; s.charAt(i - 2) != '0' &amp;&amp; Integer.valueOf(s.substring(i - 2, i)) &lt;= 26) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
}
</code></pre>
<h4 id="c-4"><a class="header" href="#c-4">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        int f[n + 1];
        memset(f, 0, sizeof(f));
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            if (s[i - 1] != '0') {
                f[i] = f[i - 1];
            }
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6')) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
</code></pre>
<h4 id="go-4"><a class="header" href="#go-4">Go</a></h4>
<pre><code class="language-go">func numDecodings(s string) int {
	n := len(s)
	f := make([]int, n+1)
	f[0] = 1
	for i := 1; i &lt;= n; i++ {
		if s[i-1] != '0' {
			f[i] = f[i-1]
		}
		if i &gt; 1 &amp;&amp; (s[i-2] == '1' || (s[i-2] == '2' &amp;&amp; s[i-1] &lt;= '6')) {
			f[i] += f[i-2]
		}
	}
	return f[n]
}
</code></pre>
<h4 id="typescript-4"><a class="header" href="#typescript-4">TypeScript</a></h4>
<pre><code class="language-ts">function numDecodings(s: string): number {
    const n = s.length;
    const f: number[] = new Array(n + 1).fill(0);
    f[0] = 1;
    for (let i = 1; i &lt;= n; ++i) {
        if (s[i - 1] !== '0') {
            f[i] = f[i - 1];
        }
        if (i &gt; 1 &amp;&amp; (s[i - 2] === '1' || (s[i - 2] === '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
            f[i] += f[i - 2];
        }
    }
    return f[n];
}
</code></pre>
<h4 id="c-5"><a class="header" href="#c-5">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int NumDecodings(string s) {
        int n = s.Length;
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            if (s[i - 1] != '0') {
                f[i] = f[i - 1];
            }
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
}
</code></pre>
<!-- tabs:end -->
<p>We notice that the state $f[i]$ is only related to the states $f[i-1]$ and $f[i-2]$, and is irrelevant to other states. Therefore, we can use two variables to replace these two states, reducing the original space complexity from $O(n)$ to $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-5"><a class="header" href="#python3-5">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        f, g = 0, 1
        for i, c in enumerate(s, 1):
            h = g if c != "0" else 0
            if i &gt; 1 and s[i - 2] != "0" and int(s[i - 2 : i]) &lt;= 26:
                h += f
            f, g = g, h
        return g
</code></pre>
<h4 id="java-5"><a class="header" href="#java-5">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int f = 0, g = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int h = s.charAt(i - 1) != '0' ? g : 0;
            if (i &gt; 1 &amp;&amp; s.charAt(i - 2) != '0' &amp;&amp; Integer.valueOf(s.substring(i - 2, i)) &lt;= 26) {
                h += f;
            }
            f = g;
            g = h;
        }
        return g;
    }
}
</code></pre>
<h4 id="c-6"><a class="header" href="#c-6">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        int f = 0, g = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int h = s[i - 1] != '0' ? g : 0;
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
                h += f;
            }
            f = g;
            g = h;
        }
        return g;
    }
};
</code></pre>
<h4 id="go-5"><a class="header" href="#go-5">Go</a></h4>
<pre><code class="language-go">func numDecodings(s string) int {
	n := len(s)
	f, g := 0, 1
	for i := 1; i &lt;= n; i++ {
		h := 0
		if s[i-1] != '0' {
			h = g
		}
		if i &gt; 1 &amp;&amp; (s[i-2] == '1' || (s[i-2] == '2' &amp;&amp; s[i-1] &lt;= '6')) {
			h += f
		}
		f, g = g, h
	}
	return g
}
</code></pre>
<h4 id="typescript-5"><a class="header" href="#typescript-5">TypeScript</a></h4>
<pre><code class="language-ts">function numDecodings(s: string): number {
    const n = s.length;
    let [f, g] = [0, 1];
    for (let i = 1; i &lt;= n; ++i) {
        let h = s[i - 1] !== '0' ? g : 0;
        if (i &gt; 1 &amp;&amp; (s[i - 2] === '1' || (s[i - 2] === '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
            h += f;
        }
        [f, g] = [g, h];
    }
    return g;
}
</code></pre>
<h4 id="c-7"><a class="header" href="#c-7">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int NumDecodings(string s) {
        int n = s.Length;
        int f = 0, g = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int h = s[i - 1] != '0' ? g : 0;
            if (i &gt; 1 &amp;&amp; (s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6'))) {
                h += f;
            }
            f = g;
            g = h;
        }
        return g;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class DecodeWays {

	// 1. Recursive brute-force solution
	public static int numDecodings1(String s) {
		return f1(s.toCharArray(), 0);
	}

	// compute decoding ways for substring s[i..]
	public static int f1(char[] s, int i) {
		if (i == s.length) {
			return 1;
		}
		int ans;
		if (s[i] == '0') {
			ans = 0;
		} else {
			ans = f1(s, i + 1);
			if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
				ans += f1(s, i + 2);
			}
		}
		return ans;
	}

	// 2. recursive solution with memoization
	public static int numDecodings2(String s) {
		int[] dp = new int[s.length()];
		Arrays.fill(dp, -1);
		return f2(s.toCharArray(), 0, dp);
	}

	public static int f2(char[] s, int i, int[] dp) {
		if (i == s.length) {
			return 1;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		int ans;
		if (s[i] == '0') {
			ans = 0;
		} else {
			ans = f2(s, i + 1, dp);
			if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
				ans += f2(s, i + 2, dp);
			}
		}
		dp[i] = ans;
		return ans;
	}

	// 3. bottom-up iterative solution
	public static int numDecodings3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[] dp = new int[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') {
				dp[i] = 0;
			} else {
				dp[i] = dp[i + 1];
				if (i + 1 &lt; s.length &amp;&amp; ((s[i] - '0') * 10 + s[i + 1] - '0') &lt;= 26) {
					dp[i] += dp[i + 2];
				}
			}
		}
		return dp[0];
	}

	// 4. iterative solution + space optimization
	public static int numDecodings4(String s) {
		// dp[i+1]
		int next = 1;
		// dp[i+2]
		int nextNext = 0;
		for (int i = s.length() - 1, cur; i &gt;= 0; i--) {
			if (s.charAt(i) == '0') {
				cur = 0;
			} else {
				cur = next;
				if (i + 1 &lt; s.length() &amp;&amp; ((s.charAt(i) - '0') * 10 + s.charAt(i + 1) - '0') &lt;= 26) {
					cur += nextNext;
				}
			}
			nextNext = next;
			next = cur;
		}
		return next;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=4249">
    </iframe>
</details>
<h2 id="decode-ways-ii"><a class="header" href="#decode-ways-ii">Decode Ways II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0600-0699/0639.Decode%20Ways%20II/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="639-decode-ways-ii"><a class="header" href="#639-decode-ways-ii"><a href="https://leetcode.com/problems/decode-ways-ii">639. Decode Ways II</a></a></h1>
<p><a href="dynamic-programming//solution/0600-0699/0639.Decode%20Ways%20II/README.html">中文文档</a></p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<!-- description:start -->
<p>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p>
<pre>
&#39;A&#39; -&gt; &quot;1&quot;
&#39;B&#39; -&gt; &quot;2&quot;
...
&#39;Z&#39; -&gt; &quot;26&quot;
</pre>
<p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p>
<ul>
	<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li>
	<li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li>
</ul>
<p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p>
<p><strong>In addition</strong> to the mapping above, an encoded message may contain the <code>&#39;*&#39;</code> character, which can represent any digit from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code> (<code>&#39;0&#39;</code> is excluded). For example, the encoded message <code>&quot;1*&quot;</code> may represent any of the encoded messages <code>&quot;11&quot;</code>, <code>&quot;12&quot;</code>, <code>&quot;13&quot;</code>, <code>&quot;14&quot;</code>, <code>&quot;15&quot;</code>, <code>&quot;16&quot;</code>, <code>&quot;17&quot;</code>, <code>&quot;18&quot;</code>, or <code>&quot;19&quot;</code>. Decoding <code>&quot;1*&quot;</code> is equivalent to decoding <strong>any</strong> of the encoded messages it can represent.</p>
<p>Given a string <code>s</code> consisting of digits and <code>&#39;*&#39;</code> characters, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p>
<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;*&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, or &quot;9&quot;.
Each of these can be decoded to the strings &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, and &quot;I&quot; respectively.
Hence, there are a total of 9 ways to decode &quot;*&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;1*&quot;
<strong>Output:</strong> 18
<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, or &quot;19&quot;.
Each of these encoded messages have 2 ways to be decoded (e.g. &quot;11&quot; can be decoded to &quot;AA&quot; or &quot;K&quot;).
Hence, there are a total of 9 * 2 = 18 ways to decode &quot;1*&quot;.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;2*&quot;
<strong>Output:</strong> 15
<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, or &quot;29&quot;.
&quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, and &quot;26&quot; have 2 ways of being decoded, but &quot;27&quot;, &quot;28&quot;, and &quot;29&quot; only have 1 way.
Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode &quot;2*&quot;.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is a digit or <code>&#39;*&#39;</code>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-3"><a class="header" href="#solutions-3">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1"><a class="header" href="#solution-1">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-6"><a class="header" href="#python3-6">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        mod = int(1e9 + 7)
        n = len(s)

        # dp[i - 2], dp[i - 1], dp[i]
        a, b, c = 0, 1, 0
        for i in range(1, n + 1):
            # 1 digit
            if s[i - 1] == "*":
                c = 9 * b % mod
            elif s[i - 1] != "0":
                c = b
            else:
                c = 0

            # 2 digits
            if i &gt; 1:
                if s[i - 2] == "*" and s[i - 1] == "*":
                    c = (c + 15 * a) % mod
                elif s[i - 2] == "*":
                    if s[i - 1] &gt; "6":
                        c = (c + a) % mod
                    else:
                        c = (c + 2 * a) % mod
                elif s[i - 1] == "*":
                    if s[i - 2] == "1":
                        c = (c + 9 * a) % mod
                    elif s[i - 2] == "2":
                        c = (c + 6 * a) % mod
                elif (
                    s[i - 2] != "0"
                    and (ord(s[i - 2]) - ord("0")) * 10 + ord(s[i - 1]) - ord("0") &lt;= 26
                ):
                    c = (c + a) % mod

            a, b = b, c

        return c
</code></pre>
<h4 id="java-6"><a class="header" href="#java-6">Java</a></h4>
<pre><code class="language-java">class Solution {

    private static final int MOD = 1000000007;

    public int numDecodings(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();

        // dp[i - 2], dp[i - 1], dp[i]
        long a = 0, b = 1, c = 0;
        for (int i = 1; i &lt;= n; i++) {
            // 1 digit
            if (cs[i - 1] == '*') {
                c = 9 * b % MOD;
            } else if (cs[i - 1] != '0') {
                c = b;
            } else {
                c = 0;
            }

            // 2 digits
            if (i &gt; 1) {
                if (cs[i - 2] == '*' &amp;&amp; cs[i - 1] == '*') {
                    c = (c + 15 * a) % MOD;
                } else if (cs[i - 2] == '*') {
                    if (cs[i - 1] &gt; '6') {
                        c = (c + a) % MOD;
                    } else {
                        c = (c + 2 * a) % MOD;
                    }
                } else if (cs[i - 1] == '*') {
                    if (cs[i - 2] == '1') {
                        c = (c + 9 * a) % MOD;
                    } else if (cs[i - 2] == '2') {
                        c = (c + 6 * a) % MOD;
                    }
                } else if (cs[i - 2] != '0' &amp;&amp; (cs[i - 2] - '0') * 10 + cs[i - 1] - '0' &lt;= 26) {
                    c = (c + a) % MOD;
                }
            }

            a = b;
            b = c;
        }

        return (int) c;
    }
}
</code></pre>
<h4 id="go-6"><a class="header" href="#go-6">Go</a></h4>
<pre><code class="language-go">const mod int = 1e9 + 7

func numDecodings(s string) int {
	n := len(s)

	// dp[i - 2], dp[i - 1], dp[i]
	a, b, c := 0, 1, 0
	for i := 1; i &lt;= n; i++ {
		// 1 digit
		if s[i-1] == '*' {
			c = 9 * b % mod
		} else if s[i-1] != '0' {
			c = b
		} else {
			c = 0
		}

		// 2 digits
		if i &gt; 1 {
			if s[i-2] == '*' &amp;&amp; s[i-1] == '*' {
				c = (c + 15*a) % mod
			} else if s[i-2] == '*' {
				if s[i-1] &gt; '6' {
					c = (c + a) % mod
				} else {
					c = (c + 2*a) % mod
				}
			} else if s[i-1] == '*' {
				if s[i-2] == '1' {
					c = (c + 9*a) % mod
				} else if s[i-2] == '2' {
					c = (c + 6*a) % mod
				}
			} else if s[i-2] != '0' &amp;&amp; (s[i-2]-'0')*10+s[i-1]-'0' &lt;= 26 {
				c = (c + a) % mod
			}
		}

		a, b = b, c
	}
	return c
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

public class DecodeWaysII {

	// 1. brute-force solution without modulus (incorrect answer)
	public static int numDecodings1(String str) {
		return f1(str.toCharArray(), 0);
	}

	// compute decode ways for substring s[i..]
	public static int f1(char[] s, int i) {
		if (i == s.length) {
			return 1;
		}
		if (s[i] == '0') {
			return 0;
		}
		// s[i] != '0'
		// decode s[i] only
		int ans = f1(s, i + 1) * (s[i] == '*' ? 9 : 1);
		// decode s[i] and s[i+1] combined
		if (i + 1 &lt; s.length) { // s[i+1] exists
			if (s[i] != '*' &amp;&amp; s[i+1] != '*') { // case 1: digit + digit
				if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
					ans += f1(s, i + 2);
				}
			} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') { // case 2: digit + '*'
				if (s[i] == '1') {
					ans += f1(s, i + 2) * 9;
				}
				if (s[i] == '2') {
					ans += f1(s, i + 2) * 6;
				}
			} else if (s[i] == '*' &amp;&amp; s[i+1] != '*') { // case 3: '*' + digit
				if (s[i + 1] &lt;= '6') {
					ans += f1(s, i + 2) * 2;
				} else {
					ans += f1(s, i + 2);
				}
			} else { // case 4: '*' + '*'
				ans += f1(s, i + 2) * 15;
			}
		}
		return ans;
	}

	// 2. recursive solution with memoization, answer modulo 10^9+7
	public static long mod = 1000000007;

	public static int numDecodings2(String str) {
		char[] s = str.toCharArray();
		long[] dp = new long[s.length];
		Arrays.fill(dp, -1);
		return (int) f2(s, 0, dp);
	}

	public static long f2(char[] s, int i, long[] dp) {
		if (i == s.length) {
			return 1;
		}
		if (s[i] == '0') {
			return 0;
		}
		if (dp[i] != -1) {
			return dp[i];
		}
		long ans = f2(s, i + 1, dp) * (s[i] == '*' ? 9 : 1); // decode s[i] only
		if (i + 1 &lt; s.length) { // decode s[i] and s[i+1] together
			if (s[i] != '*' &amp;&amp; s[i+1] != '*') {
				if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
					ans += f2(s, i + 2, dp);
				}
			} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') {
				if (s[i] == '1') {
					ans += f2(s, i + 2, dp) * 9;
				}
				if (s[i] == '2') {
					ans += f2(s, i + 2, dp) * 6;
				}
			} else if (s[i] == '*' &amp;&amp; s[i + 1] != '*') {
				if (s[i + 1] &lt;= '6') {
					ans += f2(s, i + 2, dp) * 2;
				} else {
					ans += f2(s, i + 2, dp);
				}
			} else {
				ans += f2(s, i + 2, dp) * 15;
			}
		}
		ans %= mod;
		dp[i] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int numDecodings3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		long[] dp = new long[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') continue;
			dp[i] = (s[i] == '*' ? 9 : 1) * dp[i + 1];
			if (i + 1 &lt; n) {
				if (s[i] != '*' &amp;&amp; s[i + 1] != '*') {
					if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
						dp[i] += dp[i + 2];
					}
				} else if (s[i] != '*' &amp;&amp; s[i + 1] == '*') {
					if (s[i] == '1') {
						dp[i] += dp[i + 2] * 9;
					}
					if (s[i] == '2') {
						dp[i] += dp[i + 2] * 6;
					}
				} else if (s[i] == '*' &amp;&amp; s[i + 1] != '*') {
					if (s[i + 1] &lt;= '6') {
						dp[i] += dp[i + 2] * 2;
					} else {
						dp[i] += dp[i + 2];
					}
				} else {
					dp[i] += dp[i + 2] * 15;
				}
			}
			dp[i] %= mod;
		}
		return (int) dp[0];
	}

	// 4. iterative solution with space optimization
	public static int numDecodings4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		long cur = 0, next = 1, nextNext = 0;
		for (int i = n - 1; i &gt;= 0; i--) {
			if (s[i] == '0') continue;
			cur = (s[i] == '*' ? 9 : 1) * next;
			if (i + 1 &lt; n) {
				if (s[i] != '*' &amp;&amp; s[i+1] != '*') {
					if ((s[i] - '0') * 10 + s[i + 1] - '0' &lt;= 26) {
						cur += nextNext;
					}
				} else if (s[i] != '*' &amp;&amp; s[i+1] == '*') {
					if (s[i] == '1') {
						cur += nextNext * 9;
					}
					if (s[i] == '2') {
						cur += nextNext * 6;
					}
				} else if (s[i] == '*' &amp;&amp; s[i+1] != '*') {
					if (s[i + 1] &lt;= '6') {
						cur += nextNext * 2;
					} else {
						cur += nextNext;
					}
				} else {
					cur += nextNext * 15;
				}
			}
			cur %= mod;
			nextNext = next;
			next = cur;
			cur = 0;
		}
		return (int) next;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=5985">
    </iframe>
</details>
<h2 id="ugly-number-ii"><a class="header" href="#ugly-number-ii">Ugly Number II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0264.Ugly%20Number%20II/README_EN.md
tags:
    - Hash Table
    - Math
    - Dynamic Programming
    - Heap (Priority Queue)
</code></pre>
<!-- problem:start -->
<h1 id="264-ugly-number-ii"><a class="header" href="#264-ugly-number-ii"><a href="https://leetcode.com/problems/ugly-number-ii">264. Ugly Number II</a></a></h1>
<p><a href="dynamic-programming//solution/0200-0299/0264.Ugly%20Number%20II/README.html">中文文档</a></p>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<!-- description:start -->
<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>
<p>Given an integer <code>n</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>ugly number</strong></em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 12
<strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= n &lt;= 1690</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-4"><a class="header" href="#solutions-4">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-1"><a class="header" href="#solution-1-1">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-7"><a class="header" href="#python3-7">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        h = [1]
        vis = {1}
        ans = 1
        for _ in range(n):
            ans = heappop(h)
            for v in [2, 3, 5]:
                nxt = ans * v
                if nxt not in vis:
                    vis.add(nxt)
                    heappush(h, nxt)
        return ans
</code></pre>
<h4 id="java-7"><a class="header" href="#java-7">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int nthUglyNumber(int n) {
        Set&lt;Long&gt; vis = new HashSet&lt;&gt;();
        PriorityQueue&lt;Long&gt; q = new PriorityQueue&lt;&gt;();
        int[] f = new int[] {2, 3, 5};
        q.offer(1L);
        vis.add(1L);
        long ans = 0;
        while (n-- &gt; 0) {
            ans = q.poll();
            for (int v : f) {
                long next = ans * v;
                if (vis.add(next)) {
                    q.offer(next);
                }
            }
        }
        return (int) ans;
    }
}
</code></pre>
<h4 id="c-8"><a class="header" href="#c-8">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; q;
        q.push(1l);
        unordered_set&lt;long&gt; vis{{1l}};
        long ans = 1;
        vector&lt;int&gt; f = {2, 3, 5};
        while (n--) {
            ans = q.top();
            q.pop();
            for (int&amp; v : f) {
                long nxt = ans * v;
                if (!vis.count(nxt)) {
                    vis.insert(nxt);
                    q.push(nxt);
                }
            }
        }
        return (int) ans;
    }
};
</code></pre>
<h4 id="go-7"><a class="header" href="#go-7">Go</a></h4>
<pre><code class="language-go">func nthUglyNumber(n int) int {
	h := IntHeap([]int{1})
	heap.Init(&amp;h)
	ans := 1
	vis := map[int]bool{1: true}
	for n &gt; 0 {
		ans = heap.Pop(&amp;h).(int)
		for _, v := range []int{2, 3, 5} {
			nxt := ans * v
			if !vis[nxt] {
				vis[nxt] = true
				heap.Push(&amp;h, nxt)
			}
		}
		n--
	}
	return ans
}

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *IntHeap) Push(x any) {
	*h = append(*h, x.(int))
}
func (h *IntHeap) Pop() any {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}
</code></pre>
<h4 id="javascript-2"><a class="header" href="#javascript-2">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function (n) {
    let dp = [1];
    let p2 = 0,
        p3 = 0,
        p5 = 0;
    for (let i = 1; i &lt; n; ++i) {
        const next2 = dp[p2] * 2,
            next3 = dp[p3] * 3,
            next5 = dp[p5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        if (dp[i] == next2) ++p2;
        if (dp[i] == next3) ++p3;
        if (dp[i] == next5) ++p5;
        dp.push(dp[i]);
    }
    return dp[n - 1];
};
</code></pre>
<h4 id="c-9"><a class="header" href="#c-9">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int NthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i &lt; n; ++i) {
            int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
            dp[i] = Math.Min(next2, Math.Min(next3, next5));
            if (dp[i] == next2) {
                ++p2;
            }
            if (dp[i] == next3) {
                ++p3;
            }
            if (dp[i] == next5) {
                ++p5;
            }
        }
        return dp[n - 1];
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2"><a class="header" href="#solution-2">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-8"><a class="header" href="#python3-8">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp = [1] * n
        p2 = p3 = p5 = 0
        for i in range(1, n):
            next2, next3, next5 = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
            dp[i] = min(next2, next3, next5)
            if dp[i] == next2:
                p2 += 1
            if dp[i] == next3:
                p3 += 1
            if dp[i] == next5:
                p5 += 1
        return dp[-1]
</code></pre>
<h4 id="java-8"><a class="header" href="#java-8">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i &lt; n; ++i) {
            int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
            dp[i] = Math.min(next2, Math.min(next3, next5));
            if (dp[i] == next2) ++p2;
            if (dp[i] == next3) ++p3;
            if (dp[i] == next5) ++p5;
        }
        return dp[n - 1];
    }
}
</code></pre>
<h4 id="c-10"><a class="header" href="#c-10">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int nthUglyNumber(int n) {
        vector&lt;int&gt; dp(n);
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i &lt; n; ++i) {
            int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
            dp[i] = min(next2, min(next3, next5));
            if (dp[i] == next2) ++p2;
            if (dp[i] == next3) ++p3;
            if (dp[i] == next5) ++p5;
        }
        return dp[n - 1];
    }
};
</code></pre>
<h4 id="go-8"><a class="header" href="#go-8">Go</a></h4>
<pre><code class="language-go">func nthUglyNumber(n int) int {
	dp := make([]int, n)
	dp[0] = 1
	p2, p3, p5 := 0, 0, 0
	for i := 1; i &lt; n; i++ {
		next2, next3, next5 := dp[p2]*2, dp[p3]*3, dp[p5]*5
		dp[i] = min(next2, min(next3, next5))
		if dp[i] == next2 {
			p2++
		}
		if dp[i] == next3 {
			p3++
		}
		if dp[i] == next5 {
			p5++
		}
	}
	return dp[n-1]
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class UglyNumberII {

	public static int nthUglyNumber(int n) {
		int[] dp = new int[n + 1];
		dp[1] = 1;
		int i2 = 1, i3 = 1, i5 = 1, a, b, c, cur;
		for (int i = 2; i &lt;= n; i++) {
			a = dp[i2] * 2;
			b = dp[i3] * 3;
			c = dp[i5] * 5;
			cur = Math.min(Math.min(a, b), c);
			if (cur == a) {
				i2++;
			}
			if (cur == b) {
				i3++;
			}
			if (cur == c) {
				i5++;
			}
			dp[i] = cur;
		}
		return dp[n];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=7739">
    </iframe>
</details>
<h2 id="longest-valid-parentheses"><a class="header" href="#longest-valid-parentheses">Longest Valid Parentheses</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0000-0099/0032.Longest%20Valid%20Parentheses/README_EN.md
tags:
    - Stack
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="32-longest-valid-parentheses"><a class="header" href="#32-longest-valid-parentheses"><a href="https://leetcode.com/problems/longest-valid-parentheses">32. Longest Valid Parentheses</a></a></h1>
<p><a href="dynamic-programming//solution/0000-0099/0032.Longest%20Valid%20Parentheses/README.html">中文文档</a></p>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<!-- description:start -->
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, return <em>the length of the longest valid (well-formed) parentheses </em><span data-keyword="substring-nonempty"><em>substring</em></span>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;(()&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;)()())&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()()&quot;.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;&quot;
<strong>Output:</strong> 0
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>s[i]</code> is <code>&#39;(&#39;</code>, or <code>&#39;)&#39;</code>.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-5"><a class="header" href="#solutions-5">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-1"><a class="header" href="#solution-1-dynamic-programming-1">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i]$ to be the length of the longest valid parentheses that ends with $s[i-1]$, and the answer is $max(f[i])$.</p>
<p>When $i \lt 2$, the length of the string is less than $2$, and there is no valid parentheses, so $f[i] = 0$.</p>
<p>When $i \ge 2$, we consider the length of the longest valid parentheses that ends with $s[i-1]$, that is, $f[i]$:</p>
<ul>
<li>If $s[i-1]$ is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ must be $0$, so $f[i] = 0$.</li>
<li>If $s[i-1]$ is a right parenthesis, there are the following two cases:
<ul>
<li>If $s[i-2]$ is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-2] + 2$.</li>
<li>If $s[i-2]$ is a right parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-1] + 2$, but we also need to consider whether $s[i-f[i-1]-2]$ is a left parenthesis. If it is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-1] + 2 + f[i-f[i-1]-2]$.</li>
</ul>
</li>
</ul>
<p>Therefore, we can get the state transition equation:</p>
<p>$$
\begin{cases}
f[i] = 0, &amp; \textit{if } s[i-1] = '(',\
f[i] = f[i-2] + 2, &amp; \textit{if } s[i-1] = ')' \textit{ and } s[i-2] = '(',\
f[i] = f[i-1] + 2 + f[i-f[i-1]-2], &amp; \textit{if } s[i-1] = ')' \textit{ and } s[i-2] = ')' \textit{ and } s[i-f[i-1]-2] = '(',\
\end{cases}
$$</p>
<p>Finally, we only need to return $max(f)$.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string.</p>
<!-- tabs:start -->
<h4 id="python3-9"><a class="header" href="#python3-9">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        n = len(s)
        f = [0] * (n + 1)
        for i, c in enumerate(s, 1):
            if c == ")":
                if i &gt; 1 and s[i - 2] == "(":
                    f[i] = f[i - 2] + 2
                else:
                    j = i - f[i - 1] - 1
                    if j and s[j - 1] == "(":
                        f[i] = f[i - 1] + 2 + f[j - 1]
        return max(f)
</code></pre>
<h4 id="java-9"><a class="header" href="#java-9">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        int ans = 0;
        for (int i = 2; i &lt;= n; ++i) {
            if (s.charAt(i - 1) == ')') {
                if (s.charAt(i - 2) == '(') {
                    f[i] = f[i - 2] + 2;
                } else {
                    int j = i - f[i - 1] - 1;
                    if (j &gt; 0 &amp;&amp; s.charAt(j - 1) == '(') {
                        f[i] = f[i - 1] + 2 + f[j - 1];
                    }
                }
                ans = Math.max(ans, f[i]);
            }
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-11"><a class="header" href="#c-11">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        int f[n + 1];
        memset(f, 0, sizeof(f));
        for (int i = 2; i &lt;= n; ++i) {
            if (s[i - 1] == ')') {
                if (s[i - 2] == '(') {
                    f[i] = f[i - 2] + 2;
                } else {
                    int j = i - f[i - 1] - 1;
                    if (j &amp;&amp; s[j - 1] == '(') {
                        f[i] = f[i - 1] + 2 + f[j - 1];
                    }
                }
            }
        }
        return *max_element(f, f + n + 1);
    }
};
</code></pre>
<h4 id="go-9"><a class="header" href="#go-9">Go</a></h4>
<pre><code class="language-go">func longestValidParentheses(s string) int {
	n := len(s)
	f := make([]int, n+1)
	for i := 2; i &lt;= n; i++ {
		if s[i-1] == ')' {
			if s[i-2] == '(' {
				f[i] = f[i-2] + 2
			} else if j := i - f[i-1] - 1; j &gt; 0 &amp;&amp; s[j-1] == '(' {
				f[i] = f[i-1] + 2 + f[j-1]
			}
		}
	}
	return slices.Max(f)
}
</code></pre>
<h4 id="typescript-6"><a class="header" href="#typescript-6">TypeScript</a></h4>
<pre><code class="language-ts">function longestValidParentheses(s: string): number {
    const n = s.length;
    const f: number[] = new Array(n + 1).fill(0);
    for (let i = 2; i &lt;= n; ++i) {
        if (s[i - 1] === ')') {
            if (s[i - 2] === '(') {
                f[i] = f[i - 2] + 2;
            } else {
                const j = i - f[i - 1] - 1;
                if (j &amp;&amp; s[j - 1] === '(') {
                    f[i] = f[i - 1] + 2 + f[j - 1];
                }
            }
        }
    }
    return Math.max(...f);
}
</code></pre>
<h4 id="rust-2"><a class="header" href="#rust-2">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn longest_valid_parentheses(s: String) -&gt; i32 {
        let mut ans = 0;
        let mut f = vec![0; s.len() + 1];
        for i in 2..=s.len() {
            if s.chars().nth(i - 1).unwrap() == ')' {
                if s.chars().nth(i - 2).unwrap() == '(' {
                    f[i] = f[i - 2] + 2;
                } else if (i as i32) - f[i - 1] - 1 &gt; 0
                    &amp;&amp; s.chars().nth(i - (f[i - 1] as usize) - 2).unwrap() == '('
                {
                    f[i] = f[i - 1] + 2 + f[i - (f[i - 1] as usize) - 2];
                }
                ans = ans.max(f[i]);
            }
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-3"><a class="header" href="#javascript-3">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function (s) {
    const n = s.length;
    const f = new Array(n + 1).fill(0);
    for (let i = 2; i &lt;= n; ++i) {
        if (s[i - 1] === ')') {
            if (s[i - 2] === '(') {
                f[i] = f[i - 2] + 2;
            } else {
                const j = i - f[i - 1] - 1;
                if (j &amp;&amp; s[j - 1] === '(') {
                    f[i] = f[i - 1] + 2 + f[j - 1];
                }
            }
        }
    }
    return Math.max(...f);
};
</code></pre>
<h4 id="c-12"><a class="header" href="#c-12">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int LongestValidParentheses(string s) {
        int n = s.Length;
        int[] f = new int[n + 1];
        int ans = 0;
        for (int i = 2; i &lt;= n; ++i) {
            if (s[i - 1] == ')') {
                if (s[i - 2] == '(') {
                    f[i] = f[i - 2] + 2;
                } else {
                    int j = i - f[i - 1] - 1;
                    if (j &gt; 0 &amp;&amp; s[j - 1] == '(') {
                        f[i] = f[i - 1] + 2 + f[j - 1];
                    }
                }
                ans = Math.Max(ans, f[i]);
            }
        }
        return ans;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-using-stack"><a class="header" href="#solution-2-using-stack">Solution 2: Using Stack</a></h3>
<ul>
<li>Maintain a stack to store the indices of left parentheses. Initialize the bottom element of the stack with the value -1 to facilitate the calculation of the length of valid parentheses.</li>
<li>Iterate through each element of the string:
<ul>
<li>If the character is a left parenthesis, push the index of the character onto the stack.</li>
<li>If the character is a right parenthesis, pop an element from the stack to represent that we have found a valid pair of parentheses.
<ul>
<li>If the stack is empty, it means we couldn't find a left parenthesis to match the right parenthesis. In this case, push the index of the character as a new starting point.</li>
<li>If the stack is not empty, calculate the length of the valid parentheses and update it.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Summary:</p>
<p>The key to this algorithm is to maintain a stack to store the indices of left parentheses and then update the length of the valid substring of parentheses by pushing and popping elements.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string.</p>
<!-- tabs:start -->
<h4 id="python3-10"><a class="header" href="#python3-10">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        stack = [-1]
        ans = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    ans = max(ans, i - stack[-1])
        return ans
</code></pre>
<h4 id="go-10"><a class="header" href="#go-10">Go</a></h4>
<pre><code class="language-go">func longestValidParentheses(s string) int {
	ans := 0
	stack := []int{-1}
	for i, v := range s {
		if v == '(' {
			stack = append(stack, i)
		} else {
			stack = stack[:len(stack)-1]
			if len(stack) == 0 {
				stack = append(stack, i)
			} else {
				if ans &lt; i-stack[len(stack)-1] {
					ans = i - stack[len(stack)-1]
				}
			}
		}
	}
	return ans
}
</code></pre>
<h4 id="typescript-7"><a class="header" href="#typescript-7">TypeScript</a></h4>
<pre><code class="language-ts">function longestValidParentheses(s: string): number {
    let max_length: number = 0;
    const stack: number[] = [-1];
    for (let i = 0; i &lt; s.length; i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            stack.pop();

            if (stack.length === 0) {
                stack.push(i);
            } else {
                max_length = Math.max(max_length, i - stack[stack.length - 1]);
            }
        }
    }

    return max_length;
}
</code></pre>
<h4 id="rust-3"><a class="header" href="#rust-3">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn longest_valid_parentheses(s: String) -&gt; i32 {
        let mut stack = vec![-1];
        let mut res = 0;
        for i in 0..s.len() {
            if let Some('(') = s.chars().nth(i) {
                stack.push(i as i32);
            } else {
                stack.pop().unwrap();
                if stack.is_empty() {
                    stack.push(i as i32);
                } else {
                    res = std::cmp::max(res, (i as i32) - stack.last().unwrap());
                }
            }
        }
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-4"><a class="header" href="#javascript-4">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function (s) {
    let ans = 0;
    const stack = [-1];
    for (i = 0; i &lt; s.length; i++) {
        if (s.charAt(i) === '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.length === 0) {
                stack.push(i);
            } else {
                ans = Math.max(ans, i - stack[stack.length - 1]);
            }
        }
    }
    return ans;
};
</code></pre>
<h4 id="php-1"><a class="header" href="#php-1">PHP</a></h4>
<pre><code class="language-php">class Solution {
    /**
     * @param string $s
     * @return integer
     */

    function longestValidParentheses($s) {
        $stack = [];
        $maxLength = 0;

        array_push($stack, -1);
        for ($i = 0; $i &lt; strlen($s); $i++) {
            if ($s[$i] === '(') {
                array_push($stack, $i);
            } else {
                array_pop($stack);

                if (empty($stack)) {
                    array_push($stack, $i);
                } else {
                    $length = $i - end($stack);
                    $maxLength = max($maxLength, $length);
                }
            }
        }
        return $maxLength;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class LongestValidParentheses {

	public static int longestValidParentheses(String str) {
		char[] s = str.toCharArray();
		// dp[i] : the longest valid parentheses for substring ending at i 
		int[] dp = new int[s.length];
		int ans = 0, p;
		for (int i = 1; i &lt; s.length; i++) {
			if (s[i] == ')') {
				p = i - dp[i - 1] - 1;  // position of the matching left parenthese
				if (p &gt;= 0 &amp;&amp; s[p] == '(') {  // found matching left parenthese
					dp[i] = dp[i - 1] + 2 + (p - 1 &gt;= 0 ? dp[p - 1] : 0);
				}
			}
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=8666">
    </iframe>
</details>
<h2 id="unique-substring-in-wraparound-string"><a class="header" href="#unique-substring-in-wraparound-string">Unique Substring in Wraparound String</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0400-0499/0467.Unique%20Substrings%20in%20Wraparound%20String/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="467-unique-substrings-in-wraparound-string"><a class="header" href="#467-unique-substrings-in-wraparound-string"><a href="https://leetcode.com/problems/unique-substrings-in-wraparound-string">467. Unique Substrings in Wraparound String</a></a></h1>
<p><a href="dynamic-programming//solution/0400-0499/0467.Unique%20Substrings%20in%20Wraparound%20String/README.html">中文文档</a></p>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<!-- description:start -->
<p>We define the string <code>base</code> to be the infinite wraparound string of <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, so <code>base</code> will look like this:</p>
<ul>
	<li><code>&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;</code>.</li>
</ul>
<p>Given a string <code>s</code>, return <em>the number of <strong>unique non-empty substrings</strong> of </em><code>s</code><em> are present in </em><code>base</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;a&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> Only the substring &quot;a&quot; of s is in base.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;cac&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two substrings (&quot;a&quot;, &quot;c&quot;) of s in base.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;zab&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are six substrings (&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, and &quot;zab&quot;) of s in base.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-6"><a class="header" href="#solutions-6">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-2"><a class="header" href="#solution-1-dynamic-programming-2">Solution 1: Dynamic Programming</a></h3>
<p>We can define an array $f$ of length $26$, where $f[i]$ represents the length of the longest consecutive substring ending with the $i$th character. The answer is the sum of all elements in $f$.</p>
<p>We define a variable $k$ to represent the length of the longest consecutive substring ending with the current character. We iterate through the string $s$. For each character $c$, if the difference between $c$ and the previous character $s[i - 1]$ is $1$, then we increment $k$ by $1$, otherwise, we reset $k$ to $1$. Then we update $f[c]$ to be the larger value of $f[c]$ and $k$.</p>
<p>Finally, we return the sum of all elements in $f$.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(|\Sigma|)$, where $\Sigma$ is the character set, in this case, the set of lowercase letters.</p>
<!-- tabs:start -->
<h4 id="python3-11"><a class="header" href="#python3-11">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def findSubstringInWraproundString(self, s: str) -&gt; int:
        f = defaultdict(int)
        k = 0
        for i, c in enumerate(s):
            if i and (ord(c) - ord(s[i - 1])) % 26 == 1:
                k += 1
            else:
                k = 1
            f[c] = max(f[c], k)
        return sum(f.values())
</code></pre>
<h4 id="java-10"><a class="header" href="#java-10">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int findSubstringInWraproundString(String s) {
        int[] f = new int[26];
        int n = s.length();
        for (int i = 0, k = 0; i &lt; n; ++i) {
            if (i &gt; 0 &amp;&amp; (s.charAt(i) - s.charAt(i - 1) + 26) % 26 == 1) {
                ++k;
            } else {
                k = 1;
            }
            f[s.charAt(i) - 'a'] = Math.max(f[s.charAt(i) - 'a'], k);
        }
        return Arrays.stream(f).sum();
    }
}
</code></pre>
<h4 id="c-13"><a class="header" href="#c-13">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int findSubstringInWraproundString(string s) {
        int f[26]{};
        int n = s.length();
        for (int i = 0, k = 0; i &lt; n; ++i) {
            if (i &amp;&amp; (s[i] - s[i - 1] + 26) % 26 == 1) {
                ++k;
            } else {
                k = 1;
            }
            f[s[i] - 'a'] = max(f[s[i] - 'a'], k);
        }
        return accumulate(begin(f), end(f), 0);
    }
};
</code></pre>
<h4 id="go-11"><a class="header" href="#go-11">Go</a></h4>
<pre><code class="language-go">func findSubstringInWraproundString(s string) (ans int) {
	f := [26]int{}
	k := 0
	for i := range s {
		if i &gt; 0 &amp;&amp; (s[i]-s[i-1]+26)%26 == 1 {
			k++
		} else {
			k = 1
		}
		f[s[i]-'a'] = max(f[s[i]-'a'], k)
	}
	for _, x := range f {
		ans += x
	}
	return
}
</code></pre>
<h4 id="typescript-8"><a class="header" href="#typescript-8">TypeScript</a></h4>
<pre><code class="language-ts">function findSubstringInWraproundString(s: string): number {
    const idx = (c: string): number =&gt; c.charCodeAt(0) - 97;
    const f: number[] = Array(26).fill(0);
    const n = s.length;
    for (let i = 0, k = 0; i &lt; n; ++i) {
        const j = idx(s[i]);
        if (i &amp;&amp; (j - idx(s[i - 1]) + 26) % 26 === 1) {
            ++k;
        } else {
            k = 1;
        }
        f[j] = Math.max(f[j], k);
    }
    return f.reduce((acc, cur) =&gt; acc + cur, 0);
}
</code></pre>
<h4 id="rust-4"><a class="header" href="#rust-4">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn find_substring_in_wrapround_string(s: String) -&gt; i32 {
        let idx = |c: u8| -&gt; usize { (c - b'a') as usize };
        let mut f = vec![0; 26];
        let n = s.len();
        let s = s.as_bytes();
        let mut k = 0;
        for i in 0..n {
            let j = idx(s[i]);
            if i &gt; 0 &amp;&amp; ((j as i32) - (idx(s[i - 1]) as i32) + 26) % 26 == 1 {
                k += 1;
            } else {
                k = 1;
            }
            f[j] = f[j].max(k);
        }

        f.iter().sum()
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class UniqueSubstringInWraparoundString {

	public static int findSubstringInWraproundString(String str) {
		int n = str.length();
		int[] s = new int[n]; 
		// converting input str to int[] s
		// a -&gt; 0, b -&gt; 1, c -&gt; 2, ... y -&gt; 24, z -&gt; 25
		for (int i = 0; i &lt; n; i++) {
			s[i] = str.charAt(i) - 'a';
		}
		// dp[i] : the longest substring ending with character i in both str and base
		// e.g., if dp[i] = 4 (abcd, bcde, xyza, and etc), then there are 4 unique common substrings 
		int[] dp = new int[26];
		dp[s[0]] = 1;
		int len = 1, // length of the longest common substring
			cur, 	 // current character in s
			pre;	 // previous character in s
		for (int i = 1; i &lt; n; i++) {
			cur = s[i];
			pre = s[i - 1];
			if ((pre == 25 &amp;&amp; cur == 0) || pre + 1 == cur) {
				len++;
			} else {
				len = 1;
			}
			dp[cur] = Math.max(dp[cur], len);
		}
		int ans = 0;
		for (int i = 0; i &lt; 26; i++) {
			ans += dp[i];
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=10261">
    </iframe>
</details>
<h2 id="distinct-subsequences-ii"><a class="header" href="#distinct-subsequences-ii">Distinct Subsequences II</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Hard
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0940.Distinct%20Subsequences%20II/README_EN.md
tags:
    - String
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="940-distinct-subsequences-ii"><a class="header" href="#940-distinct-subsequences-ii"><a href="https://leetcode.com/problems/distinct-subsequences-ii">940. Distinct Subsequences II</a></a></h1>
<p><a href="dynamic-programming//solution/0900-0999/0940.Distinct%20Subsequences%20II/README.html">中文文档</a></p>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<!-- description:start -->
<p>Given a string s, return <em>the number of <strong>distinct non-empty subsequences</strong> of</em> <code>s</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;abc&quot;
<strong>Output:</strong> 7
<strong>Explanation:</strong> The 7 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, and &quot;abc&quot;.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;aba&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> The 6 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;aa&quot;, &quot;ba&quot;, and &quot;aba&quot;.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> s = &quot;aaa&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 distinct subsequences are &quot;a&quot;, &quot;aa&quot; and &quot;aaa&quot;.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 2000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
<!-- description:end -->
<h2 id="solutions-7"><a class="header" href="#solutions-7">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-2"><a class="header" href="#solution-1-2">Solution 1</a></h3>
<!-- tabs:start -->
<h4 id="python3-12"><a class="header" href="#python3-12">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10**9 + 7
        n = len(s)
        dp = [[0] * 26 for _ in range(n + 1)]
        for i, c in enumerate(s, 1):
            k = ord(c) - ord('a')
            for j in range(26):
                if j == k:
                    dp[i][j] = sum(dp[i - 1]) % mod + 1
                else:
                    dp[i][j] = dp[i - 1][j]
        return sum(dp[-1]) % mod
</code></pre>
<h4 id="java-11"><a class="header" href="#java-11">Java</a></h4>
<pre><code class="language-java">class Solution {
    private static final int MOD = (int) 1e9 + 7;

    public int distinctSubseqII(String s) {
        int[] dp = new int[26];
        for (int i = 0; i &lt; s.length(); ++i) {
            int j = s.charAt(i) - 'a';
            dp[j] = sum(dp) + 1;
        }
        return sum(dp);
    }

    private int sum(int[] arr) {
        int x = 0;
        for (int v : arr) {
            x = (x + v) % MOD;
        }
        return x;
    }
}
</code></pre>
<h4 id="c-14"><a class="header" href="#c-14">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    const int mod = 1e9 + 7;

    int distinctSubseqII(string s) {
        vector&lt;long&gt; dp(26);
        for (char&amp; c : s) {
            int i = c - 'a';
            dp[i] = accumulate(dp.begin(), dp.end(), 1l) % mod;
        }
        return accumulate(dp.begin(), dp.end(), 0l) % mod;
    }
};
</code></pre>
<h4 id="go-12"><a class="header" href="#go-12">Go</a></h4>
<pre><code class="language-go">func distinctSubseqII(s string) int {
	const mod int = 1e9 + 7
	sum := func(arr []int) int {
		x := 0
		for _, v := range arr {
			x = (x + v) % mod
		}
		return x
	}

	dp := make([]int, 26)
	for _, c := range s {
		c -= 'a'
		dp[c] = sum(dp) + 1
	}
	return sum(dp)
}
</code></pre>
<h4 id="typescript-9"><a class="header" href="#typescript-9">TypeScript</a></h4>
<pre><code class="language-ts">function distinctSubseqII(s: string): number {
    const mod = 1e9 + 7;
    const dp = new Array(26).fill(0);
    for (const c of s) {
        dp[c.charCodeAt(0) - 'a'.charCodeAt(0)] = dp.reduce((r, v) =&gt; (r + v) % mod, 0) + 1;
    }
    return dp.reduce((r, v) =&gt; (r + v) % mod, 0);
}
</code></pre>
<h4 id="rust-5"><a class="header" href="#rust-5">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn distinct_subseq_ii(s: String) -&gt; i32 {
        const MOD: i32 = (1e9 as i32) + 7;
        let mut dp = [0; 26];
        for u in s.as_bytes() {
            let i = (u - &amp;b'a') as usize;
            dp[i] = ({
                let mut sum = 0;
                dp.iter().for_each(|&amp;v| {
                    sum = (sum + v) % MOD;
                });
                sum
            }) + 1;
        }
        let mut res = 0;
        dp.iter().for_each(|&amp;v| {
            res = (res + v) % MOD;
        });
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="c-15"><a class="header" href="#c-15">C</a></h4>
<pre><code class="language-c">int distinctSubseqII(char* s) {
    int mod = 1e9 + 7;
    int n = strlen(s);
    int dp[26] = {0};
    for (int i = 0; i &lt; n; i++) {
        int sum = 0;
        for (int j = 0; j &lt; 26; j++) {
            sum = (sum + dp[j]) % mod;
        }
        dp[s[i] - 'a'] = sum + 1;
    }
    int res = 0;
    for (int i = 0; i &lt; 26; i++) {
        res = (res + dp[i]) % mod;
    }
    return res;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-1"><a class="header" href="#solution-2-1">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-13"><a class="header" href="#python3-13">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10**9 + 7
        dp = [0] * 26
        for c in s:
            i = ord(c) - ord('a')
            dp[i] = sum(dp) % mod + 1
        return sum(dp) % mod
</code></pre>
<h4 id="java-12"><a class="header" href="#java-12">Java</a></h4>
<pre><code class="language-java">class Solution {
    private static final int MOD = (int) 1e9 + 7;

    public int distinctSubseqII(String s) {
        int[] dp = new int[26];
        int ans = 0;
        for (int i = 0; i &lt; s.length(); ++i) {
            int j = s.charAt(i) - 'a';
            int add = (ans - dp[j] + 1) % MOD;
            ans = (ans + add) % MOD;
            dp[j] = (dp[j] + add) % MOD;
        }
        return (ans + MOD) % MOD;
    }
}
</code></pre>
<h4 id="c-16"><a class="header" href="#c-16">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    const int mod = 1e9 + 7;

    int distinctSubseqII(string s) {
        vector&lt;long&gt; dp(26);
        long ans = 0;
        for (char&amp; c : s) {
            int i = c - 'a';
            long add = ans - dp[i] + 1;
            ans = (ans + add + mod) % mod;
            dp[i] = (dp[i] + add) % mod;
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-13"><a class="header" href="#go-13">Go</a></h4>
<pre><code class="language-go">func distinctSubseqII(s string) int {
	const mod int = 1e9 + 7
	dp := make([]int, 26)
	ans := 0
	for _, c := range s {
		c -= 'a'
		add := ans - dp[c] + 1
		ans = (ans + add) % mod
		dp[c] = (dp[c] + add) % mod
	}
	return (ans + mod) % mod
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3"><a class="header" href="#solution-3">Solution 3</a></h3>
<!-- tabs:start -->
<h4 id="python3-14"><a class="header" href="#python3-14">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10**9 + 7
        dp = [0] * 26
        ans = 0
        for c in s:
            i = ord(c) - ord('a')
            add = ans - dp[i] + 1
            ans = (ans + add) % mod
            dp[i] += add
        return ans
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class DistinctSubsequencesII {

	// a b a a
	// 0 1 2 3
	//    {}                      all = 1
	// 0: {} {a}                  newAdd = 1 (all-cnt['a']); all = 2 (+=newAdd); cnt['a'] = 1 (+=newAdd)
	// 1: {}  {a}                 newAdd = 2 (all-cnt['b']); all = 4 (+=newAdd); cnt['b'] = 2 (+=newAdd) 
	//    {b} {ab}
	// 2: {}   {a}  {b}  {ab}     newAdd = 3 (all-cnt['a']); all = 7 (all + newAdd); cnt['a'] = 4 (+=newAdd)
	//    {a}* {aa} {ba} {aba}
	// 3: {}   {a}  {b}  {ab}     newAdd = 3 (all-cnt['a']); all = 10 (all + newAdd); cnt['a'] = 7 (+=newAdd)
	//    {aa} {ba} {aba}
	//    {a}* {aa}* {ba}* {aba}* 
	//    {aaa}  {baa}  {abaa}

	public static int distinctSubseqII(String s) {
		int mod = 1000000007;
		char[] str = s.toCharArray();
		int[] cnt = new int[26]; // number of subsequences ending with chr - 'a'
		int all = 1, // include empty string
			newAdd;
		for (char x : str) {
			newAdd = (all - cnt[x - 'a'] + mod) % mod;
			cnt[x - 'a'] = (cnt[x - 'a'] + newAdd) % mod;
			all = (all + newAdd) % mod;
		}
		return (all - 1 + mod) % mod;  // exclude empty string
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/n23bxZi4ZaY?start=11518">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-dimensional-dp-problems-part-1"><a class="header" href="#two-dimensional-dp-problems-part-1">Two-Dimensional DP Problems (part 1)</a></h1>
<h2 id="minimum-path-sum"><a class="header" href="#minimum-path-sum">Minimum Path Sum</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-path-sum">LeetCode 64. Minimum Path Sum</a></p>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<pre><code>Example 1:

Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1  3  1  1  1 minimizes the sum.

Example 2:

Input: grid = [[1,2,3],[4,5,6]]
Output: 12
</code></pre>
<p>Constraints:</p>
<ul>
<li>m = grid.length</li>
<li>n = grid[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>0 &lt;= grid[i][j] &lt;= 200</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class MinimumPathSum {

	// 1. brute-force recursive solution
	public static int minPathSum1(int[][] grid) {
		return f1(grid, grid.length - 1, grid[0].length - 1);
	}

	// compute the minimum path sum from grid[0][0] to grid[i][j]
	public static int f1(int[][] grid, int i, int j) {
		if (i == 0 &amp;&amp; j == 0) {
			return grid[0][0];
		}
		int up = Integer.MAX_VALUE;
		int left = Integer.MAX_VALUE;
		if (i - 1 &gt;= 0) {
			up = f1(grid, i - 1, j);
		}
		if (j - 1 &gt;= 0) {
			left = f1(grid, i, j - 1);
		}
		return grid[i][j] + Math.min(up, left);
	}

	// 2. recusive solution with memoization
	public static int minPathSum2(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int[][] dp = new int[n][m];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; m; j++) {
				dp[i][j] = -1;
			}
		}
		return f2(grid, grid.length - 1, grid[0].length - 1, dp);
	}

	public static int f2(int[][] grid, int i, int j, int[][] dp) {
		if (dp[i][j] != -1) {
			return dp[i][j];
		}
		int ans;
		if (i == 0 &amp;&amp; j == 0) {
			ans = grid[0][0];
		} else {
			int up = Integer.MAX_VALUE;
			int left = Integer.MAX_VALUE;
			if (i - 1 &gt;= 0) {
				up = f2(grid, i - 1, j, dp);
			}
			if (j - 1 &gt;= 0) {
				left = f2(grid, i, j - 1, dp);
			}
			ans = grid[i][j] + Math.min(up, left);
		}
		dp[i][j] = ans;
		return ans;
	}

	// 3. iterative bottom-up solution
	public static int minPathSum3(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int[][] dp = new int[n][m];
		dp[0][0] = grid[0][0];
		for (int i = 1; i &lt; n; i++) {
			dp[i][0] = dp[i - 1][0] + grid[i][0];
		}
		for (int j = 1; j &lt; m; j++) {
			dp[0][j] = dp[0][j - 1] + grid[0][j];
		}
		for (int i = 1; i &lt; n; i++) {
			for (int j = 1; j &lt; m; j++) {
				dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
			}
		}
		return dp[n - 1][m - 1];
	}

	// 4. iterative solution with space optimization
	public static int minPathSum4(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		// compressed reusable DP table, equivalent to one row of the 2D DP table
		int[] dp = new int[m];
		dp[0] = grid[0][0];
		for (int j = 1; j &lt; m; j++) {
			dp[j] = dp[j - 1] + grid[0][j];
		}
		for (int i = 1; i &lt; n; i++) {
			dp[0] += grid[i][0];
			for (int j = 1; j &lt; m; j++) { // refresh the DP table from left to right
				dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
			}
		}
		return dp[m - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=172">
    </iframe>
</details>
<h2 id="word-search"><a class="header" href="#word-search">Word Search</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/word-search">LeetCode 79. Word Search</a></p>
<p>Given an m x n grid of characters board and a string word, return true if word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<pre><code>Example 1:

Input: 
  board = [
    [A,B,C,E],
    [S,F,C,S],
    [A,D,E,E]
  ], 
  word = ABCCED
Output: true

Example 2:

Input:
  board = [
    [A,B,C,E],
    [S,F,C,S],
    [A,D,E,E]
  ], 
  word = SEE
Output: true

Example 3:

Input:
  board = [
    [A,B,C,E],
    [S,F,C,S],
    [A,D,E,E]
  ], 
  word = ABCB
Output: false

Example 4:

Input:
  board = [
    [A,T],
    [T,A],
    [S,S]
  ],
  word = ATASST
Output: true
</code></pre>
<p>Constraints:</p>
<ul>
<li>m = board.length</li>
<li>n = board[i].length</li>
<li>1 &lt;= m, n &lt;= 6</li>
<li>1 &lt;= word.length &lt;= 15</li>
<li>board and word consists of only lowercase and uppercase English letters.</li>
</ul>
<p>Follow up: Could you use search pruning to make your solution faster with a larger board?</p>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">public class WordSearch {

	// Note: This problem does not have iterative solution 
	// because the subproblem not only depend on i and j
	// but also depend on the visited state of the board.
	// For the same i and j, there are probably different
	// solutions for different board state.

	public static boolean exist(char[][] board, String word) {
		char[] w = word.toCharArray();
		for (int i = 0; i &lt; board.length; i++) {
			for (int j = 0; j &lt; board[0].length; j++) {
				if (f(board, i, j, w, 0)) {
					return true;
				}
			}
		}
		return false;
	}

	// starting from b[i][j], is there a match with w[k..]
	// recursive solution with backtracking
	public static boolean f(char[][] b, int i, int j, char[] w, int k) {
		if (k == w.length) {
			return true;
		}
		// check the boundaries and character match
		if (i &lt; 0 || i == b.length || j &lt; 0 || j == b[0].length || b[i][j] != w[k]) {
			return false;
		}
		// within the boundary of b and b[i][j] == w[k]
		char tmp = b[i][j]; // needed for backtracking
		b[i][j] = 0; // mark b[i][j] as visited
		boolean ans = f(b, i - 1, j, w, k + 1)  // search up
			    || f(b, i + 1, j, w, k + 1)     // search down 
				|| f(b, i, j - 1, w, k + 1)     // search left
				|| f(b, i, j + 1, w, k + 1);    // search right
		b[i][j] = tmp; // backtracking - restore the value of b[i][j]
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=2825">
    </iframe>
</details>
<h2 id="longest-common-subsequence"><a class="header" href="#longest-common-subsequence">Longest Common Subsequence</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/longest-common-subsequence">LeetCode 1143. Longest Common Subsequence</a></p>
<p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.</p>
<p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>
<pre><code>For example, ace is a subsequence of abcde.
</code></pre>
<p>A common subsequence of two strings is a subsequence that is common to both strings.</p>
<pre><code>Example 1:

Input: text1 = abcde, text2 = ace 
Output: 3  
Explanation: The longest common subsequence is ace and its length is 3.

Example 2:

Input: text1 = abc, text2 = abc
Output: 3
Explanation: The longest common subsequence is abc and its length is 3.

Example 3:

Input: text1 = abc, text2 = def
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= text1.length, text2.length &lt;= 1000</li>
<li>text1 and text2 consist of only lowercase English characters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/longest-common-subsequence/
public class LongestCommonSubsequence {

	// 0. brute-force recursive solution (naive version)
	public static int longestCommonSubsequence1(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		return f1(s1, s2, n - 1, m - 1);
	}

	// compute the LCS for substrings s1[0..i1] and s2[0..i2]
	public static int f1(char[] s1, char[] s2, int i1, int i2) {
		if (i1 &lt; 0 || i2 &lt; 0) {
			return 0;
		}
		int p1 = f1(s1, s2, i1 - 1, i2 - 1);		// case 1: drop both s1[i1] and s2[i2], ONLY used in case 4
		int p2 = f1(s1, s2, i1 - 1, i2);			// case 2: drop s1[i1] but keep s2[i2]			
		int p3 = f1(s1, s2, i1, i2 - 1);			// case 3: keep s1[i1] but drop s2[i2]
		int p4 = s1[i1] == s2[i2] ? (p1 + 1) : 0;	// case 4: keep both s1[i1] and s2[i2] if the two characters match
		return Math.max(Math.max(p1, p2), Math.max(p3, p4));
	}

	// 1. brute-force recursive solution (improved version)
	// notice in solution 0, p1 &lt;= p2 and p1 &lt;= p3
	public static int longestCommonSubsequence2(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		return f2(s1, s2, n, m);
	}

	// compute the LCS length for s1's len1-character prefix and s2's len2 prefix
	// using length intead of array index to avoid handling negative indices
	public static int f2(char[] s1, char[] s2, int len1, int len2) {
		if (len1 == 0 || len2 == 0) {
			return 0;
		}
		int ans;
		if (s1[len1 - 1] == s2[len2 - 1]) {	// the last characters of two strings match
			ans = f2(s1, s2, len1 - 1, len2 - 1) + 1;
		} else {
			ans = Math.max(f2(s1, s2, len1 - 1, len2), f2(s1, s2, len1, len2 - 1));
		}
		return ans;
	}

	// 2. recursive solution with memoization
	public static int longestCommonSubsequence3(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 0; i &lt;= n; i++) {
			for (int j = 0; j &lt;= m; j++) {
				dp[i][j] = -1;
			}
		}
		return f3(s1, s2, n, m, dp);
	}

	public static int f3(char[] s1, char[] s2, int len1, int len2, int[][] dp) {
		if (len1 == 0 || len2 == 0) {
			return 0;
		}
		if (dp[len1][len2] != -1) {
			return dp[len1][len2];
		}
		int ans;
		if (s1[len1 - 1] == s2[len2 - 1]) {
			ans = f3(s1, s2, len1 - 1, len2 - 1, dp) + 1;
		} else {
			ans = Math.max(f3(s1, s2, len1 - 1, len2, dp), f3(s1, s2, len1, len2 - 1, dp));
		}
		dp[len1][len2] = ans;
		return ans;
	}

	// 3. iterative bottom-up solution
	public static int longestCommonSubsequence4(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		int[][] dp = new int[n + 1][m + 1];
		for (int len1 = 1; len1 &lt;= n; len1++) {
			for (int len2 = 1; len2 &lt;= m; len2++) {
				if (s1[len1 - 1] == s2[len2 - 1]) {
					dp[len1][len2] = 1 + dp[len1 - 1][len2 - 1];
				} else {
					dp[len1][len2] = Math.max(dp[len1 - 1][len2], dp[len1][len2 - 1]);
				}
			}
		}
		return dp[n][m];
	}

	// 4. iterative solution + space optimization
	public static int longestCommonSubsequence5(String str1, String str2) {
		char[] s1, s2;
		if (str1.length() &gt;= str2.length()) {
			s1 = str1.toCharArray();
			s2 = str2.toCharArray();
		} else {
			s1 = str2.toCharArray();
			s2 = str1.toCharArray();
		}
		int n = s1.length;
		int m = s2.length;
		int[] dp = new int[m + 1];
		for (int len1 = 1; len1 &lt;= n; len1++) {
			int leftUp = 0, backup;
			for (int len2 = 1; len2 &lt;= m; len2++) {
				backup = dp[len2];
				if (s1[len1 - 1] == s2[len2 - 1]) {
					dp[len2] = 1 + leftUp;
				} else {
					dp[len2] = Math.max(dp[len2], dp[len2 - 1]);
				}
				leftUp = backup;
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=3756">
    </iframe>
</details>
<h2 id="longest-palindromic-subsequence"><a class="header" href="#longest-palindromic-subsequence">Longest Palindromic Subsequence</a></h2>
<details><summary>Description:</summary>
<hr />
<h2>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0500-0599/0516.Longest%20Palindromic%20Subsequence/README_EN.md
tags:
- String
- Dynamic Programming</h2>
<h1 id="516-longest-palindromic-subsequence"><a class="header" href="#516-longest-palindromic-subsequence"><a href="https://leetcode.com/problems/longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a></a></h1>
<p><a href="dynamic-programming//solution/0500-0599/0516.Longest%20Palindromic%20Subsequence/README.html">中文文档</a></p>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<p>Given a string s, find the longest palindromic subsequences length in s.</p>
<p>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<p>Example 1:</p>
<p>Input: s = bbbab
Output: 4
Explanation: One possible longest palindromic subsequence is bbbb.</p>
<p>Example 2:</p>
<p>Input: s = cbbd
Output: 2
Explanation: One possible longest palindromic subsequence is bb.</p>
<p>Constraints:</p>
<pre><code>1 = s.length = 1000
s consists only of lowercase English letters.
</code></pre>
<h2 id="solutions-8"><a class="header" href="#solutions-8">Solutions</a></h2>
<h3 id="solution-1-dynamic-programming-3"><a class="header" href="#solution-1-dynamic-programming-3">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i][j]$ as the length of the longest palindromic subsequence from the $i$-th character to the $j$-th character in string $s$. Initially, $f[i][i] = 1$, and the values of other positions are all $0$.</p>
<p>If $s[i] = s[j]$, then $f[i][j] = f[i + 1][j - 1] + 2$; otherwise, $f[i][j] = \max(f[i + 1][j], f[i][j - 1])$.</p>
<p>Since the value of $f[i][j]$ is related to $f[i + 1][j - 1]$, $f[i + 1][j]$, and $f[i][j - 1]$, we should enumerate $i$ from large to small, and enumerate $j$ from small to large.</p>
<p>The answer is $f[0][n - 1]$.</p>
<p>The time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Where $n$ is the length of the string $s$.</p>
<h4 id="python3-15"><a class="header" href="#python3-15">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        n = len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = 1
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1] + 2
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return f[0][-1]
</code></pre>
<h4 id="java-13"><a class="header" href="#java-13">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] f = new int[n][n];
        for (int i = 0; i &lt; n; ++i) {
            f[i][i] = 1;
        }
        for (int i = n - 1; i &gt;= 0; --i) {
            for (int j = i + 1; j &lt; n; ++j) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
}
</code></pre>
<h4 id="c-17"><a class="header" href="#c-17">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        int f[n][n];
        memset(f, 0, sizeof(f));
        for (int i = 0; i &lt; n; ++i) {
            f[i][i] = 1;
        }
        for (int i = n - 1; ~i; --i) {
            for (int j = i + 1; j &lt; n; ++j) {
                if (s[i] == s[j]) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
};
</code></pre>
<h4 id="go-14"><a class="header" href="#go-14">Go</a></h4>
<pre><code class="language-go">func longestPalindromeSubseq(s string) int {
	n := len(s)
	f := make([][]int, n)
	for i := range f {
		f[i] = make([]int, n)
		f[i][i] = 1
	}
	for i := n - 2; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			if s[i] == s[j] {
				f[i][j] = f[i+1][j-1] + 2
			} else {
				f[i][j] = max(f[i+1][j], f[i][j-1])
			}
		}
	}
	return f[0][n-1]
}
</code></pre>
<h4 id="typescript-10"><a class="header" href="#typescript-10">TypeScript</a></h4>
<pre><code class="language-ts">function longestPalindromeSubseq(s: string): number {
    const n = s.length;
    const f: number[][] = Array.from({ length: n }, () =&gt; Array(n).fill(0));
    for (let i = 0; i &lt; n; ++i) {
        f[i][i] = 1;
    }
    for (let i = n - 2; ~i; --i) {
        for (let j = i + 1; j &lt; n; ++j) {
            if (s[i] === s[j]) {
                f[i][j] = f[i + 1][j - 1] + 2;
            } else {
                f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
            }
        }
    }
    return f[0][n - 1];
}
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/longest-palindromic-subsequence/
public class LongestPalindromicSubsequence {

	// Note: this problem can be converted to LCS problem by comparing the orignal string with the reversed one.
	// Here we only discuss the DP solutions

	// 1. brute-force recursive solution
	public static int longestPalindromeSubseq1(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		return f1(s, 0, n - 1);
	}

	// compute the length of LPS for substring s[l..r]
	public static int f1(char[] s, int l, int r) {
		if (l == r) {
			return 1;
		}
		if (l + 1 == r) {
			return s[l] == s[r] ? 2 : 1;
		}
		if (s[l] == s[r]) {
			return 2 + f1(s, l + 1, r - 1);
		} else {
			return Math.max(f1(s, l + 1, r), f1(s, l, r - 1));
		}
	}

	// 2. recursive solution with memoization
	public static int longestPalindromeSubseq2(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		return f2(s, 0, n - 1, dp);
	}

	public static int f2(char[] s, int l, int r, int[][] dp) {
		if (l == r) {
			return 1;
		}
		if (l + 1 == r) {
			return s[l] == s[r] ? 2 : 1;
		}
		if (dp[l][r] != 0) {
			return dp[l][r];
		}
		int ans;
		if (s[l] == s[r]) {
			ans = 2 + f2(s, l + 1, r - 1, dp);
		} else {
			ans = Math.max(f2(s, l + 1, r, dp), f2(s, l, r - 1, dp));
		}
		dp[l][r] = ans;
		return ans;
	}

	// 3. iterative solution
	public static int longestPalindromeSubseq3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int l = n - 1; l &gt;= 0; l--) {
			dp[l][l] = 1;
			if (l + 1 &lt; n) {
				dp[l][l + 1] = s[l] == s[l + 1] ? 2 : 1;
			}
			for (int r = l + 2; r &lt; n; r++) {
				if (s[l] == s[r]) {
					dp[l][r] = 2 + dp[l + 1][r - 1];
				} else {
					dp[l][r] = Math.max(dp[l + 1][r], dp[l][r - 1]);
				}
			}
		}
		return dp[0][n - 1];
	}

	// 4. iterative solution with space optimization
	public static int longestPalindromeSubseq4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[] dp = new int[n];
		for (int l = n - 1, leftDown = 0, backup; l &gt;= 0; l--) {
			dp[l] = 1;
			if (l + 1 &lt; n) {
				leftDown = dp[l + 1];
				dp[l + 1] = s[l] == s[l + 1] ? 2 : 1;
			}
			for (int r = l + 2; r &lt; n; r++) {
				backup = dp[r];
				if (s[l] == s[r]) {
					dp[r] = 2 + leftDown;
				} else {
					dp[r] = Math.max(dp[r], dp[r - 1]);
				}
				leftDown = backup;
			}
		}
		return dp[n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=6378">
    </iframe>
</details>
<h2 id="longest-increasing-path-in-a-matrix"><a class="header" href="#longest-increasing-path-in-a-matrix">Longest Increasing Path in a Matrix</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix">LeetCode 329. Longest Increasing Path in a Matrix</a></p>
<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.</p>
<p>From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p>
<pre><code>Example 1:

Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].

Example 2:

Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

Example 3:

Input: matrix = [[1]]
Output: 1
</code></pre>
<p>Constraints:</p>
<ul>
<li>m = matrix.length</li>
<li>n = matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>0 &lt;= matrix[i][j] &lt;= 2^31 - 1</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
public class LongestIncreasingPathInMatrix {

	// 1. brute-force recursive solution
	public static int longestIncreasingPath1(int[][] grid) {
		int ans = 0;
		for (int i = 0; i &lt; grid.length; i++) {
			for (int j = 0; j &lt; grid[0].length; j++) {
				ans = Math.max(ans, f1(grid, i, j));
			}
		}
		return ans;
	}

	// compute longest increasing path from grid[i][j]
	public static int f1(int[][] grid, int i, int j) {
		int next = 0;
		if (i &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i - 1][j]) {
			next = Math.max(next, f1(grid, i - 1, j));
		}
		if (i + 1 &lt; grid.length &amp;&amp; grid[i][j] &lt; grid[i + 1][j]) {
			next = Math.max(next, f1(grid, i + 1, j));
		}
		if (j &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i][j - 1]) {
			next = Math.max(next, f1(grid, i, j - 1));
		}
		if (j + 1 &lt; grid[0].length &amp;&amp; grid[i][j] &lt; grid[i][j + 1]) {
			next = Math.max(next, f1(grid, i, j + 1));
		}
		return next + 1;
	}

	// recursive solution with memoization
	public static int longestIncreasingPath2(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int[][] dp = new int[n][m];
		int ans = 0;
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; m; j++) {
				ans = Math.max(ans, f2(grid, i, j, dp));
			}
		}
		return ans;
	}

	public static int f2(int[][] grid, int i, int j, int[][] dp) {
		if (dp[i][j] != 0) {
			return dp[i][j];
		}
		int next = 0;
		if (i &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i - 1][j]) {
			next = Math.max(next, f2(grid, i - 1, j, dp));
		}
		if (i + 1 &lt; grid.length &amp;&amp; grid[i][j] &lt; grid[i + 1][j]) {
			next = Math.max(next, f2(grid, i + 1, j, dp));
		}
		if (j &gt; 0 &amp;&amp; grid[i][j] &lt; grid[i][j - 1]) {
			next = Math.max(next, f2(grid, i, j - 1, dp));
		}
		if (j + 1 &lt; grid[0].length &amp;&amp; grid[i][j] &lt; grid[i][j + 1]) {
			next = Math.max(next, f2(grid, i, j + 1, dp));
		}
		dp[i][j] = next + 1;
		return next + 1;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/ZfCVUUWi2Y8?start=10078">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-dimensional-dp-problems-part-2"><a class="header" href="#two-dimensional-dp-problems-part-2">Two-Dimensional DP Problems (part 2)</a></h1>
<h2 id="distinct-subsequences"><a class="header" href="#distinct-subsequences">Distinct Subsequences</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/distinct-subsequences">LeetCode 115. Distinct Subsequences</a></p>
<p>Given two strings s and t, return the number of distinct subsequences of s which equals t.</p>
<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>
<pre><code>Example 1:

Input: s = rabbbit, t = rabbit
Output: 3
Explanation:
As shown below, there are 3 ways you can generate rabbit from s.
rabbbit
rabbbit
rabbbit

Example 2:

Input: s = babgbag, t = bag
Output: 5
Explanation:
As shown below, there are 5 ways you can generate bag from s.
babgbag
babgbag
babgbag
babgbag
babgbag
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length, t.length &lt;= 1000</li>
<li>s and t consist of English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/distinct-subsequences/
public class DistinctSubsequences {

	// 1. iterative solution using a 2D DP table
	public static int numDistinct1(String str, String target) {
		char[] s = str.toCharArray();
		char[] t = target.toCharArray();
		int n = s.length;
		int m = t.length;
		// dp[i][j] : number of subsequences in s[0..i] that match substring t[0..j]
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 0; i &lt;= n; i++) {
			dp[i][0] = 1;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				dp[i][j] = dp[i - 1][j];
				if (s[i - 1] == t[j - 1]) {
					dp[i][j] += dp[i - 1][j - 1];
				}
			}
		}
		return dp[n][m];
	}

	// 2. iterative solution + space optimization
	public static int numDistinct2(String str, String target) {
		char[] s = str.toCharArray();
		char[] t = target.toCharArray();
		int n = s.length;
		int m = t.length;
		int[] dp = new int[m + 1];
		dp[0] = 1;
		for (int i = 1; i &lt;= n; i++) {
			for (int j = m; j &gt;= 1; j--) {
				if (s[i - 1] == t[j - 1]) {
					dp[j] += dp[j - 1];
				}
			}
		}
		return dp[m];
	}

	// 3. fix overflow error: answer % (10^9 + 7)
	public static int numDistinct3(String str, String target) {
		int mod = 1000000007;
		char[] s = str.toCharArray();
		char[] t = target.toCharArray();
		int n = s.length;
		int m = t.length;
		int[] dp = new int[m + 1];
		dp[0] = 1;
		for (int i = 1; i &lt;= n; i++) {
			for (int j = m; j &gt;= 1; j--) {
				if (s[i - 1] == t[j - 1]) {
					dp[j] = (dp[j] + dp[j - 1]) % mod;
				}
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=85">
    </iframe>
</details>
<h2 id="edit-distance"><a class="header" href="#edit-distance">Edit Distance</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/edit-distance">LeetCode 72. Edit Distance</a></p>
<p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following three operations permitted on a word:</p>
<pre><code>Insert a character
Delete a character
Replace a character
</code></pre>
<pre><code>Example 1:

Input: word1 = horse, word2 = ros
Output: 3
Explanation: 
horse - rorse (replace h with r)
rorse - rose (remove r)
rose - ros (remove e)

Example 2:

Input: word1 = intention, word2 = execution
Output: 5
Explanation: 
intention - inention (remove t)
inention - enention (replace i with e)
enention - exention (replace n with x)
exention - exection (replace n with c)
exection - execution (insert u)
</code></pre>
<p>Constraints:</p>
<ul>
<li>0 &lt;= word1.length, word2.length &lt;= 500</li>
<li>word1 and word2 consist of lowercase English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/edit-distance/
public class EditDistance {

	public int minDistance(String word1, String word2) {
		return editDistance2(word1, word2, 1, 1, 1);
	}

	// 0. first trial version	
	// a : cost of insersion
	// b : cost of deletion
	// c : cost of substitution
	public static int editDistance1(String str1, String str2, int a, int b, int c) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[i][j] : cost of converting s1[0..i] to s2[0..j]
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][0] = i * b;
		}
		for (int j = 1; j &lt;= m; j++) {
			dp[0][j] = j * a;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				int p1 = Integer.MAX_VALUE;
				if (s1[i - 1] == s2[j - 1]) {
					p1 = dp[i - 1][j - 1];
				}
				int p2 = Integer.MAX_VALUE;
				if (s1[i - 1] != s2[j - 1]) {
					p2 = dp[i - 1][j - 1] + c;
				}
				int p3 = dp[i][j - 1] + a;
				int p4 = dp[i - 1][j] + b;
				dp[i][j] = Math.min(Math.min(p1, p2), Math.min(p3, p4));
			}
		}
		return dp[n][m];
	}

	// 1. optimized version - fast enumeration
	// a : cost of insersion
	// b : cost of deletion
	// c : cost of substitution
	public static int editDistance2(String str1, String str2, int a, int b, int c) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[i][j] : cost of converting s1[0..i] to s2[0..j]
		int[][] dp = new int[n + 1][m + 1];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][0] = i * b;
		}
		for (int j = 1; j &lt;= m; j++) {
			dp[0][j] = j * a;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				if (s1[i - 1] == s2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(Math.min(dp[i - 1][j] + b, dp[i][j - 1] + a), dp[i - 1][j - 1] + c);
				}
			}
		}
		return dp[n][m];
	}

	// 2. solution with space optimization
	public static int editDistance3(String str1, String str2, int a, int b, int c) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		int[] dp = new int[m + 1];
		for (int j = 1; j &lt;= m; j++) {
			dp[j] = j * a;
		}
		for (int i = 1, leftUp, backUp; i &lt;= n; i++) {
			leftUp = (i - 1) * b;
			dp[0] = i * b;
			for (int j = 1; j &lt;= m; j++) {
				backUp = dp[j];
				if (s1[i - 1] == s2[j - 1]) {
					dp[j] = leftUp;
				} else {
					dp[j] = Math.min(Math.min(dp[j] + b, dp[j - 1] + a), leftUp + c);
				}
				leftUp = backUp;
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=1333">
    </iframe>
</details>
<h2 id="interleaving-string"><a class="header" href="#interleaving-string">Interleaving String</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/interleaving-string">LeetCode 97. Interleaving String</a></p>
<p>Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.</p>
<p>An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:</p>
<pre><code>s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| = 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
</code></pre>
<p>Note: a + b is the concatenation of strings a and b.</p>
<pre><code>Example 1:

Input: s1 = aabcc, s2 = dbbca, s3 = aadbbcbcac
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = aa + bc + c, and s2 into s2 = dbbc + a.
Interleaving the two splits, we get aa + dbbc + bc + a + c = aadbbcbcac.
Since s3 can be obtained by interleaving s1 and s2, we return true.

Example 2:

Input: s1 = aabcc, s2 = dbbca, s3 = aadbbbaccc
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.

Example 3:

Input: s1 = , s2 = , s3 = 
Output: true
</code></pre>
<p>Constraints:</p>
<ul>
<li>0 &lt;= s1.length, s2.length &lt;= 100</li>
<li>0 &lt;= s3.length &lt;= 200</li>
<li>s1, s2, and s3 consist of lowercase English letters.</li>
</ul>
<p>Follow up: Could you solve it using only O(s2.length) additional memory space?</p>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/interleaving-string/
public class InterleavingString {

	// 1. iterative bottom up solution
	public static boolean isInterleave1(String str1, String str2, String str3) {
		if (str1.length() + str2.length() != str3.length()) {
			return false;
		}
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		char[] s3 = str3.toCharArray();
		int n = s1.length;
		int m = s2.length;
		// dp[i][j]: can substrings s1[0..i] and s2[0..j] interleave into s3[0..i+j]
		boolean[][] dp = new boolean[n + 1][m + 1];
		dp[0][0] = true;
		for (int i = 1; i &lt;= n; i++) {
			if (s1[i - 1] != s3[i - 1]) {
				break;
			}
			dp[i][0] = true;
		}
		for (int j = 1; j &lt;= m; j++) {
			if (s2[j - 1] != s3[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		for (int i = 1; i &lt;= n; i++) {
			for (int j = 1; j &lt;= m; j++) {
				dp[i][j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1]);
			}
		}
		return dp[n][m];
	}

	// 2. iterative solution with space optimization 
	public static boolean isInterleave2(String str1, String str2, String str3) {
		if (str1.length() + str2.length() != str3.length()) {
			return false;
		}
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		char[] s3 = str3.toCharArray();
		int n = s1.length;
		int m = s2.length;
		boolean[] dp = new boolean[m + 1];
		dp[0] = true;
		for (int j = 1; j &lt;= m; j++) {
			if (s2[j - 1] != s3[j - 1]) {
				break;
			}
			dp[j] = true;
		}
		for (int i = 1; i &lt;= n; i++) {
			dp[0] = s1[i - 1] == s3[i - 1] &amp;&amp; dp[0];
			for (int j = 1; j &lt;= m; j++) {
				dp[j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[j - 1]);
			}
		}
		return dp[m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/cDljUjSkQ3c?start=2921">
    </iframe>
</details>
<h2 id="fill-cells-use-all-colors-ways"><a class="header" href="#fill-cells-use-all-colors-ways">Fill Cells Use All Colors Ways</a></h2>
<h2 id="minimum-delete-become-substring"><a class="header" href="#minimum-delete-become-substring">Minimum Delete Become Substring</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-subarray-sum-and-the-related-problems-part-1"><a class="header" href="#largest-subarray-sum-and-the-related-problems-part-1">Largest Subarray Sum and the Related Problems (part 1)</a></h1>
<h2 id="maximumsubarray"><a class="header" href="#maximumsubarray">MaximumSubarray</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0000-0099/0053.Maximum%20Subarray/README_EN.md
tags:
    - Array
    - Divide and Conquer
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="53-maximum-subarray"><a class="header" href="#53-maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray">53. Maximum Subarray</a></a></h1>
<p><a href="dynamic-programming//solution/0000-0099/0053.Maximum%20Subarray/README.html">中文文档</a></p>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<!-- description:start -->
<p>Given an integer array <code>nums</code>, find the <span data-keyword="subarray-nonempty">subarray</span> with the largest sum, and return <em>its sum</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The subarray [1] has the largest sum 1.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [5,4,-1,7,8]
<strong>Output:</strong> 23
<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
<p>&nbsp;</p>
<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>
<!-- description:end -->
<h2 id="solutions-9"><a class="header" href="#solutions-9">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-4"><a class="header" href="#solution-1-dynamic-programming-4">Solution 1: Dynamic Programming</a></h3>
<p>We define $f[i]$ to represent the maximum sum of a contiguous subarray ending at element $\textit{nums}[i]$. Initially, $f[0] = \textit{nums}[0]$. The final answer we seek is $\max_{0 \leq i &lt; n} f[i]$.</p>
<p>Consider $f[i]$ for $i \geq 1$. Its state transition equation is:</p>
<p>$$
f[i] = \max(f[i - 1] + \textit{nums}[i], \textit{nums}[i])
$$</p>
<p>That is:</p>
<p>$$
f[i] = \max(f[i - 1], 0) + \textit{nums}[i]
$$</p>
<p>Since $f[i]$ is only related to $f[i - 1]$, we can use a single variable $f$ to maintain the current value of $f[i]$ and perform the state transition. The answer is $\max_{0 \leq i &lt; n} f$.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array $\textit{nums}$. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-16"><a class="header" href="#python3-16">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        ans = f = nums[0]
        for x in nums[1:]:
            f = max(f, 0) + x
            ans = max(ans, f)
        return ans
</code></pre>
<h4 id="java-14"><a class="header" href="#java-14">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        for (int i = 1, f = nums[0]; i &lt; nums.length; ++i) {
            f = Math.max(f, 0) + nums[i];
            ans = Math.max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<h4 id="c-18"><a class="header" href="#c-18">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = nums[0], f = nums[0];
        for (int i = 1; i &lt; nums.size(); ++i) {
            f = max(f, 0) + nums[i];
            ans = max(ans, f);
        }
        return ans;
    }
};
</code></pre>
<h4 id="go-15"><a class="header" href="#go-15">Go</a></h4>
<pre><code class="language-go">func maxSubArray(nums []int) int {
	ans, f := nums[0], nums[0]
	for _, x := range nums[1:] {
		f = max(f, 0) + x
		ans = max(ans, f)
	}
	return ans
}
</code></pre>
<h4 id="typescript-11"><a class="header" href="#typescript-11">TypeScript</a></h4>
<pre><code class="language-ts">function maxSubArray(nums: number[]): number {
    let [ans, f] = [nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        f = Math.max(f, 0) + nums[i];
        ans = Math.max(ans, f);
    }
    return ans;
}
</code></pre>
<h4 id="rust-6"><a class="header" href="#rust-6">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut ans = nums[0];
        let mut f = nums[0];
        for i in 1..n {
            f = f.max(0) + nums[i];
            ans = ans.max(f);
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-5"><a class="header" href="#javascript-5">JavaScript</a></h4>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    let [ans, f] = [nums[0], nums[0]];
    for (let i = 1; i &lt; nums.length; ++i) {
        f = Math.max(f, 0) + nums[i];
        ans = Math.max(ans, f);
    }
    return ans;
};
</code></pre>
<h4 id="c-19"><a class="header" href="#c-19">C#</a></h4>
<pre><code class="language-cs">public class Solution {
    public int MaxSubArray(int[] nums) {
        int ans = nums[0], f = nums[0];
        for (int i = 1; i &lt; nums.Length; ++i) {
            f = Math.Max(f, 0) + nums[i];
            ans = Math.Max(ans, f);
        }
        return ans;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-2"><a class="header" href="#solution-2-2">Solution 2</a></h3>
<!-- tabs:start -->
<h4 id="python3-17"><a class="header" href="#python3-17">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        def crossMaxSub(nums, left, mid, right):
            lsum = rsum = 0
            lmx = rmx = -inf
            for i in range(mid, left - 1, -1):
                lsum += nums[i]
                lmx = max(lmx, lsum)
            for i in range(mid + 1, right + 1):
                rsum += nums[i]
                rmx = max(rmx, rsum)
            return lmx + rmx

        def maxSub(nums, left, right):
            if left == right:
                return nums[left]
            mid = (left + right) &gt;&gt; 1
            lsum = maxSub(nums, left, mid)
            rsum = maxSub(nums, mid + 1, right)
            csum = crossMaxSub(nums, left, mid, right)
            return max(lsum, rsum, csum)

        left, right = 0, len(nums) - 1
        return maxSub(nums, left, right)
</code></pre>
<h4 id="java-15"><a class="header" href="#java-15">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        return maxSub(nums, 0, nums.length - 1);
    }

    private int maxSub(int[] nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        int mid = (left + right) &gt;&gt;&gt; 1;
        int lsum = maxSub(nums, left, mid);
        int rsum = maxSub(nums, mid + 1, right);
        return Math.max(Math.max(lsum, rsum), crossMaxSub(nums, left, mid, right));
    }

    private int crossMaxSub(int[] nums, int left, int mid, int right) {
        int lsum = 0, rsum = 0;
        int lmx = Integer.MIN_VALUE, rmx = Integer.MIN_VALUE;
        for (int i = mid; i &gt;= left; --i) {
            lsum += nums[i];
            lmx = Math.max(lmx, lsum);
        }
        for (int i = mid + 1; i &lt;= right; ++i) {
            rsum += nums[i];
            rmx = Math.max(rmx, rsum);
        }
        return lmx + rmx;
    }
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 子数组最大累加和
// 给你一个整数数组 nums
// 返回非空子数组的最大累加和
// 测试链接 : https://leetcode.com/problems/maximum-subarray/
public class Code01_MaximumSubarray {

	// 动态规划
	public static int maxSubArray1(int[] nums) {
		int n = nums.length;
		// dp[i] : 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和
		int[] dp = new int[n];
		dp[0] = nums[0];
		int ans = nums[0];
		for (int i = 1; i &lt; n; i++) {
			dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}

	// 空间压缩
	public static int maxSubArray2(int[] nums) {
		int n = nums.length;
		int ans = nums[0];
		for (int i = 1, pre = nums[0]; i &lt; n; i++) {
			pre = Math.max(nums[i], pre + nums[i]);
			ans = Math.max(ans, pre);
		}
		return ans;
	}

	// 如下代码为附加问题的实现
	// 子数组中找到拥有最大累加和的子数组
	// 并返回如下三个信息:
	// 1) 最大累加和子数组的开头left
	// 2) 最大累加和子数组的结尾right
	// 3) 最大累加和子数组的累加和sum
	// 如果不止一个子数组拥有最大累加和，那么找到哪一个都可以
	public static int left;

	public static int right;

	public static int sum;

	// 找到拥有最大累加和的子数组
	// 更新好全局变量left、right、sum
	// 上游调用函数可以直接使用这三个变量
	// 相当于返回了三个值
	public static void extra(int[] nums) {
		sum = Integer.MIN_VALUE;
		for (int l = 0, r = 0, pre = Integer.MIN_VALUE; r &lt; nums.length; r++) {
			if (pre &gt;= 0) {
				// 吸收前面的累加和有利可图
				// 那就不换开头
				pre += nums[r];
			} else {
				// 吸收前面的累加和已经无利可图
				// 那就换开头
				pre = nums[r];
				l = r;
			}
			if (pre &gt; sum) {
				sum = pre;
				left = l;
				right = r;
			}
		}
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=75">
    </iframe>
</details>
<h2 id="houserobber"><a class="header" href="#houserobber">HouseRobber</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0100-0199/0198.House%20Robber/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="198-house-robber"><a class="header" href="#198-house-robber"><a href="https://leetcode.com/problems/house-robber">198. House Robber</a></a></h1>
<p><a href="dynamic-programming//solution/0100-0199/0198.House%20Robber/README.html">中文文档</a></p>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<!-- description:start -->
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,7,9,3,1]
<strong>Output:</strong> 12
<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-10"><a class="header" href="#solutions-10">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-memoization-search"><a class="header" href="#solution-1-memoization-search">Solution 1: Memoization Search</a></h3>
<p>We design a function $\textit{dfs}(i)$, which represents the maximum amount of money that can be stolen starting from the $i$-th house. Thus, the answer is $\textit{dfs}(0)$.</p>
<p>The execution process of the function $\textit{dfs}(i)$ is as follows:</p>
<ul>
<li>If $i \ge \textit{len}(\textit{nums})$, it means all houses have been considered, and we directly return $0$;</li>
<li>Otherwise, consider stealing from the $i$-th house, then $\textit{dfs}(i) = \textit{nums}[i] + \textit{dfs}(i+2)$; if not stealing from the $i$-th house, then $\textit{dfs}(i) = \textit{dfs}(i+1)$.</li>
<li>Return $\max(\textit{nums}[i] + \textit{dfs}(i+2), \textit{dfs}(i+1))$.</li>
</ul>
<p>To avoid repeated calculations, we use memoization search. The result of $\textit{dfs}(i)$ is saved in an array or hash table. Before each calculation, we first check if it has been calculated. If so, we directly return the result.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array.</p>
<!-- tabs:start -->
<h4 id="python3-18"><a class="header" href="#python3-18">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        @cache
        def dfs(i: int) -&gt; int:
            if i &gt;= len(nums):
                return 0
            return max(nums[i] + dfs(i + 2), dfs(i + 1))

        return dfs(0)
</code></pre>
<h4 id="java-16"><a class="header" href="#java-16">Java</a></h4>
<pre><code class="language-java">class Solution {
    private Integer[] f;
    private int[] nums;

    public int rob(int[] nums) {
        this.nums = nums;
        f = new Integer[nums.length];
        return dfs(0);
    }

    private int dfs(int i) {
        if (i &gt;= nums.length) {
            return 0;
        }
        if (f[i] == null) {
            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));
        }
        return f[i];
    }
}
</code></pre>
<h4 id="c-20"><a class="header" href="#c-20">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int f[n];
        memset(f, -1, sizeof(f));
        auto dfs = [&amp;](auto&amp;&amp; dfs, int i) -&gt; int {
            if (i &gt;= n) {
                return 0;
            }
            if (f[i] &lt; 0) {
                f[i] = max(nums[i] + dfs(dfs, i + 2), dfs(dfs, i + 1));
            }
            return f[i];
        };
        return dfs(dfs, 0);
    }
};
</code></pre>
<h4 id="go-16"><a class="header" href="#go-16">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	n := len(nums)
	f := make([]int, n)
	for i := range f {
		f[i] = -1
	}
	var dfs func(int) int
	dfs = func(i int) int {
		if i &gt;= n {
			return 0
		}
		if f[i] &lt; 0 {
			f[i] = max(nums[i]+dfs(i+2), dfs(i+1))
		}
		return f[i]
	}
	return dfs(0)
}
</code></pre>
<h4 id="typescript-12"><a class="header" href="#typescript-12">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    const n = nums.length;
    const f: number[] = Array(n).fill(-1);
    const dfs = (i: number): number =&gt; {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i] &lt; 0) {
            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));
        }
        return f[i];
    };
    return dfs(0);
}
</code></pre>
<h4 id="rust-7"><a class="header" href="#rust-7">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        fn dfs(i: usize, nums: &amp;Vec&lt;i32&gt;, f: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {
            if i &gt;= nums.len() {
                return 0;
            }
            if f[i] &lt; 0 {
                f[i] = (nums[i] + dfs(i + 2, nums, f)).max(dfs(i + 1, nums, f));
            }
            f[i]
        }

        let n = nums.len();
        let mut f = vec![-1; n];
        dfs(0, &amp;nums, &amp;mut f)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-6"><a class="header" href="#javascript-6">JavaScript</a></h4>
<pre><code class="language-js">function rob(nums) {
    const n = nums.length;
    const f = Array(n).fill(-1);
    const dfs = i =&gt; {
        if (i &gt;= n) {
            return 0;
        }
        if (f[i] &lt; 0) {
            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));
        }
        return f[i];
    };
    return dfs(0);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-2-dynamic-programming-1"><a class="header" href="#solution-2-dynamic-programming-1">Solution 2: Dynamic Programming</a></h3>
<p>We define $f[i]$ as the maximum total amount that can be robbed from the first $i$ houses, initially $f[0]=0$, $f[1]=nums[0]$.</p>
<p>Consider the case where $i \gt 1$, the $i$th house has two options:</p>
<ul>
<li>Do not rob the $i$th house, the total amount of robbery is $f[i-1]$;</li>
<li>Rob the $i$th house, the total amount of robbery is $f[i-2]+nums[i-1]$;</li>
</ul>
<p>Therefore, we can get the state transition equation:</p>
<p>$$
f[i]=
\begin{cases}
0, &amp; i=0 \
nums[0], &amp; i=1 \
\max(f[i-1],f[i-2]+nums[i-1]), &amp; i \gt 1
\end{cases}
$$</p>
<p>The final answer is $f[n]$, where $n$ is the length of the array.</p>
<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array.</p>
<!-- tabs:start -->
<h4 id="python3-19"><a class="header" href="#python3-19">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [0] * (n + 1)
        f[1] = nums[0]
        for i in range(2, n + 1):
            f[i] = max(f[i - 1], f[i - 2] + nums[i - 1])
        return f[n]
</code></pre>
<h4 id="java-17"><a class="header" href="#java-17">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] f = new int[n + 1];
        f[1] = nums[0];
        for (int i = 2; i &lt;= n; ++i) {
            f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
        }
        return f[n];
    }
}
</code></pre>
<h4 id="c-21"><a class="header" href="#c-21">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int f[n + 1];
        memset(f, 0, sizeof(f));
        f[1] = nums[0];
        for (int i = 2; i &lt;= n; ++i) {
            f[i] = max(f[i - 1], f[i - 2] + nums[i - 1]);
        }
        return f[n];
    }
};
</code></pre>
<h4 id="go-17"><a class="header" href="#go-17">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	n := len(nums)
	f := make([]int, n+1)
	f[1] = nums[0]
	for i := 2; i &lt;= n; i++ {
		f[i] = max(f[i-1], f[i-2]+nums[i-1])
	}
	return f[n]
}
</code></pre>
<h4 id="typescript-13"><a class="header" href="#typescript-13">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    const n = nums.length;
    const f: number[] = Array(n + 1).fill(0);
    f[1] = nums[0];
    for (let i = 2; i &lt;= n; ++i) {
        f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
    }
    return f[n];
}
</code></pre>
<h4 id="rust-8"><a class="header" href="#rust-8">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut f = vec![0; n + 1];
        f[1] = nums[0];
        for i in 2..=n {
            f[i] = f[i - 1].max(f[i - 2] + nums[i - 1]);
        }
        f[n]
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-7"><a class="header" href="#javascript-7">JavaScript</a></h4>
<pre><code class="language-js">function rob(nums) {
    const n = nums.length;
    const f = Array(n + 1).fill(0);
    f[1] = nums[0];
    for (let i = 2; i &lt;= n; ++i) {
        f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
    }
    return f[n];
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- solution:start -->
<h3 id="solution-3-dynamic-programming-space-optimization"><a class="header" href="#solution-3-dynamic-programming-space-optimization">Solution 3: Dynamic Programming (Space Optimization)</a></h3>
<p>We notice that when $i \gt 2$, $f[i]$ is only related to $f[i-1]$ and $f[i-2]$. Therefore, we can use two variables instead of an array to reduce the space complexity to $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-20"><a class="header" href="#python3-20">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        f = g = 0
        for x in nums:
            f, g = max(f, g), f + x
        return max(f, g)
</code></pre>
<h4 id="java-18"><a class="header" href="#java-18">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int rob(int[] nums) {
        int f = 0, g = 0;
        for (int x : nums) {
            int ff = Math.max(f, g);
            g = f + x;
            f = ff;
        }
        return Math.max(f, g);
    }
}
</code></pre>
<h4 id="c-22"><a class="header" href="#c-22">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int f = 0, g = 0;
        for (int&amp; x : nums) {
            int ff = max(f, g);
            g = f + x;
            f = ff;
        }
        return max(f, g);
    }
};
</code></pre>
<h4 id="go-18"><a class="header" href="#go-18">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	f, g := 0, 0
	for _, x := range nums {
		f, g = max(f, g), f+x
	}
	return max(f, g)
}
</code></pre>
<h4 id="typescript-14"><a class="header" href="#typescript-14">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    let [f, g] = [0, 0];
    for (const x of nums) {
        [f, g] = [Math.max(f, g), f + x];
    }
    return Math.max(f, g);
}
</code></pre>
<h4 id="rust-9"><a class="header" href="#rust-9">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut f = [0, 0];
        for x in nums {
            f = [f[0].max(f[1]), f[0] + x];
        }
        f[0].max(f[1])
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="javascript-8"><a class="header" href="#javascript-8">JavaScript</a></h4>
<pre><code class="language-js">function rob(nums) {
    let [f, g] = [0, 0];
    for (const x of nums) {
        [f, g] = [Math.max(f, g), f + x];
    }
    return Math.max(f, g);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 数组中不能选相邻元素的最大累加和
// 给定一个数组，可以随意选择数字
// 但是不能选择相邻的数字，返回能得到的最大累加和
// 测试链接 : https://leetcode.com/problems/house-robber/
public class Code02_HouseRobber {

	// 动态规划
	public static int rob1(int[] nums) {
		int n = nums.length;
		if (n == 1) {
			return nums[0];
		}
		if (n == 2) {
			return Math.max(nums[0], nums[1]);
		}
		// dp[i] : nums[0...i]范围上可以随意选择数字，但是不能选相邻数，能得到的最大累加和
		int[] dp = new int[n];
		dp[0] = nums[0];
		dp[1] = Math.max(nums[0], nums[1]);
		for (int i = 2; i &lt; n; i++) {
			dp[i] = Math.max(dp[i - 1], Math.max(nums[i], dp[i - 2] + nums[i]));
		}
		return dp[n - 1];
	}

	// 空间压缩
	public static int rob2(int[] nums) {
		int n = nums.length;
		if (n == 1) {
			return nums[0];
		}
		if (n == 2) {
			return Math.max(nums[0], nums[1]);
		}
		int prepre = nums[0];
		int pre = Math.max(nums[0], nums[1]);
		for (int i = 2, cur; i &lt; n; i++) {
			cur = Math.max(pre, Math.max(nums[i], prepre + nums[i]));
			prepre = pre;
			pre = cur;
		}
		return pre;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=1685">
    </iframe>
</details>
<h2 id="maximumsumcircularsubarray"><a class="header" href="#maximumsumcircularsubarray">MaximumSumCircularSubarray</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0900-0999/0918.Maximum%20Sum%20Circular%20Subarray/README_EN.md
tags:
    - Queue
    - Array
    - Divide and Conquer
    - Dynamic Programming
    - Monotonic Queue
</code></pre>
<!-- problem:start -->
<h1 id="918-maximum-sum-circular-subarray"><a class="header" href="#918-maximum-sum-circular-subarray"><a href="https://leetcode.com/problems/maximum-sum-circular-subarray">918. Maximum Sum Circular Subarray</a></a></h1>
<p><a href="dynamic-programming//solution/0900-0999/0918.Maximum%20Sum%20Circular%20Subarray/README.html">中文文档</a></p>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<!-- description:start -->
<p>Given a <strong>circular integer array</strong> <code>nums</code> of length <code>n</code>, return <em>the maximum possible sum of a non-empty <strong>subarray</strong> of </em><code>nums</code>.</p>
<p>A <strong>circular array</strong> means the end of the array connects to the beginning of the array. Formally, the next element of <code>nums[i]</code> is <code>nums[(i + 1) % n]</code> and the previous element of <code>nums[i]</code> is <code>nums[(i - 1 + n) % n]</code>.</p>
<p>A <strong>subarray</strong> may only include each element of the fixed buffer <code>nums</code> at most once. Formally, for a subarray <code>nums[i], nums[i + 1], ..., nums[j]</code>, there does not exist <code>i &lt;= k1</code>, <code>k2 &lt;= j</code> with <code>k1 % n == k2 % n</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,-2,3,-2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Subarray [3] has maximum sum 3.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [5,-3,5]
<strong>Output:</strong> 10
<strong>Explanation:</strong> Subarray [5,5] has maximum sum 5 + 5 = 10.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [-3,-2,-3]
<strong>Output:</strong> -2
<strong>Explanation:</strong> Subarray [-2] has maximum sum -2.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-11"><a class="header" href="#solutions-11">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-maintain-prefix-maximum"><a class="header" href="#solution-1-maintain-prefix-maximum">Solution 1: Maintain Prefix Maximum</a></h3>
<p>The maximum sum of a circular subarray can be divided into two cases:</p>
<ul>
<li>Case 1: The subarray with the maximum sum does not include the circular part, which is the ordinary maximum subarray sum;</li>
<li>Case 2: The subarray with the maximum sum includes the circular part, which can be transformed into: the total sum of the array minus the minimum subarray sum.</li>
</ul>
<p>Therefore, we maintain the following variables:</p>
<ul>
<li>The minimum prefix sum $pmi$, initially $0$;</li>
<li>The maximum prefix sum $pmx$, initially $-\infty$;</li>
<li>The prefix sum $s$, initially $0$;</li>
<li>The minimum subarray sum $smi$, initially $\infty$;</li>
<li>The answer $ans$, initially $-\infty$.</li>
</ul>
<p>Next, we only need to traverse the array $nums$. For the current element $x$ we are traversing, we perform the following update operations:</p>
<ul>
<li>Update the prefix sum $s = s + x$;</li>
<li>Update the answer $ans = \max(ans, s - pmi)$, which is the answer for Case 1 (the prefix sum $s$ minus the minimum prefix sum $pmi$ can give the maximum subarray sum);</li>
<li>Update $smi = \min(smi, s - pmx)$, which is the minimum subarray sum for Case 2;</li>
<li>Update $pmi = \min(pmi, s)$, which is the minimum prefix sum;</li>
<li>Update $pmx = \max(pmx, s)$, which is the maximum prefix sum.</li>
</ul>
<p>After the traversal, we return the maximum value of $ans$ and $s - smi$ as the answer.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-21"><a class="header" href="#python3-21">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -&gt; int:
        pmi, pmx = 0, -inf
        ans, s, smi = -inf, 0, inf
        for x in nums:
            s += x
            ans = max(ans, s - pmi)
            smi = min(smi, s - pmx)
            pmi = min(pmi, s)
            pmx = max(pmx, s)
        return max(ans, s - smi)
</code></pre>
<h4 id="java-19"><a class="header" href="#java-19">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        final int inf = 1 &lt;&lt; 30;
        int pmi = 0, pmx = -inf;
        int ans = -inf, s = 0, smi = inf;
        for (int x : nums) {
            s += x;
            ans = Math.max(ans, s - pmi);
            smi = Math.min(smi, s - pmx);
            pmi = Math.min(pmi, s);
            pmx = Math.max(pmx, s);
        }
        return Math.max(ans, s - smi);
    }
}
</code></pre>
<h4 id="c-23"><a class="header" href="#c-23">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) {
        const int inf = 1 &lt;&lt; 30;
        int pmi = 0, pmx = -inf;
        int ans = -inf, s = 0, smi = inf;
        for (int x : nums) {
            s += x;
            ans = max(ans, s - pmi);
            smi = min(smi, s - pmx);
            pmi = min(pmi, s);
            pmx = max(pmx, s);
        }
        return max(ans, s - smi);
    }
};
</code></pre>
<h4 id="go-19"><a class="header" href="#go-19">Go</a></h4>
<pre><code class="language-go">func maxSubarraySumCircular(nums []int) int {
	const inf = 1 &lt;&lt; 30
	pmi, pmx := 0, -inf
	ans, s, smi := -inf, 0, inf
	for _, x := range nums {
		s += x
		ans = max(ans, s-pmi)
		smi = min(smi, s-pmx)
		pmi = min(pmi, s)
		pmx = max(pmx, s)
	}
	return max(ans, s-smi)
}
</code></pre>
<h4 id="typescript-15"><a class="header" href="#typescript-15">TypeScript</a></h4>
<pre><code class="language-ts">function maxSubarraySumCircular(nums: number[]): number {
    let [pmi, pmx] = [0, -Infinity];
    let [ans, s, smi] = [-Infinity, 0, Infinity];
    for (const x of nums) {
        s += x;
        ans = Math.max(ans, s - pmi);
        smi = Math.min(smi, s - pmx);
        pmi = Math.min(pmi, s);
        pmx = Math.max(pmx, s);
    }
    return Math.max(ans, s - smi);
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 环形数组的子数组最大累加和
// 给定一个数组nums，长度为n
// nums是一个环形数组，下标0和下标n-1是连在一起的
// 返回环形数组中，子数组最大累加和
// 测试链接 : https://leetcode.com/problems/maximum-sum-circular-subarray/
public class Code03_MaximumSumCircularSubarray {

	public static int maxSubarraySumCircular(int[] nums) {
		int n = nums.length, all = nums[0], maxsum = nums[0], minsum = nums[0];
		for (int i = 1, maxpre = nums[0], minpre = nums[0]; i &lt; n; i++) {
			all += nums[i];
			maxpre = Math.max(nums[i], nums[i] + maxpre);
			maxsum = Math.max(maxsum, maxpre);
			minpre = Math.min(nums[i], nums[i] + minpre);
			minsum = Math.min(minsum, minpre);
		}
		// 1) maxsum
		// 2) all - minsum
		return all == minsum ? maxsum : Math.max(maxsum, all - minsum);
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=2320">
    </iframe>
</details>
<h2 id="houserobberii"><a class="header" href="#houserobberii">HouseRobberII</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/0200-0299/0213.House%20Robber%20II/README_EN.md
tags:
    - Array
    - Dynamic Programming
</code></pre>
<!-- problem:start -->
<h1 id="213-house-robber-ii"><a class="header" href="#213-house-robber-ii"><a href="https://leetcode.com/problems/house-robber-ii">213. House Robber II</a></a></h1>
<p><a href="dynamic-programming//solution/0200-0299/0213.House%20Robber%20II/README.html">中文文档</a></p>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<!-- description:start -->
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,3,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>
<p><strong class="example">Example 3:</strong></p>
<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 3
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-12"><a class="header" href="#solutions-12">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-dynamic-programming-5"><a class="header" href="#solution-1-dynamic-programming-5">Solution 1: Dynamic Programming</a></h3>
<p>The circular arrangement means that at most one of the first and last houses can be chosen for theft, so this circular arrangement problem can be reduced to two single-row house problems.</p>
<p>The time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.</p>
<!-- tabs:start -->
<h4 id="python3-22"><a class="header" href="#python3-22">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        def _rob(nums):
            f = g = 0
            for x in nums:
                f, g = max(f, g), f + x
            return max(f, g)

        if len(nums) == 1:
            return nums[0]
        return max(_rob(nums[1:]), _rob(nums[:-1]))
</code></pre>
<h4 id="java-20"><a class="header" href="#java-20">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
    }

    private int rob(int[] nums, int l, int r) {
        int f = 0, g = 0;
        for (; l &lt;= r; ++l) {
            int ff = Math.max(f, g);
            g = f + nums[l];
            f = ff;
        }
        return Math.max(f, g);
    }
}
</code></pre>
<h4 id="c-24"><a class="header" href="#c-24">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        return max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }

    int robRange(vector&lt;int&gt;&amp; nums, int l, int r) {
        int f = 0, g = 0;
        for (; l &lt;= r; ++l) {
            int ff = max(f, g);
            g = f + nums[l];
            f = ff;
        }
        return max(f, g);
    }
};
</code></pre>
<h4 id="go-20"><a class="header" href="#go-20">Go</a></h4>
<pre><code class="language-go">func rob(nums []int) int {
	n := len(nums)
	if n == 1 {
		return nums[0]
	}
	return max(robRange(nums, 0, n-2), robRange(nums, 1, n-1))
}

func robRange(nums []int, l, r int) int {
	f, g := 0, 0
	for _, x := range nums[l : r+1] {
		f, g = max(f, g), f+x
	}
	return max(f, g)
}
</code></pre>
<h4 id="typescript-16"><a class="header" href="#typescript-16">TypeScript</a></h4>
<pre><code class="language-ts">function rob(nums: number[]): number {
    const n = nums.length;
    if (n === 1) {
        return nums[0];
    }
    const robRange = (l: number, r: number): number =&gt; {
        let [f, g] = [0, 0];
        for (; l &lt;= r; ++l) {
            [f, g] = [Math.max(f, g), f + nums[l]];
        }
        return Math.max(f, g);
    };
    return Math.max(robRange(0, n - 2), robRange(1, n - 1));
}
</code></pre>
<h4 id="rust-10"><a class="header" href="#rust-10">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        if n == 1 {
            return nums[0];
        }
        let rob_range = |l, r| {
            let mut f = [0, 0];
            for i in l..r {
                f = [f[0].max(f[1]), f[0] + nums[i]];
            }
            f[0].max(f[1])
        };
        rob_range(0, n - 1).max(rob_range(1, n))
    }
}
<span class="boring">}</span></code></pre></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 环形数组中不能选相邻元素的最大累加和
// 给定一个数组nums，长度为n
// nums是一个环形数组，下标0和下标n-1是连在一起的
// 可以随意选择数字，但是不能选择相邻的数字
// 返回能得到的最大累加和
// 测试链接 : https://leetcode.com/problems/house-robber-ii/
public class Code04_HouseRobberII {

	public static int rob(int[] nums) {
		int n = nums.length;
		if (n == 1) {
			return nums[0];
		}
		return Math.max(best(nums, 1, n - 1), nums[0] + best(nums, 2, n - 2));
	}

	// nums[l....r]范围上，没有环形的概念
	// 返回 : 可以随意选择数字，但不能选择相邻数字的情况下，最大累加和
	public static int best(int[] nums, int l, int r) {
		if (l &gt; r) {
			return 0;
		}
		if (l == r) {
			return nums[l];
		}
		if (l + 1 == r) {
			return Math.max(nums[l], nums[r]);
		}
		int prepre = nums[l];
		int pre = Math.max(nums[l], nums[l + 1]);
		for (int i = l + 2, cur; i &lt;= r; i++) {
			cur = Math.max(pre, nums[i] + Math.max(0, prepre));
			prepre = pre;
			pre = cur;
		}
		return pre;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=2960">
    </iframe>
</details>
<h2 id="houserobberiv"><a class="header" href="#houserobberiv">HouseRobberIV</a></h2>
<details><summary>Description:</summary>
<pre><code>comments: true
difficulty: Medium
edit_url: https://github.com/doocs/leetcode/edit/main/solution/2500-2599/2560.House%20Robber%20IV/README_EN.md
rating: 2081
source: Weekly Contest 331 Q3
tags:
    - Array
    - Binary Search
</code></pre>
<!-- problem:start -->
<h1 id="2560-house-robber-iv"><a class="header" href="#2560-house-robber-iv"><a href="https://leetcode.com/problems/house-robber-iv">2560. House Robber IV</a></a></h1>
<p><a href="dynamic-programming//solution/2500-2599/2560.House%20Robber%20IV/README.html">中文文档</a></p>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<!-- description:start -->
<p>There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he <strong>refuses to steal from adjacent homes</strong>.</p>
<p>The <strong>capability</strong> of the robber is the maximum amount of money he steals from one house of all the houses he robbed.</p>
<p>You are given an integer array <code>nums</code> representing how much money is stashed in each house. More formally, the <code>i<sup>th</sup></code> house from the left has <code>nums[i]</code> dollars.</p>
<p>You are also given an integer <code>k</code>, representing the <strong>minimum</strong> number of houses the robber will steal from. It is always possible to steal at least <code>k</code> houses.</p>
<p>Return <em>the <strong>minimum</strong> capability of the robber out of all the possible ways to steal at least </em><code>k</code><em> houses</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,3,5,9], k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.
</pre>
<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> nums = [2,7,9,3,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>
</ul>
<!-- description:end -->
<h2 id="solutions-13"><a class="header" href="#solutions-13">Solutions</a></h2>
<!-- solution:start -->
<h3 id="solution-1-binary-search--greedy"><a class="header" href="#solution-1-binary-search--greedy">Solution 1: Binary Search + Greedy</a></h3>
<p>The problem is asking for the minimum stealing ability of the thief. We can use binary search to enumerate the stealing ability of the thief. For the enumerated ability $x$, we can use a greedy approach to determine whether the thief can steal at least $k$ houses. Specifically, we traverse the array from left to right. For the current house $i$ we are traversing, if $nums[i] \leq x$ and the difference between the index of $i$ and the last stolen house is greater than $1$, then the thief can steal house $i$. Otherwise, the thief cannot steal house $i$. We accumulate the number of stolen houses. If the number of stolen houses is greater than or equal to $k$, it means that the thief can steal at least $k$ houses, and at this time, the stealing ability $x$ of the thief might be the minimum. Otherwise, the stealing ability $x$ of the thief is not the minimum.</p>
<p>The time complexity is $O(n \times \log m)$, and the space complexity is $O(1)$. Where $n$ and $m$ are the length of the array $nums$ and the maximum value in the array $nums$, respectively.</p>
<!-- tabs:start -->
<h4 id="python3-23"><a class="header" href="#python3-23">Python3</a></h4>
<pre><code class="language-python">class Solution:
    def minCapability(self, nums: List[int], k: int) -&gt; int:
        def f(x):
            cnt, j = 0, -2
            for i, v in enumerate(nums):
                if v &gt; x or i == j + 1:
                    continue
                cnt += 1
                j = i
            return cnt &gt;= k

        return bisect_left(range(max(nums) + 1), True, key=f)
</code></pre>
<h4 id="java-21"><a class="header" href="#java-21">Java</a></h4>
<pre><code class="language-java">class Solution {
    public int minCapability(int[] nums, int k) {
        int left = 0, right = (int) 1e9;
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            if (f(nums, mid) &gt;= k) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int f(int[] nums, int x) {
        int cnt = 0, j = -2;
        for (int i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &gt; x || i == j + 1) {
                continue;
            }
            ++cnt;
            j = i;
        }
        return cnt;
    }
}
</code></pre>
<h4 id="c-25"><a class="header" href="#c-25">C++</a></h4>
<pre><code class="language-cpp">class Solution {
public:
    int minCapability(vector&lt;int&gt;&amp; nums, int k) {
        auto f = [&amp;](int x) {
            int cnt = 0, j = -2;
            for (int i = 0; i &lt; nums.size(); ++i) {
                if (nums[i] &gt; x || i == j + 1) {
                    continue;
                }
                ++cnt;
                j = i;
            }
            return cnt &gt;= k;
        };
        int left = 0, right = *max_element(nums.begin(), nums.end());
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            if (f(mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
</code></pre>
<h4 id="go-21"><a class="header" href="#go-21">Go</a></h4>
<pre><code class="language-go">func minCapability(nums []int, k int) int {
	return sort.Search(1e9+1, func(x int) bool {
		cnt, j := 0, -2
		for i, v := range nums {
			if v &gt; x || i == j+1 {
				continue
			}
			cnt++
			j = i
		}
		return cnt &gt;= k
	})
}
</code></pre>
<h4 id="typescript-17"><a class="header" href="#typescript-17">TypeScript</a></h4>
<pre><code class="language-ts">function minCapability(nums: number[], k: number): number {
    const f = (mx: number): boolean =&gt; {
        let cnt = 0;
        let j = -2;
        for (let i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &lt;= mx &amp;&amp; i - j &gt; 1) {
                ++cnt;
                j = i;
            }
        }
        return cnt &gt;= k;
    };

    let left = 1;
    let right = Math.max(...nums);
    while (left &lt; right) {
        const mid = (left + right) &gt;&gt; 1;
        if (f(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
</code></pre>
<!-- tabs:end -->
<!-- solution:end -->
<!-- problem:end -->
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

// 打家劫舍 IV
// 沿街有一排连续的房屋。每间房屋内都藏有一定的现金
// 现在有一位小偷计划从这些房屋中窃取现金
// 由于相邻的房屋装有相互连通的防盗系统，所以小偷不会窃取相邻的房屋
// 小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额
// 给你一个整数数组 nums 表示每间房屋存放的现金金额
// 第i间房屋中放有nums[i]的钱数
// 另给你一个整数k，表示小偷需要窃取至少 k 间房屋
// 返回小偷需要的最小窃取能力值
// 测试链接 : https://leetcode.com/problems/house-robber-iv/
public class Code05_HouseRobberIV {

	public static int minCapability(int[] nums, int k) {
		int n = nums.length, l = nums[0], r = nums[0];
		for (int i = 1; i &lt; n; i++) {
			l = Math.min(l, nums[i]);
			r = Math.max(r, nums[i]);
		}
		// l....r
		int m, ans = 0;
		while (l &lt;= r) {
			m = (l + r) / 2;
			if (mostRob1(nums, n, m) &gt;= k) {
				ans = m;
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		return ans;
	}

	// 盗贼能力为ability时
	// 返回盗贼最多能窃取多少间房屋
	// 注意限制 : 不能窃取相邻房屋
	public static int mostRob1(int[] nums, int n, int ability) {
		if (n == 1) {
			return nums[0] &lt;= ability ? 1 : 0;
		}
		if (n == 2) {
			return (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		}
		int[] dp = new int[n];
		dp[0] = nums[0] &lt;= ability ? 1 : 0;
		dp[1] = (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		for (int i = 2; i &lt; n; i++) {
			dp[i] = Math.max(dp[i - 1], (nums[i] &lt;= ability ? 1 : 0) + dp[i - 2]);
		}
		return dp[n - 1];
	}

	// 继续空间压缩优化
	public static int mostRob2(int[] nums, int n, int ability) {
		if (n == 1) {
			return nums[0] &lt;= ability ? 1 : 0;
		}
		if (n == 2) {
			return (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		}
		int prepre = nums[0] &lt;= ability ? 1 : 0;
		int pre = (nums[0] &lt;= ability || nums[1] &lt;= ability) ? 1 : 0;
		for (int i = 2, cur; i &lt; n; i++) {
			cur = Math.max(pre, (nums[i] &lt;= ability ? 1 : 0) + prepre);
			prepre = pre;
			pre = cur;
		}
		return pre;
	}

	// 继续贪心优化
	public static int mostRob3(int[] nums, int n, int ability) {
		int ans = 0;
		for (int i = 0; i &lt; n; i++) {
			if (nums[i] &lt;= ability) {
				ans++;
				i++;
			}
		}
		return ans;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=3264">
    </iframe>
</details>
<h2 id="maximumsubmatrix"><a class="header" href="#maximumsubmatrix">MaximumSubmatrix</a></h2>
<details><summary>Description:</summary>
<pre><code class="language-java">// 子矩阵最大累加和问题
// 给定一个二维数组grid，找到其中子矩阵的最大累加和
// 返回拥有最大累加和的子矩阵左上角和右下角坐标
// 如果有多个子矩阵都有最大累加和，返回哪一个都可以
// 测试链接 : https://leetcode.com/problems/max-submatrix-lcci/
</code></pre>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">package class070;

import java.util.Arrays;

// 子矩阵最大累加和问题
// 给定一个二维数组grid，找到其中子矩阵的最大累加和
// 返回拥有最大累加和的子矩阵左上角和右下角坐标
// 如果有多个子矩阵都有最大累加和，返回哪一个都可以
// 测试链接 : https://leetcode.com/problems/max-submatrix-lcci/
public class Code06_MaximumSubmatrix {

	// 如果行和列的规模都是n，时间复杂度O(n^3)，最优解了
	public static int[] getMaxMatrix(int[][] grid) {
		int n = grid.length;
		int m = grid[0].length;
		int max = Integer.MIN_VALUE;
		int a = 0, b = 0, c = 0, d = 0;
		int[] nums = new int[m];
		for (int up = 0; up &lt; n; up++) {
			Arrays.fill(nums, 0);
			for (int down = up; down &lt; n; down++) {
				// 如下代码就是题目1的附加问题 :
				// 子数组中找到拥有最大累加和的子数组
				for (int l = 0, r = 0, pre = Integer.MIN_VALUE; r &lt; m; r++) {
					nums[r] += grid[down][r];
					if (pre &gt;= 0) {
						pre += nums[r];
					} else {
						pre = nums[r];
						l = r;
					}
					if (pre &gt; max) {
						max = pre;
						a = up;
						b = l;
						c = down;
						d = r;
					}
				}
			}
		}
		return new int[] { a, b, c, d };
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/08C6eyZmRFI?start=4417">
    </iframe>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dp-on-intervals-part-1"><a class="header" href="#dp-on-intervals-part-1">DP on Intervals (part 1)</a></h1>
<h2 id="minimum-insertions-to-make-a-string-palindrome"><a class="header" href="#minimum-insertions-to-make-a-string-palindrome">Minimum Insertions to Make a String Palindrome</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome">LeetCode 1312. Minimum Insertion Steps to Make a String Palindrome</a></p>
<p>Given a string s. In one step you can insert any character at any index of the string.</p>
<p>Return the minimum number of steps to make spalindrome.</p>
<p>APalindrome Stringis one that reads the same backward as well as forward.</p>
<pre><code>Example 1:

Input: s = zzazz
Output: 0
Explanation: The string zzazz is already palindrome we do not need any insertions.

Example 2:

Input: s = mbadm
Output: 2
Explanation: String can be mbdadbm or mdbabdm.

Example 3:

Input: s = leetcode
Output: 5
Explanation: Inserting 5 characters the string becomes leetcodocteel.
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 500</li>
<li>s consists of lowercase English letters.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/
public class MinimumInsertionToPalindrome {

	// 暴力尝试
	public static int minInsertions1(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		return f1(s, 0, n - 1);
	}

	// s[l....r]这个范围上的字符串，整体都变成回文串
	// 返回至少插入几个字符
	public static int f1(char[] s, int l, int r) {
		// l &lt;= r
		if (l == r) {
			return 0;
		}
		if (l + 1 == r) {
			return s[l] == s[r] ? 0 : 1;
		}
		// l...r不只两个字符
		if (s[l] == s[r]) {
			return f1(s, l + 1, r - 1);
		} else {
			return Math.min(f1(s, l, r - 1), f1(s, l + 1, r)) + 1;
		}
	}

	// 记忆化搜索
	public static int minInsertions2(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = i; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		return f2(s, 0, n - 1, dp);
	}

	public static int f2(char[] s, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans;
		if (l == r) {
			ans = 0;
		} else if (l + 1 == r) {
			ans = s[l] == s[l + 1] ? 0 : 1;
		} else {
			if (s[l] == s[r]) {
				ans = f2(s, l + 1, r - 1, dp);
			} else {
				ans = Math.min(f2(s, l, r - 1, dp), f2(s, l + 1, r, dp)) + 1;
			}
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int minInsertions3(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[n][n];
		for (int l = 0; l &lt; n - 1; l++) {
			dp[l][l + 1] = s[l] == s[l + 1] ? 0 : 1;
		}
		for (int l = n - 3; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				if (s[l] == s[r]) {
					dp[l][r] = dp[l + 1][r - 1];
				} else {
					dp[l][r] = Math.min(dp[l][r - 1], dp[l + 1][r]) + 1;
				}
			}
		}
		return dp[0][n - 1];
	}

	// 空间压缩
	// 本题有关空间压缩的实现，可以参考讲解067，题目4，最长回文子序列问题的讲解
	// 这两个题空间压缩写法高度相似
	// 因为之前的课多次讲过空间压缩的内容，所以这里不再赘述
	public static int minInsertions4(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		if (n &lt; 2) {
			return 0;
		}
		int[] dp = new int[n];
		dp[n - 1] = s[n - 2] == s[n - 1] ? 0 : 1;
		for (int l = n - 3, leftDown, backUp; l &gt;= 0; l--) {
			leftDown = dp[l + 1];
			dp[l + 1] = s[l] == s[l + 1] ? 0 : 1;
			for (int r = l + 2; r &lt; n; r++) {
				backUp = dp[r];
				if (s[l] == s[r]) {
					dp[r] = leftDown;
				} else {
					dp[r] = Math.min(dp[r - 1], dp[r]) + 1;
				}
				leftDown = backUp;
			}
		}
		return dp[n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=151">
    </iframe>
</details>
<h2 id="predict-the-winner"><a class="header" href="#predict-the-winner">Predict the Winner</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/predict-the-winner">LeetCode 486. Predict the Winner</a></p>
<p>You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.</p>
<p>Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.</p>
<p>Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.</p>
<pre><code>Example 1:

Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.

Example 2:

Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
</code></pre>
<p>Constraints:</p>
<ul>
<li>1 &lt;= nums.length &lt;= 20</li>
<li>0 &lt;= nums[i] &lt;= 10^7</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/predict-the-winner/
public class PredictTheWinner {

	// 暴力尝试
	public static boolean predictTheWinner1(int[] nums) {
		int sum = 0;
		for (int num : nums) {
			sum += num;
		}
		int n = nums.length;
		int first = f1(nums, 0, n - 1);
		int second = sum - first;
		return first &gt;= second;
	}

	// nums[l...r]范围上的数字进行游戏，轮到玩家1
	// 返回玩家1最终能获得多少分数，玩家1和玩家2都绝顶聪明
	public static int f1(int[] nums, int l, int r) {
		if (l == r) {
			return nums[l];
		}
		if (l == r - 1) {
			return Math.max(nums[l], nums[r]);
		}
		// l....r 不只两个数
		// 可能性1 ：玩家1拿走nums[l] l+1...r
		int p1 = nums[l] + Math.min(f1(nums, l + 2, r), f1(nums, l + 1, r - 1));
		// 可能性2 ：玩家1拿走nums[r] l...r-1
		int p2 = nums[r] + Math.min(f1(nums, l + 1, r - 1), f1(nums, l, r - 2));
		return Math.max(p1, p2);
	}

	// 记忆化搜索
	public static boolean predictTheWinner2(int[] nums) {
		int sum = 0;
		for (int num : nums) {
			sum += num;
		}
		int n = nums.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = i; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		int first = f2(nums, 0, n - 1, dp);
		int second = sum - first;
		return first &gt;= second;
	}

	public static int f2(int[] nums, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans;
		if (l == r) {
			ans = nums[l];
		} else if (l == r - 1) {
			ans = Math.max(nums[l], nums[r]);
		} else {
			int p1 = nums[l] + Math.min(f2(nums, l + 2, r, dp), f2(nums, l + 1, r - 1, dp));
			int p2 = nums[r] + Math.min(f2(nums, l + 1, r - 1, dp), f2(nums, l, r - 2, dp));
			ans = Math.max(p1, p2);
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static boolean predictTheWinner3(int[] nums) {
		int sum = 0;
		for (int num : nums) {
			sum += num;
		}
		int n = nums.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n - 1; i++) {
			dp[i][i] = nums[i];
			dp[i][i + 1] = Math.max(nums[i], nums[i + 1]);
		}
		dp[n - 1][n - 1] = nums[n - 1];
		for (int l = n - 3; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				dp[l][r] = Math.max(
						nums[l] + Math.min(dp[l + 2][r], dp[l + 1][r - 1]),
						nums[r] + Math.min(dp[l + 1][r - 1], dp[l][r - 2]));
			}
		}
		int first = dp[0][n - 1];
		int second = sum - first;
		return first &gt;= second;
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=1394">
    </iframe>
</details>
<h2 id="minimum-score-triangulation-of-polygon"><a class="header" href="#minimum-score-triangulation-of-polygon">Minimum Score Triangulation of Polygon</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon">LeetCode 1039. Minimum Score Triangulation of Polygon</a></p>
<p>You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex in clockwise order.</p>
<p>Polygon triangulation is a process where you divide a polygon into a set of triangles and the vertices of each triangle must also be vertices of the original polygon. Note that no other shapes other than triangles are allowed in the division. This process will result in n - 2 triangles.</p>
<p>You will triangulate the polygon. For each triangle, the weight of that triangle is the product of the values at its vertices. The total score of the triangulation is the sum of these weights over all n - 2 triangles.</p>
<p>Return the minimum possible score that you can achieve with some triangulation of the polygon.</p>
<pre><code>Example 1:

Input: values = [1,2,3]

Output: 6

Explanation: The polygon is already triangulated, and the score of the only triangle is 6.

Example 2:

Input: values = [3,7,4,5]

Output: 144

Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.
The minimum score is 144.

Example 3:

Input: values = [1,3,1,4,1,5]

Output: 13

Explanation: The minimum score triangulation is 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.
</code></pre>
<p>Constraints:</p>
<ul>
<li>n = values.length</li>
<li>3 &lt;= n &lt;= 50</li>
<li>1 &lt;= values[i] &lt;= 100</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/minimum-score-triangulation-of-polygon/
public class MinimumScoreTriangulationOfPolygon {

	// 记忆化搜索
	public static int minScoreTriangulation1(int[] arr) {
		int n = arr.length;
		int[][] dp = new int[n][n];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				dp[i][j] = -1;
			}
		}
		return f(arr, 0, n - 1, dp);
	}

	public static int f(int[] arr, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans = Integer.MAX_VALUE;
		if (l == r || l == r - 1) {
			ans = 0;
		} else {
			// l....r &gt;=3
			// 0..1..2..3..4...5
			for (int m = l + 1; m &lt; r; m++) {
				// l m r
				ans = Math.min(ans, f(arr, l, m, dp) + f(arr, m, r, dp) + arr[l] * arr[m] * arr[r]);
			}
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int minScoreTriangulation2(int[] arr) {
		int n = arr.length;
		int[][] dp = new int[n][n];
		for (int l = n - 3; l &gt;= 0; l--) {
			for (int r = l + 2; r &lt; n; r++) {
				dp[l][r] = Integer.MAX_VALUE;
				for (int m = l + 1; m &lt; r; m++) {
					dp[l][r] = Math.min(dp[l][r], dp[l][m] + dp[m][r] + arr[l] * arr[m] * arr[r]);
				}
			}
		}
		return dp[0][n - 1];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=2526">
    </iframe>
</details>
<h2 id="minimum-cost-to-cut-a-stick"><a class="header" href="#minimum-cost-to-cut-a-stick">Minimum Cost to Cut a Stick</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/minimum-cost-to-cut-a-stick">LeetCode 1547. Minimum Cost to Cut a Stick</a></p>
<p>Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:</p>
<p>Given an integer array cuts where cuts[i] denotes a position you should perform a cut at.</p>
<p>You should perform the cuts in order, you can change the order of the cuts as you wish.</p>
<p>The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.</p>
<p>Return the minimum total cost of the cuts.</p>
<pre><code>Example 1:

Input: n = 7, cuts = [1,3,4,5]
Output: 16
Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:

The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).

Example 2:

Input: n = 9, cuts = [5,6,1,4,2]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost = 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.
</code></pre>
<p>Constraints:</p>
<ul>
<li>2 &lt;= n &lt;= 10^6</li>
<li>1 &lt;= cuts.length &lt;= min(n - 1, 100)</li>
<li>1 &lt;= cuts[i] &lt;= n - 1</li>
<li>All the integers in cuts array are distinct.</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">import java.util.Arrays;

// https://leetcode.com/problems/minimum-cost-to-cut-a-stick/
public class MinimumCostToCutAStick {

	// 记忆化搜索
	public static int minCost1(int n, int[] cuts) {
		int m = cuts.length;
		Arrays.sort(cuts);
		int[] arr = new int[m + 2];
		arr[0] = 0;
		for (int i = 1; i &lt;= m; ++i) {
			arr[i] = cuts[i - 1];
		}
		arr[m + 1] = n;
		int[][] dp = new int[m + 2][m + 2];
		for (int i = 1; i &lt;= m; i++) {
			for (int j = 1; j &lt;= m; j++) {
				dp[i][j] = -1;
			}
		}
		return f(arr, 1, m, dp);
	}
	
	// 切点[l....r]，决定一个顺序
	// 让切点都切完，总代价最小
	public static int f(int[] arr, int l, int r, int[][] dp) {
		if (l &gt; r) {
			return 0;
		}
		if (l == r) {
			return arr[r + 1] - arr[l - 1];
		}
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = l; k &lt;= r; k++) {
			ans = Math.min(ans, f(arr, l, k - 1, dp) + f(arr, k + 1, r, dp));
		}
		ans += arr[r + 1] - arr[l - 1];
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int minCost2(int n, int[] cuts) {
		int m = cuts.length;
		Arrays.sort(cuts);
		int[] arr = new int[m + 2];
		arr[0] = 0;
		for (int i = 1; i &lt;= m; ++i) {
			arr[i] = cuts[i - 1];
		}
		arr[m + 1] = n;
		int[][] dp = new int[m + 2][m + 2];
		for (int i = 1; i &lt;= m; i++) {
			dp[i][i] = arr[i + 1] - arr[i - 1];
		}
		for (int l = m - 1, next; l &gt;= 1; l--) {
			for (int r = l + 1; r &lt;= m; r++) {
				next = Integer.MAX_VALUE;
				for (int k = l; k &lt;= r; k++) {
					next = Math.min(next, dp[l][k - 1] + dp[k + 1][r]);
				}
				dp[l][r] = arr[r + 1] - arr[l - 1] + next;
			}
		}
		return dp[1][m];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=3405">
    </iframe>
</details>
<h2 id="burst-balloons"><a class="header" href="#burst-balloons">Burst Balloons</a></h2>
<details><summary>Description:</summary>
<p><a href="https://leetcode.com/problems/burst-balloons">LeetCode 312. Burst Balloons</a></p>
<p>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.</p>
<p>If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.</p>
<p>Return the maximum coins you can collect by bursting the balloons wisely.</p>
<pre><code>Example 1:

Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] -- [3,5,8] -- [3,8] -- [8] -- []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

Example 2:

Input: nums = [1,5]
Output: 10
</code></pre>
<p>Constraints:</p>
<ul>
<li>n = nums.length</li>
<li>1 &lt;= n &lt;= 300</li>
<li>0 &lt;= nums[i] &lt;= 100</li>
</ul>
</details>
<details><summary>Solution:</summary>
<pre><code class="language-java">// https://leetcode.com/problems/burst-balloons/
public class BurstBalloons {

	// 记忆化搜索
	public static int maxCoins1(int[] nums) {
		int n = nums.length;
		// a b c d e
		// 1 a b c d e 1
		int[] arr = new int[n + 2];
		arr[0] = 1;
		arr[n + 1] = 1;
		for (int i = 0; i &lt; n; i++) {
			arr[i + 1] = nums[i];
		}
		int[][] dp = new int[n + 2][n + 2];
		for (int i = 1; i &lt;= n; i++) {
			for (int j = i; j &lt;= n; j++) {
				dp[i][j] = -1;
			}
		}
		return f(arr, 1, n, dp);
	}

	// arr[l...r]这些气球决定一个顺序，获得最大得分返回！
	// 一定有 : arr[l-1]一定没爆！
	// 一定有 : arr[r+1]一定没爆！
	// 尝试每个气球最后打爆
	public static int f(int[] arr, int l, int r, int[][] dp) {
		if (dp[l][r] != -1) {
			return dp[l][r];
		}
		int ans;
		if (l == r) {
			ans = arr[l - 1] * arr[l] * arr[r + 1];
		} else {
			// l   ....r
			// l +1 +2 .. r
			ans = Math.max(
					arr[l - 1] * arr[l] * arr[r + 1] + f(arr, l + 1, r, dp), // l位置的气球最后打爆
					arr[l - 1] * arr[r] * arr[r + 1] + f(arr, l, r - 1, dp));// r位置的气球最后打爆
			for (int k = l + 1; k &lt; r; k++) {
				// k位置的气球最后打爆
				// l...k-1  k  k+1...r
				ans = Math.max(ans, arr[l - 1] * arr[k] * arr[r + 1] + f(arr, l, k - 1, dp) + f(arr, k + 1, r, dp));
			}
		}
		dp[l][r] = ans;
		return ans;
	}

	// 严格位置依赖的动态规划
	public static int maxCoins2(int[] nums) {
		int n = nums.length;
		int[] arr = new int[n + 2];
		arr[0] = 1;
		arr[n + 1] = 1;
		for (int i = 0; i &lt; n; i++) {
			arr[i + 1] = nums[i];
		}
		int[][] dp = new int[n + 2][n + 2];
		for (int i = 1; i &lt;= n; i++) {
			dp[i][i] = arr[i - 1] * arr[i] * arr[i + 1];
		}
		for (int l = n, ans; l &gt;= 1; l--) {
			for (int r = l + 1; r &lt;= n; r++) {
				ans = Math.max(arr[l - 1] * arr[l] * arr[r + 1] + dp[l + 1][r],
						arr[l - 1] * arr[r] * arr[r + 1] + dp[l][r - 1]);
				for (int k = l + 1; k &lt; r; k++) {
					ans = Math.max(ans, arr[l - 1] * arr[k] * arr[r + 1] + dp[l][k - 1] + dp[k + 1][r]);
				}
				dp[l][r] = ans;
			}
		}
		return dp[1][n];
	}

}
</code></pre>
</details>
<details>
    <summary>YouTube Video:</summary>
    <iframe frameborder="0" allowfullscreen
        src="https://www.youtube.com/embed/73EmMoOAxIU?start=4709">
    </iframe>
</details>
<h2 id="boolean-evaluation"><a class="header" href="#boolean-evaluation">Boolean Evaluation</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
